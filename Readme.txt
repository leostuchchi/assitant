–ø—Ä–æ–µ–∫—Ç personal_assistant

–∏—Ç–æ–≥–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –ø—Ä–æ–µ–∫—Ç–∞: 
–ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ —Ä–∞—Å—á–µ—Ç–∞—Ö –∏ –¥–∞–Ω–Ω—ã—Ö, —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–∏ —á–µ–ª–æ–≤–µ–∫—É –Ω–∞ –æ–¥–∏–Ω –¥–µ–Ω—å. –¥–ª—è —Ä–∞–∑–≤–∏—Ç–∏—è, —Å–∞–º–æ—Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —á–µ–ª–æ–≤–µ–∫–∞ –Ω–∞ –±–∞–∑–µ –º–æ–¥–µ–ª–∏ –ò–ò.



–ª–æ–≥–∏–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞:
—Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (tegram bot)
–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã
–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã
—Ä–∞—Å—á–µ—Ç –±–∏–æ—Ä–∏—Ç–º–æ–≤
–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ–¥–∏–Ω –¥–µ–Ω—å, –Ω–∞ –æ—Å–Ω–æ–≤–µ: –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã, –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã, –±–∏–æ—Ä–∏—Ç–º–æ–≤
–≤—ã–≤–æ–¥ —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ–¥–∏–Ω –¥–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (telegram bot)

—Ç–µ–∫—É—â–∞—è –∑–∞–¥–∞—á–∞ –ø—Ä–æ–µ–∫—Ç–∞: 
## üîß **3. –ú–û–î–£–õ–ò, –ó–ê–¢–†–û–ù–£–¢–´–ï –ò–ó–ú–ï–ù–ï–ù–ò–Ø–ú–ò**

### **üî¥ –¢–†–ï–ë–£–Æ–¢ –ò–ó–ú–ï–ù–ï–ù–ò–ô:**

1. **`backend/database.py`** - –Ω–æ–≤—ã–µ –º–æ–¥–µ–ª–∏ –∏ —Å–≤—è–∑–∏
2. **`backend/assistant.py`** - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è AI –¥–≤–∏–∂–∫–∞
3. **`backend/prediction_services.py`** - –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI
4. **`bot/handlers.py`** - –≤—ã–≤–æ–¥ AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
5. **`docker-compose.yml`** - –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ Ollama —Å–µ—Ä–≤–∏—Å–∞

### **üü¢ –ù–û–í–´–ï –ú–û–î–£–õ–ò:**

1. **`backend/ai_engine.py`** - —Ä–∞–±–æ—Ç–∞ —Å Ollama API
2. **`backend/astro_interpreter.py`** - –ø—Ä–µ-–æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞—Å—Ç—Ä–æ–¥–∞–Ω–Ω—ã—Ö
3. **`backend/prompt_builder.py`** - –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø—Ä–æ–º–ø—Ç–æ–≤
4. **`backend/recommendation_cache.py`** - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—ç—à–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
5. **`backend/data_optimizer.py`** - —Å–∂–∞—Ç–∏–µ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö

## ‚öñÔ∏è **4. –í–õ–ò–Ø–ù–ò–ï –ù–ê –°–õ–û–ñ–ù–û–°–¢–¨ –ü–†–û–ï–ö–¢–ê**

### **üü¢ –£–ü–†–û–©–ï–ù–ò–ï:**
- **–ë–æ–ª–µ–µ —á–∏—Å—Ç—ã–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã** - –º–æ–¥—É–ª–∏ –æ–±—â–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ñ–æ—Ä–º–∞—Ç—ã
- **–£–ª—É—á—à–µ–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫** - –∏–∑–æ–ª—è—Ü–∏—è AI –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
- **–õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å** - –º–æ–∫–∏ –¥–ª—è AI –≤—ã–∑–æ–≤–æ–≤
- **–ü—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–∞—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å** - –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç–∞–±–∏–ª–∏–∑–∏—Ä—É–µ—Ç –æ—Ç–∫–ª–∏–∫

### **üî¥ –£–°–õ–û–ñ–ù–ï–ù–ò–ï:**
- **–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–æ–¥—É–ª–µ–π** +5 –Ω–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤
- **–ù–æ–≤—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏** - –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–µ HTTP –∑–∞–ø—Ä–æ—Å—ã, —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
- **–°–ª–æ–∂–Ω–µ–µ –¥–µ–±–∞–∂–∏—Ç—å** - —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è –ª–æ–≥–∏–∫–∞ –º–µ–∂–¥—É –º–æ–¥—É–ª—è–º–∏
- **–¢—Ä–µ–±—É–µ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞** - –∑–¥–æ—Ä–æ–≤—å–µ Ollama, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏

### **‚öñÔ∏è –ë–ê–õ–ê–ù–°:**
**–ß–ò–°–¢–´–ô –í–´–ò–ì–†–´–®** - –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –±–æ–ª–µ–µ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º–æ–π –∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–æ–π, –Ω–µ—Å–º–æ—Ç—Ä—è –Ω–∞ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤.

## üèóÔ∏è **5. –ò–¢–û–ì–û–í–ê–Ø –°–¢–†–£–ö–¢–£–†–ê –ü–†–û–ï–ö–¢–ê**

```
personal_assistant/
‚îú‚îÄ‚îÄ üìÅ bot/
‚îÇ   ‚îú‚îÄ‚îÄ config.py                          # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ handlers.py                        # üî¥ –ò–ó–ú–ï–ù–ò–¢–¨ - –≤—ã–≤–æ–¥ AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
‚îÇ   ‚îú‚îÄ‚îÄ main.py                            # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô  
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ üìÅ backend/
‚îÇ   ‚îú‚îÄ‚îÄ üÜï ai_engine.py                    # üü¢ –ù–û–í–´–ô - —Ä–∞–±–æ—Ç–∞ —Å Ollama API
‚îÇ   ‚îú‚îÄ‚îÄ üÜï astro_interpreter.py            # üü¢ –ù–û–í–´–ô - –ø—Ä–µ-–æ–±—Ä–∞–±–æ—Ç–∫–∞ –∞—Å—Ç—Ä–æ–¥–∞–Ω–Ω—ã—Ö
‚îÇ   ‚îú‚îÄ‚îÄ üÜï prompt_builder.py               # üü¢ –ù–û–í–´–ô - –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–æ–≤
‚îÇ   ‚îú‚îÄ‚îÄ üÜï recommendation_cache.py         # üü¢ –ù–û–í–´–ô - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫—ç—à–µ–º
‚îÇ   ‚îú‚îÄ‚îÄ üÜï data_optimizer.py               # üü¢ –ù–û–í–´–ô - —Å–∂–∞—Ç–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI
‚îÇ   ‚îú‚îÄ‚îÄ assistant.py                       # üî¥ –ò–ó–ú–ï–ù–ò–¢–¨ - –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è AI –¥–≤–∏–∂–∫–∞
‚îÇ   ‚îú‚îÄ‚îÄ prediction_services.py             # üî¥ –ò–ó–ú–ï–ù–ò–¢–¨ - –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–ª—è AI
‚îÇ   ‚îú‚îÄ‚îÄ database.py                        # üî¥ –ò–ó–ú–ï–ù–ò–¢–¨ - –Ω–æ–≤—ã–µ –º–æ–¥–µ–ª–∏ –ë–î
‚îÇ   ‚îú‚îÄ‚îÄ biorhythm_calculator.py            # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ biorhythm_services.py              # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ chart_services.py                  # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ matrix_services.py                 # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ natal_chart.py                     # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ predictions.py                     # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ psyho_matrix.py                    # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ user_services.py                   # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îú‚îÄ‚îÄ db_connection.py                   # ‚úÖ –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
‚îÇ   ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ üìÅ ollama/
‚îÇ   ‚îî‚îÄ‚îÄ docker-compose.yml                 # üî¥ –ò–ó–ú–ï–ù–ò–¢–¨ - –¥–æ–±–∞–≤–∏—Ç—å —Å–µ—Ç–∏
‚îú‚îÄ‚îÄ docker-compose.yml                     # üî¥ –ò–ó–ú–ï–ù–ò–¢–¨ - –¥–æ–±–∞–≤–∏—Ç—å Ollama
‚îî‚îÄ‚îÄ requirements.txt                       # üî¥ –ò–ó–ú–ï–ù–ò–¢–¨ - –Ω–æ–≤—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
```


—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ personal_assistant:

docker-compose.yml

bot: 
config.py
handlers.py
__init__.py
main.py

backend: 
__init__.py
assistant.py
biorhythm_calculator.py
biorhythm_services.py
chart_services.py
database.py
db_connection.py
matrix_services.py
moon.py
natal_chart.py
predictions.py
prediction_services.py
psyho_matrix.py
user_services.py

ollama:
docker-compose.yml:
services:
  ollama:
    image: ollama/ollama:latest
    container_name: ollama_assistant
    ports:
      - "11435:11434"
    volumes:
      - ollama_data:/root/.ollama
    restart: unless-stopped
    environment:
      - OLLAMA_HOST=0.0.0.0
      - OLLAMA_NUM_GPU=0                    # –û—Ç–∫–ª—é—á–∞–µ–º GPU
      - OLLAMA_CPU_COUNT=4                  # –ò—Å–ø–æ–ª—å–∑—É–µ–º 4 CPU —è–¥—Ä–∞
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:11434/api/tags"]
      interval: 30s
      timeout: 15s
      retries: 5
      start_period: 60s
    deploy:
      resources:
        limits:
          memory: 8G                        # 8GB –¥–ª—è CPU-—Ä–µ–∂–∏–º–∞
          cpus: "4.0"                       # 4 CPU —è–¥—Ä–∞
        reservations:
          memory: 6G
          cpus: "3.0"

volumes:
  ollama_data:
    driver: local

networks:
  assistant_net:
    name: personal_assistant_network
    external: true

init-scripts.01-init-tables.sql

-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –∑–∞–ø—É—Å–∫–µ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞

-- –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
CREATE TABLE IF NOT EXISTS users (
    telegram_id BIGINT PRIMARY KEY,
    birth_date DATE NOT NULL,
    birth_time TIME NOT NULL,
    birth_city VARCHAR(100) NOT NULL,
    profession VARCHAR(100),
    job_position VARCHAR(100),
    current_city VARCHAR(100),
    gender VARCHAR(10),
    request_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –Ω–∞—Ç–∞–ª—å–Ω—ã—Ö –∫–∞—Ä—Ç
CREATE TABLE IF NOT EXISTS user_natal_charts (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    natal_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü
CREATE TABLE IF NOT EXISTS psyho_matrix (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    matrix_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π
CREATE TABLE IF NOT EXISTS natal_predictions (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    predictions JSONB NOT NULL,
    assistant_data JSONB NOT NULL DEFAULT '{}',
    data_hash VARCHAR(64),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤
CREATE TABLE IF NOT EXISTS biorhythms (
    telegram_id BIGINT REFERENCES users(telegram_id) ON DELETE CASCADE,
    biorhythm_data JSONB NOT NULL,
    calculation_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (telegram_id, calculation_date)
);

-- –ù–û–í–´–ï –¢–ê–ë–õ–ò–¶–´ –î–õ–Ø AI –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ô:

-- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
CREATE TABLE IF NOT EXISTS ai_recommendations (
    telegram_id BIGINT REFERENCES users(telegram_id) ON DELETE CASCADE,
    target_date DATE NOT NULL,
    data_hash VARCHAR(64) NOT NULL,
    recommendations TEXT NOT NULL,
    model_version VARCHAR(20) DEFAULT 'gemma:2b',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (telegram_id, target_date)
);

-- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –ø—Ä–µ-–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã—Ö –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –∏–Ω—Å–∞–π—Ç–æ–≤
CREATE TABLE IF NOT EXISTS astro_insights (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    dominant_energy JSONB NOT NULL,
    personality_traits JSONB NOT NULL,
    planetary_strengths JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –°–û–ó–î–ê–ù–ò–ï –ò–ù–î–ï–ö–°–û–í –î–õ–Ø –ü–†–û–ò–ó–í–û–î–ò–¢–ï–õ–¨–ù–û–°–¢–ò:

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è users
CREATE INDEX IF NOT EXISTS idx_users_telegram_id ON users(telegram_id);
CREATE INDEX IF NOT EXISTS idx_users_birth_date ON users(birth_date);
CREATE INDEX IF NOT EXISTS idx_users_profession ON users(profession);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –Ω–∞—Ç–∞–ª—å–Ω—ã—Ö –∫–∞—Ä—Ç
CREATE INDEX IF NOT EXISTS idx_user_natal_charts_telegram_id ON user_natal_charts(telegram_id);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü
CREATE INDEX IF NOT EXISTS idx_psyho_matrix_telegram_id ON psyho_matrix(telegram_id);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π
CREATE INDEX IF NOT EXISTS idx_natal_predictions_telegram_id ON natal_predictions(telegram_id);
CREATE INDEX IF NOT EXISTS idx_natal_predictions_hash ON natal_predictions(data_hash);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è –±–∏–æ—Ä–∏—Ç–º–æ–≤
CREATE INDEX IF NOT EXISTS idx_biorhythms_telegram_id ON biorhythms(telegram_id);
CREATE INDEX IF NOT EXISTS idx_biorhythms_calculation_date ON biorhythms(calculation_date);

-- –ò–Ω–¥–µ–∫—Å—ã –¥–ª—è AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
CREATE INDEX IF NOT EXISTS idx_ai_recommendations_hash ON ai_recommendations(data_hash);
CREATE INDEX IF NOT EXISTS idx_ai_recommendations_date ON ai_recommendations(target_date);
CREATE INDEX IF NOT EXISTS idx_ai_recommendations_created ON ai_recommendations(created_at);

-- –ü—Ä–∞–≤–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO pers_assist;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO pers_assist;

-- –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ —Ç–∞–±–ª–∏—Ü–∞–º
COMMENT ON TABLE users IS '–û—Å–Ω–æ–≤–Ω–∞—è —Ç–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω–æ–≥–æ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞';
COMMENT ON TABLE ai_recommendations IS '–ö—ç—à AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –æ—Ç –º–æ–¥–µ–ª–∏ Llama';
COMMENT ON TABLE astro_insights IS '–ü—Ä–µ-–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∏–Ω—Å–∞–π—Ç—ã –¥–ª—è AI';

-- –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
DO $$ 
BEGIN
    RAISE NOTICE '‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö personal_assistant —É—Å–ø–µ—à–Ω–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞';
END $$;




   

docker-compose.yml:
services:
  postgres:
    image: postgres:16
    container_name: postgres_astrology
    environment:
      POSTGRES_DB: p_assistant_bd
      POSTGRES_USER: pers_assist
      POSTGRES_PASSWORD: astra123
      POSTGRES_INITDB_ARGS: "--encoding=UTF8 --lc-collate=C --lc-ctype=C"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init-scripts:/docker-entrypoint-initdb.d
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U pers_assist -d p_assistant_bd"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    deploy:
      resources:
        limits:
          memory: 1G
        reservations:
          memory: 512M

  # –û–ü–¶–ò–û–ù–ê–õ–¨–ù–û: pgAdmin –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ë–î
  pgadmin:
    image: dpage/pgadmin4:latest
    container_name: pgadmin_astrology
    environment:
      PGADMIN_DEFAULT_EMAIL: admin@astrology.local
      PGADMIN_DEFAULT_PASSWORD: admin123
      PGADMIN_CONFIG_SERVER_MODE: 'False'
    ports:
      - "8080:80"
    volumes:
      - pgadmin_data:/var/lib/pgadmin
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
    profiles:
      - admin-tools

volumes:
  postgres_data:
    driver: local
  pgadmin_data:
    driver: local

networks:
  assistant_net:
    driver: bridge
  
–º–æ–¥—É–ª–∏ –ø—Ä–æ–µ–∫—Ç–∞:

bot: 

config.py:

import os
from dotenv import load_dotenv

load_dotenv()

TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

handlers.py:

from aiogram import Router, types
from aiogram.filters import Command, StateFilter
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from datetime import datetime, date, timedelta
import logging

from backend.assistant import assistant

logger = logging.getLogger(__name__)

# –°–æ–∑–¥–∞–µ–º —Ä–æ—É—Ç–µ—Ä
router = Router()


# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
class DataCollectionStates(StatesGroup):
    waiting_for_birth_date = State()
    waiting_for_birth_time = State()
    waiting_for_birth_city = State()
    waiting_for_current_city = State()
    waiting_for_profession = State()
    waiting_for_job_position = State()
    waiting_for_gender = State()  # –ù–û–í–û–ï –°–û–°–¢–û–Ø–ù–ò–ï


# –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ –¥–∞—Ç—ã
class DateSelectionStates(StatesGroup):
    waiting_for_custom_date = State()


# –û—Å–Ω–æ–≤–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
def get_main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã")],
            [KeyboardButton(text="üìÖ –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")],
        ],
        resize_keyboard=True
    )


# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–∞—Ç—ã
def get_date_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìÖ –°–µ–≥–æ–¥–Ω—è"), KeyboardButton(text="üìÖ –ó–∞–≤—Ç—Ä–∞")],
            [KeyboardButton(text="üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É")],
            [KeyboardButton(text="üîô –ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )


# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–ª–∞
def get_gender_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üë® –ú—É–∂—Å–∫–æ–π"), KeyboardButton(text="üë© –ñ–µ–Ω—Å–∫–∏–π")],
            [KeyboardButton(text="ü§∑ –ù–µ —É–∫–∞–∑—ã–≤–∞—Ç—å")]
        ],
        resize_keyboard=True
    )


@router.message(Command("start"))
async def cmd_start(message: types.Message):
    """–ö–æ–º–∞–Ω–¥–∞ –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã —Å –±–æ—Ç–æ–º"""
    welcome_text = """
üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç!

–Ø –ø–æ–º–æ–≥—É –≤–∞–º –ø–æ–ª—É—á–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ:
‚Ä¢ üåü –ù–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –∏ –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —Ç—Ä–∞–Ω–∑–∏—Ç–æ–≤
‚Ä¢ üî¢ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ø–æ –¥–∞—Ç–µ —Ä–æ–∂–¥–µ–Ω–∏—è  
‚Ä¢ ‚ö° –ë–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
‚Ä¢ üíº –í–∞—à–µ–π –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:
    """

    await message.answer(welcome_text, reply_markup=get_main_keyboard())


@router.message(lambda message: message.text == "üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã")
async def start_data_collection(message: types.Message, state: FSMContext):
    """–ù–∞—á–∞–ª–æ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    status = await assistant.get_user_data_status(message.from_user.id)

    if status['is_complete']:
        await message.answer(
            "‚úÖ –í–∞—à–∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —É–∂–µ —Å–æ–±—Ä–∞–Ω—ã!\n"
            "–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Ñ–µ—Å—Å–∏—é –∏–ª–∏ –≥–æ—Ä–æ–¥, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É.",
            reply_markup=get_main_keyboard()
        )
    else:
        await message.answer(
            "üìä –ù–∞—á–Ω–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö!\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à—É –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î:",
            reply_markup=types.ReplyKeyboardRemove()
        )
        await state.set_state(DataCollectionStates.waiting_for_birth_date)


@router.message(DataCollectionStates.waiting_for_birth_date)
async def process_birth_date(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è"""
    try:
        birth_date = datetime.strptime(message.text, "%Y-%m-%d").date()
        await state.update_data(birth_date=birth_date)

        await message.answer(
            "‚úÖ –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n"
            "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (24 —á–∞—Å–∞):"
        )
        await state.set_state(DataCollectionStates.waiting_for_birth_time)

    except ValueError:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –ì–ì–ì–ì-–ú–ú-–î–î:")


@router.message(DataCollectionStates.waiting_for_birth_time)
async def process_birth_time(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Ä–æ–∂–¥–µ–Ω–∏—è"""
    try:
        birth_time = datetime.strptime(message.text, "%H:%M").time()
        await state.update_data(birth_time=birth_time)

        await message.answer(
            "‚úÖ –í—Ä–µ–º—è —Ä–æ–∂–¥–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ!\n\n"
            "–í–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ —Ä–æ–∂–¥–µ–Ω–∏—è:"
        )
        await state.set_state(DataCollectionStates.waiting_for_birth_city)

    except ValueError:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –ß–ß:–ú–ú:")


@router.message(DataCollectionStates.waiting_for_birth_city)
async def process_birth_city(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ—Ä–æ–¥–∞ —Ä–æ–∂–¥–µ–Ω–∏—è"""
    birth_city = message.text.strip()
    await state.update_data(birth_city=birth_city)

    await message.answer(
        "‚úÖ –ì–æ—Ä–æ–¥ —Ä–æ–∂–¥–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n"
        "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è:"
    )
    await state.set_state(DataCollectionStates.waiting_for_current_city)


@router.message(DataCollectionStates.waiting_for_current_city)
async def process_current_city(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ—Ä–æ–¥–∞ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è"""
    current_city = message.text.strip()
    await state.update_data(current_city=current_city)

    await message.answer(
        "‚úÖ –ì–æ—Ä–æ–¥ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à—É —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å –∏–ª–∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏—é:"
    )
    await state.set_state(DataCollectionStates.waiting_for_profession)


@router.message(DataCollectionStates.waiting_for_profession)
async def process_profession(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏"""
    profession = message.text.strip()
    await state.update_data(profession=profession)

    await message.answer(
        "‚úÖ –ü—Ä–æ—Ñ–µ—Å—Å–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à—É –¥–æ–ª–∂–Ω–æ—Å—Ç—å (–µ—Å–ª–∏ –Ω–µ—Ç - –Ω–∞–ø–∏—à–∏—Ç–µ '–Ω–µ—Ç'):"
    )
    await state.set_state(DataCollectionStates.waiting_for_job_position)


@router.message(DataCollectionStates.waiting_for_job_position)
async def process_job_position(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–∏ –∏ –ø–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É –ø–æ–ª–∞"""
    job_position = message.text.strip()
    if job_position.lower() == '–Ω–µ—Ç':
        job_position = None

    await state.update_data(job_position=job_position)

    await message.answer(
        "‚úÖ –î–æ–ª–∂–Ω–æ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n"
        "–£–∫–∞–∂–∏—Ç–µ –≤–∞—à –ø–æ–ª:",
        reply_markup=get_gender_keyboard()
    )
    await state.set_state(DataCollectionStates.waiting_for_gender)


@router.message(DataCollectionStates.waiting_for_gender)
async def process_gender(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª–∞ –∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
    gender_map = {
        "üë® –º—É–∂—Å–∫–æ–π": "male",
        "üë© –∂–µ–Ω—Å–∫–∏–π": "female",
        "ü§∑ –Ω–µ —É–∫–∞–∑—ã–≤–∞—Ç—å": None
    }

    gender_text = message.text.lower()
    gender = None

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–ª –ø–æ —Ç–µ–∫—Å—Ç—É
    for key, value in gender_map.items():
        if key in gender_text:
            gender = value
            break

    # –ï—Å–ª–∏ –ø–æ–ª –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç –∫–∞–∫ –µ—Å—Ç—å
    if gender is None:
        if any(word in gender_text for word in ["–º—É–∂", "male", "–º"]):
            gender = "male"
        elif any(word in gender_text for word in ["–∂–µ–Ω", "female", "–∂"]):
            gender = "female"
        else:
            gender = None

    await state.update_data(gender=gender)
    user_data = await state.get_data()

    try:
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
        result = await assistant.collect_user_data(
            telegram_id=message.from_user.id,
            birth_date=user_data['birth_date'],
            birth_time=user_data['birth_time'],
            birth_city=user_data['birth_city'],
            current_city=user_data['current_city'],
            profession=user_data['profession'],
            job_position=user_data.get('job_position'),
            gender=gender  # –ü–ï–†–ï–î–ê–ï–ú –ü–û–õ
        )

        if result['success']:
            await message.answer(
                "üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–±—Ä–∞–Ω—ã!\n\n"
                "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:",
                reply_markup=get_main_keyboard()
            )
        else:
            await message.answer(
                f"‚ùå {result['message']}\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∑–∞–Ω–æ–≤–æ.",
                reply_markup=get_main_keyboard()
            )

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
        await message.answer(
            f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö: {str(e)}\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∑–∞–Ω–æ–≤–æ.",
            reply_markup=get_main_keyboard()
        )

    await state.clear()


@router.message(lambda message: message.text == "üìÖ –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")
async def select_date_option(message: types.Message):
    """–í—ã–±–æ—Ä –¥–∞—Ç—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –¥–∞–Ω–Ω—ã—Ö
    status = await assistant.get_user_data_status(message.from_user.id)
    if not status['is_complete']:
        await message.answer(
            "‚ùå –°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–æ–±—Ä–∞—Ç—å –¥–∞–Ω–Ω—ã–µ!\n"
            "–ù–∞–∂–º–∏—Ç–µ 'üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã'",
            reply_markup=get_main_keyboard()
        )
        return

    await message.answer(
        "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤:",
        reply_markup=get_date_keyboard()
    )


@router.message(lambda message: message.text == "üìÖ –°–µ–≥–æ–¥–Ω—è")
async def get_todays_data(message: types.Message):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"""
    await process_date_selection(message, date.today())


@router.message(lambda message: message.text == "üìÖ –ó–∞–≤—Ç—Ä–∞")
async def get_tomorrows_data(message: types.Message):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –∑–∞–≤—Ç—Ä–∞"""
    tomorrow = date.today() + timedelta(days=1)
    await process_date_selection(message, tomorrow)


@router.message(lambda message: message.text == "üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É")
async def request_custom_date(message: types.Message, state: FSMContext):
    """–ó–∞–ø—Ä–æ—Å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π –¥–∞—Ç—ã"""
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î:",
        reply_markup=types.ReplyKeyboardRemove()
    )
    await state.set_state(DateSelectionStates.waiting_for_custom_date)


@router.message(DateSelectionStates.waiting_for_custom_date)
async def process_custom_date(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–µ–¥–µ–Ω–Ω–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –¥–∞—Ç—ã"""
    try:
        target_date = datetime.strptime(message.text, "%Y-%m-%d").date()

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –¥–∞—Ç–∞ –Ω–µ –≤ –ø—Ä–æ—à–ª–æ–º
        if target_date < date.today():
            await message.answer(
                "‚ùå –ú–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏–ª–∏ –±—É–¥—É—â–∏–µ –¥–∞—Ç—ã",
                reply_markup=get_date_keyboard()
            )
            return

        await process_date_selection(message, target_date)

    except ValueError:
        await message.answer(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î",
            reply_markup=get_date_keyboard()
        )

    await state.clear()


@router.message(lambda message: message.text == "üîô –ù–∞–∑–∞–¥")
async def go_back_to_main(message: types.Message):
    """–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    await message.answer(
        "–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
        reply_markup=get_main_keyboard()
    )


async def process_date_selection(message: types.Message, target_date: date):
    """–û–±—â–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –¥–∞—Ç—ã"""
    processing_msg = await message.answer(f"üîÑ –§–æ—Ä–º–∏—Ä—É—é –¥–∞–Ω–Ω—ã–µ –Ω–∞ {target_date.strftime('%d.%m.%Y')}...")

    try:
        result = await assistant.get_recommendations(message.from_user.id, target_date)

        if result['success']:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            await message.answer(result['user_data'], parse_mode="Markdown")

            # –î–∞–Ω–Ω—ã–µ –¥–ª—è –º–æ–¥–µ–ª–∏ —É–∂–µ –≤—ã–≤–æ–¥—è—Ç—Å—è —á–µ—Ä–µ–∑ print –≤ assistant.py
            await message.answer(
                f"ü§ñ *–î–∞–Ω–Ω—ã–µ –Ω–∞ {target_date.strftime('%d.%m.%Y')} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ AI –º–æ–¥–µ–ª—å*\n"
                "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—É–¥—É—Ç –¥–æ—Å—Ç—É–ø–Ω—ã –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è!",
                parse_mode="Markdown",
                reply_markup=get_main_keyboard()
            )
        else:
            await message.answer(
                result['message'],
                reply_markup=get_main_keyboard()
            )

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è: {e}")
        await message.answer(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.",
            reply_markup=get_main_keyboard()
        )

    await processing_msg.delete()


@router.message(Command("status"))
async def cmd_status(message: types.Message):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        status = await assistant.get_user_data_status(message.from_user.id)

        status_text = "üìä **–°—Ç–∞—Ç—É—Å –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö:**\n\n"

        if status['is_complete']:
            status_text += "‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é\n\n"
        else:
            status_text += "‚ùå –ù–µ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω—ã\n\n"

        status_text += f"‚Ä¢ –û—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {'‚úÖ' if status['has_basic_data'] else '‚ùå'}\n"
        status_text += f"‚Ä¢ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞: {'‚úÖ' if status['has_natal_chart'] else '‚ùå'}\n"
        status_text += f"‚Ä¢ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞: {'‚úÖ' if status['has_psyho_matrix'] else '‚ùå'}\n"
        status_text += f"‚Ä¢ –ë–∏–æ—Ä–∏—Ç–º—ã: {'‚úÖ' if status['has_biorhythms'] else '‚ùå'}\n\n"

        if not status['is_complete']:
            status_text += "–ù–∞–∂–º–∏—Ç–µ 'üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã' –¥–ª—è —Å–±–æ—Ä–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö"

        await message.answer(status_text, parse_mode="Markdown")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞: {e}")
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –¥–∞–Ω–Ω—ã—Ö")


@router.message(Command("help"))
async def cmd_help(message: types.Message):
    """–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º –±–æ—Ç–∞"""
    help_text = """
üìã **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**

/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º
/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É

**–û—Å–Ω–æ–≤–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è:**

üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã - –°–æ–±—Ä–∞—Ç—å –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ
üìÖ –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ - –ü–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—á–µ—Ç—ã –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É

**–í—ã–±–æ—Ä –¥–∞—Ç—ã:**
‚Ä¢ üìÖ –°–µ–≥–æ–¥–Ω—è - –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
‚Ä¢ üìÖ –ó–∞–≤—Ç—Ä–∞ - –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å  
‚Ä¢ üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É - –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–∞—è –¥–∞—Ç–∞ (–ì–ì–ì–ì-–ú–ú-–î–î)

**–ß—Ç–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è:**
‚Ä¢ –ê—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∞–Ω–∑–∏—Ç—ã –∏ –∞—Å–ø–µ–∫—Ç—ã
‚Ä¢ –ë–∏–æ—Ä–∏—Ç–º—ã (—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π, –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π)
‚Ä¢ –ù—É–º–µ—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞
‚Ä¢ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ AI –º–æ–¥–µ–ª—å –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
    """

    await message.answer(help_text, parse_mode="Markdown")


@router.message()
async def handle_other_messages(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:",
        reply_markup=get_main_keyboard()
    )


__init__.py:
"""
–ü–∞–∫–µ—Ç –±–æ—Ç–∞ Personal Assistant
"""

__version__ = "1.0.0"
__author__ = "Personal Assistant Team"

from bot.main import main

__all__ = ['main']

main.py:

from aiogram import Bot, Dispatcher
import asyncio
import logging

from bot.config import TOKEN
from bot.handlers import router
from backend.db_connection import check_db_connection
import math
from datetime import date, datetime
from typing import Dict, List, Tuple
import logging

logger = logging.getLogger(__name__)


class BiorhythmCalculator:
    """
    –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è.
    –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª—ã.
    """

    def __init__(self):
        # –ü–µ—Ä–∏–æ–¥—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤ –≤ –¥–Ω—è—Ö
        self.PHYSICAL_CYCLE = 23
        self.EMOTIONAL_CYCLE = 28
        self.INTELLECTUAL_CYCLE = 33
        self.INTUITIVE_CYCLE = 38  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª

    def calculate_biorhythms(self, birth_date: date, target_date: date) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –∑–∞–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É

        Args:
            birth_date: –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è
            target_date: –î–∞—Ç–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞

        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤
        """
        try:
            # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            days_lived = (target_date - birth_date).days

            if days_lived < 0:
                raise ValueError("–î–∞—Ç–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è")

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤
            physical = self._calculate_cycle(days_lived, self.PHYSICAL_CYCLE)
            emotional = self._calculate_cycle(days_lived, self.EMOTIONAL_CYCLE)
            intellectual = self._calculate_cycle(days_lived, self.INTELLECTUAL_CYCLE)
            intuitive = self._calculate_cycle(days_lived, self.INTUITIVE_CYCLE)

            # –û–±—â–∏–π –ø–æ–∫–∞–∑–∞—Ç–µ–ª—å —ç–Ω–µ—Ä–≥–∏–∏
            overall_energy = self._calculate_overall_energy(physical, emotional, intellectual, intuitive)

            # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤
            recommendations = self._generate_recommendations(physical, emotional, intellectual, intuitive,
                                                             overall_energy)

            biorhythm_data = {
                'calculation_date': target_date.isoformat(),
                'days_lived': days_lived,
                'cycles': {
                    'physical': physical,
                    'emotional': emotional,
                    'intellectual': intellectual,
                    'intuitive': intuitive
                },
                'overall_energy': overall_energy,
                'recommendations': recommendations,
                'critical_days': self._find_critical_days(physical, emotional, intellectual, target_date),
                'peak_days': self._find_peak_days(physical, emotional, intellectual, target_date)
            }

            logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –¥–ª—è {target_date}, –ø—Ä–æ–∂–∏—Ç–æ –¥–Ω–µ–π: {days_lived}")
            return biorhythm_data

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
            raise

    def _calculate_cycle(self, days_lived: int, cycle_length: int) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –æ–¥–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –±–∏–æ—Ä–∏—Ç–º–∞

        Args:
            days_lived: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            cycle_length: –î–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ –≤ –¥–Ω—è—Ö

        Returns:
            –î–∞–Ω–Ω—ã–µ —Ü–∏–∫–ª–∞
        """
        # –¢–µ–∫—É—â–∞—è —Ñ–∞–∑–∞ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö (2œÄ –∑–∞ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª)
        phase = (2 * math.pi * days_lived) / cycle_length

        # –ó–Ω–∞—á–µ–Ω–∏–µ —Å–∏–Ω—É—Å–æ–∏–¥—ã (-1 –¥–æ +1)
        value = math.sin(phase)

        # –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞ (0% –¥–æ 100%)
        percentage = ((value + 1) / 2) * 100

        # –î–µ–Ω—å –≤ —Ü–∏–∫–ª–µ (0 –¥–æ cycle_length-1)
        day_in_cycle = days_lived % cycle_length

        return {
            'value': round(value, 4),
            'percentage': round(percentage, 2),
            'day_in_cycle': day_in_cycle,
            'phase': self._get_phase_description(value),
            'trend': self._get_trend(phase)
        }

    def _get_phase_description(self, value: float) -> str:
        """–û–ø–∏—Å–∞–Ω–∏–µ —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–∞"""
        if value >= 0.7:
            return "–ø–∏–∫ —ç–Ω–µ—Ä–≥–∏–∏"
        elif value >= 0.3:
            return "–≤—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        elif value >= -0.3:
            return "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è —Ñ–∞–∑–∞"
        elif value >= -0.7:
            return "–Ω–∏–∑–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        else:
            return "–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Ç–æ—á–∫–∞"

    def _get_trend(self, phase: float) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞ (—Ä–∞—Å—Ç–µ—Ç/–ø–∞–¥–∞–µ—Ç)"""
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é (cos(phase))
        derivative = math.cos(phase)

        if derivative > 0.1:
            return "—Ä–∞—Å—Ç–µ—Ç"
        elif derivative < -0.1:
            return "–ø–∞–¥–∞–µ—Ç"
        else:
            return "—Å—Ç–∞–±–∏–ª—å–Ω–æ"

    def _calculate_overall_energy(self, physical: Dict, emotional: Dict, intellectual: Dict, intuitive: Dict) -> Dict:
        """–†–∞—Å—á–µ—Ç –æ–±—â–µ–≥–æ —É—Ä–æ–≤–Ω—è —ç–Ω–µ—Ä–≥–∏–∏"""
        # –í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –≤—Å–µ—Ö —Ü–∏–∫–ª–æ–≤
        total_energy = (
                physical['value'] * 0.3 +  # –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª - 30%
                emotional['value'] * 0.25 +  # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π - 25%
                intellectual['value'] * 0.25 +  # –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π - 25%
                intuitive['value'] * 0.2  # –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π - 20%
        )

        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–æ 0-100%
        energy_percentage = ((total_energy + 1) / 2) * 100

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å —ç–Ω–µ—Ä–≥–∏–∏
        if energy_percentage >= 80:
            level = "–æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π"
            description = "–û—Ç–ª–∏—á–Ω—ã–π –¥–µ–Ω—å –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –∏ –≤–∞–∂–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π"
        elif energy_percentage >= 60:
            level = "–≤—ã—Å–æ–∫–∏–π"
            description = "–•–æ—Ä–æ—à–∏–π –¥–µ–Ω—å –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã"
        elif energy_percentage >= 40:
            level = "—Å—Ä–µ–¥–Ω–∏–π"
            description = "–°—Ç–∞–±–∏–ª—å–Ω—ã–π –¥–µ–Ω—å, –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è —Ä—É—Ç–∏–Ω–Ω—ã—Ö –∑–∞–¥–∞—á"
        elif energy_percentage >= 20:
            level = "–Ω–∏–∑–∫–∏–π"
            description = "–î–µ–Ω—å –¥–ª—è –æ—Ç–¥—ã—Ö–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–ª"
        else:
            level = "–æ—á–µ–Ω—å –Ω–∏–∑–∫–∏–π"
            description = "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –±–µ—Ä–µ—á—å —ç–Ω–µ—Ä–≥–∏—é, –∏–∑–±–µ–≥–∞—Ç—å –Ω–∞–≥—Ä—É–∑–æ–∫"

        return {
            'value': round(total_energy, 4),
            'percentage': round(energy_percentage, 2),
            'level': level,
            'description': description
        }

    def _generate_recommendations(self, physical: Dict, emotional: Dict, intellectual: Dict, intuitive: Dict,
                                  overall: Dict) -> List[str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤"""
        recommendations = []

        # –§–∏–∑–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if physical['value'] > 0.5:
            recommendations.append("üí™ –ò–¥–µ–∞–ª—å–Ω—ã–π –¥–µ–Ω—å –¥–ª—è —Å–ø–æ—Ä—Ç–∞ –∏ —Ñ–∏–∑–∏—á–µ—Å–∫–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏")
        elif physical['value'] < -0.5:
            recommendations.append("üõå –ò–∑–±–µ–≥–∞–π—Ç–µ —Ç—è–∂–µ–ª—ã—Ö —Ñ–∏–∑–∏—á–µ—Å–∫–∏—Ö –Ω–∞–≥—Ä—É–∑–æ–∫")

        # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if emotional['value'] > 0.6:
            recommendations.append("üòä –û—Ç–ª–∏—á–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è –æ–±—â–µ–Ω–∏—è –∏ –Ω–æ–≤—ã—Ö –∑–Ω–∞–∫–æ–º—Å—Ç–≤")
        elif emotional['value'] < -0.4:
            recommendations.append("üßò –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ —ç–º–æ—Ü–∏–∏, –∏–∑–±–µ–≥–∞–π—Ç–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤")

        # –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if intellectual['value'] > 0.5:
            recommendations.append("üìö –ë–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –∏ –∞–Ω–∞–ª–∏–∑–∞")
        elif intellectual['value'] < -0.3:
            recommendations.append("üìù –û—Ç–ª–æ–∂–∏—Ç–µ —Å–ª–æ–∂–Ω—ã–µ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ –∑–∞–¥–∞—á–∏")

        # –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if intuitive['value'] > 0.4:
            recommendations.append("üîÆ –î–æ–≤–µ—Ä—è–π—Ç–µ –∏–Ω—Ç—É–∏—Ü–∏–∏ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ —Ä–µ—à–µ–Ω–∏–π")

        # –û–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —ç–Ω–µ—Ä–≥–∏–∏
        if overall['percentage'] > 70:
            recommendations.append("üöÄ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—ã—Å–æ–∫—É—é —ç–Ω–µ—Ä–≥–∏—é –¥–ª—è –≤–∞–∂–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤")
        elif overall['percentage'] < 30:
            recommendations.append("‚ö° –≠–∫–æ–Ω–æ–º—å—Ç–µ —Å–∏–ª—ã, –ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –ø–µ—Ä–µ—Ä—ã–≤—ã")

        # –ï—Å–ª–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –º–∞–ª–æ, –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—â–∏–µ
        if len(recommendations) < 3:
            recommendations.extend([
                "üìÖ –°–ª–µ–¥—É–π—Ç–µ —Å–≤–æ–µ–º—É –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º—É —Ä–∏—Ç–º—É",
                "‚è∞ –ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ –∑–∞–¥–∞—á–∏ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø–∏–∫–∞–º–∏",
                "üíß –ü–µ–π—Ç–µË∂≥Â§ü –≤–æ–¥—ã –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏"
            ])

        return recommendations[:5]  # –ù–µ –±–æ–ª–µ–µ 5 —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π

    def _find_critical_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –¥–Ω–µ–π (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π)"""
        critical_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (abs(physical['value']) > 0.9 or
                abs(emotional['value']) > 0.9 or
                abs(intellectual['value']) > 0.9):
            critical_days.append({
                'date': target_date.isoformat(),
                'cycles': self._get_critical_cycles(physical, emotional, intellectual),
                'description': '–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –¥–µ–Ω—å - –±—É–¥—å—Ç–µ –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã'
            })

        return critical_days

    def _find_peak_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–∏–∫–æ–≤—ã—Ö –¥–Ω–µ–π (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π)"""
        peak_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (physical['value'] > 0.8 or
                emotional['value'] > 0.8 or
                intellectual['value'] > 0.8):

            peak_cycles = []
            if physical['value'] > 0.8: peak_cycles.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
            if emotional['value'] > 0.8: peak_cycles.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
            if intellectual['value'] > 0.8: peak_cycles.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')

            peak_days.append({
                'date': target_date.isoformat(),
                'cycles': peak_cycles,
                'description': f'–ü–∏–∫ —ç–Ω–µ—Ä–≥–∏–∏ –≤ —Ü–∏–∫–ª–∞—Ö: {", ".join(peak_cycles)}'
            })

        return peak_days

    def _get_critical_cycles(self, physical: Dict, emotional: Dict, intellectual: Dict) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ü–∏–∫–ª–æ–≤"""
        critical = []
        if abs(physical['value']) > 0.9: critical.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
        if abs(emotional['value']) > 0.9: critical.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
        if abs(intellectual['value']) > 0.9: critical.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')
        return critical

    def calculate_weekly_forecast(self, birth_date: date, start_date: date, days: int = 7) -> List[Dict]:
        """–†–∞—Å—á–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π"""
        forecast = []

        for i in range(days):
            current_date = start_date + timedelta(days=i)
            biorhythms = self.calculate_biorhythms(birth_date, current_date)

            forecast.append({
                'date': current_date.isoformat(),
                'overall_energy': biorhythms['overall_energy']['percentage'],
                'physical': biorhythms['cycles']['physical']['percentage'],
                'emotional': biorhythms['cycles']['emotional']['percentage'],
                'intellectual': biorhythms['cycles']['intellectual']['percentage'],
                'is_critical': len(biorhythms['critical_days']) > 0,
                'is_peak': len(biorhythms['peak_days']) > 0
            })

        return forecast
# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


async def main():
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
        logger.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö...")
        db_connected = await check_db_connection()

        if not db_connected:
            logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã.")
            return

        bot = Bot(token=TOKEN)
        dp = Dispatcher()

        # –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–æ—É—Ç–µ—Ä
        dp.include_router(router)

        logger.info("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ...")
        logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
        logger.info("‚úÖ Personal Assistant –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–ª–∏–Ω–≥
        await dp.start_polling(bot)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")
    finally:
        if 'bot' in locals():
            await bot.close()
        logger.info("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")


if __name__ == "__main__":
    asyncio.run(main())


backend: 

__init__.py

from backend.user_services import create_or_update_user, get_user_profile, update_user_profession, \
    increment_request_count
from backend.chart_services import create_and_save_natal_chart, get_user_natal_chart
from backend.matrix_services import calculate_and_save_psyho_matrix, get_user_matrix
from backend.prediction_services import generate_and_save_prediction, get_user_predictions, \
    format_data_for_user, format_data_for_model
from backend.biorhythm_services import calculate_and_save_biorhythms, get_user_biorhythms
from backend.database import async_session
from datetime import datetime, date, timedelta
from backend.moon import calculate_lunar_phase
import logging
import asyncio
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)


class PersonalAssistant:
    """–ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –ø–æ–º–æ—â–Ω–∏–∫–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—Å–µ–º–∏ –¥–∞–Ω–Ω—ã–º–∏ —Å AI –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π"""

    def __init__(self):
        self.ai_engine = None
        self._ai_engine_initialized = False

    async def _initialize_ai_engine(self):
        """–õ–µ–Ω–∏–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è AI –¥–≤–∏–∂–∫–∞"""
        if not self._ai_engine_initialized:
            try:
                from backend.ai_engine import ai_engine
                self.ai_engine = ai_engine
                self._ai_engine_initialized = True
                logger.info("‚úÖ AI –¥–≤–∏–∂–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")
            except ImportError as e:
                logger.warning(f"‚ö†Ô∏è AI –¥–≤–∏–∂–æ–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")
                self._ai_engine_initialized = True

    async def collect_user_data(self, telegram_id: int, birth_date: date, birth_time: datetime.time,
                                birth_city: str, current_city: str = None, profession: str = None,
                                job_position: str = None, gender: str = None):
        """–°–±–æ—Ä –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            logger.info(f"üîÑ –ù–∞—á–∞–ª–æ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏ –æ–ø–µ—Ä–∞—Ü–∏–π
            async with async_session() as session:
                try:
                    # 1. –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    user = await create_or_update_user(
                        telegram_id=telegram_id,
                        birth_date=birth_date,
                        birth_time=birth_time,
                        birth_city=birth_city,
                        current_city=current_city,
                        profession=profession,
                        job_position=job_position,
                        gender=gender
                    )
                    logger.info(f"‚úÖ –î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã")

                    # 2. –°–æ–∑–¥–∞–µ–º –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É
                    birth_datetime = datetime.combine(birth_date, birth_time)
                    natal_chart = await create_and_save_natal_chart(
                        telegram_id=telegram_id,
                        city=birth_city,
                        birth_datetime=birth_datetime,
                        timezone="Europe/Moscow"
                    )
                    logger.info(f"‚úÖ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞")

                    # 3. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
                    matrix_data = await calculate_and_save_psyho_matrix(telegram_id)
                    logger.info(f"‚úÖ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–∞")

                    # 4. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∏–æ—Ä–∏—Ç–º—ã –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
                    biorhythms = await calculate_and_save_biorhythms(telegram_id)
                    logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã")

                    await session.commit()

                    return {
                        'success': True,
                        'message': "‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–±—Ä–∞–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!",
                        'data_collected': {
                            'user_profile': True,
                            'natal_chart': True,
                            'psyho_matrix': True,
                            'biorhythms': True
                        }
                    }

                except Exception as e:
                    await session.rollback()
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
                    raise

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
            }

    async def get_recommendations(self, telegram_id: int, target_date: date, include_ai: bool = False):
        """
        –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É
        include_ai: –µ—Å–ª–∏ False - –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Ä–∞—Å—á–µ—Ç—ã (–º–≥–Ω–æ–≤–µ–Ω–Ω–æ)
        """
        try:
            logger.info(f"üìÖ –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ {target_date} –¥–ª—è {telegram_id}")

            # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π
            await increment_request_count(telegram_id)
            logger.info(f"üìà –°—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π —É–≤–µ–ª–∏—á–µ–Ω –¥–ª—è {telegram_id}")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –¥–∞—Ç–∞ –Ω–µ –≤ –ø—Ä–æ—à–ª–æ–º
            if target_date < date.today():
                return {
                    'success': False,
                    'message': "‚ùå –ù–µ–ª—å–∑—è –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ—à–µ–¥—à–∏—Ö –¥–∞—Ç"
                }

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –¥–∞—Ç—ã
            prediction = await generate_and_save_prediction(telegram_id, target_date)

            # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –º–æ–¥–µ–ª–∏
            user_profile = await get_user_profile(telegram_id)
            if not user_profile:
                return {
                    'success': False,
                    'message': "‚ùå –ü—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω"
                }

            # 1. –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—á–µ—Ä–µ–∑ –±–æ—Ç)
            user_data = await format_data_for_user(prediction)

            result = {
                'success': True,
                'date': target_date.isoformat(),
                'user_data': user_data,
                'prediction_data': prediction,  # –î–∞–Ω–Ω—ã–µ –¥–ª—è AI
                'user_profile': user_profile  # –ü—Ä–æ—Ñ–∏–ª—å –¥–ª—è AI
            }

            # 2. AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¢–û–õ–¨–ö–û –µ—Å–ª–∏ —è–≤–Ω–æ –∑–∞–ø—Ä–æ—à–µ–Ω—ã
            if include_ai:
                logger.info(f"ü§ñ –í–∫–ª—é—á–µ–Ω–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –¥–ª—è {telegram_id}")
                ai_result = await self._get_ai_recommendations(telegram_id, user_profile, prediction, target_date)
                result.update({
                    'ai_recommendations': ai_result.get('recommendations', {}),
                    'ai_success': ai_result.get('success', False),
                    'is_fallback': ai_result.get('is_fallback', False),
                    'ai_error': ai_result.get('error')
                })
            else:
                logger.info(f"‚ö° AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –æ—Ç–∫–ª—é—á–µ–Ω—ã –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∫–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö {telegram_id}")

            return result

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –Ω–∞ {target_date} –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É: {str(e)}"
            }

    async def get_ai_recommendations_async(self, telegram_id: int, target_date: date,
                                           prediction_data: dict, user_profile: dict):
        """
        –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–µ –ø–æ–ª—É—á–µ–Ω–∏–µ AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π (–¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ handlers)
        """
        try:
            logger.info(f"üîÑ –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –¥–ª—è {telegram_id}")

            # –õ–µ–Ω–∏–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è AI –¥–≤–∏–∂–∫–∞
            await self._initialize_ai_engine()

            if not self.ai_engine:
                return self._get_fallback_ai_recommendations("AI –¥–≤–∏–∂–æ–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å AI —Å–µ—Ä–≤–∏—Å–∞
            health_check = await self.ai_engine.test_connection()
            if not health_check.get('ollama_available', False):
                return self._get_fallback_ai_recommendations("Ollama —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")

            if not health_check.get('model_loaded', False):
                return self._get_fallback_ai_recommendations("AI –º–æ–¥–µ–ª—å –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")

            # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ï –¥–∞–Ω–Ω—ã–µ –¥–ª—è AI
            prepared_data = self._prepare_optimized_ai_data(telegram_id, user_profile, prediction_data, target_date)

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            try:
                ai_result = await asyncio.wait_for(
                    self.ai_engine.generate_recommendations(prepared_data),
                    timeout=170  # 170 —Å–µ–∫—É–Ω–¥ –¥–ª—è AI –æ–±—Ä–∞–±–æ—Ç–∫–∏
                )

                if ai_result.get('success', False):
                    logger.info(f"‚úÖ AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è {telegram_id}")
                    return ai_result
                else:
                    logger.warning(f"‚ö†Ô∏è AI –Ω–µ —Å–º–æ–≥ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: {ai_result.get('error')}")
                    return self._get_fallback_ai_recommendations(ai_result.get('error', 'Unknown AI error'))

            except asyncio.TimeoutError:
                logger.warning(f"‚è∞ –¢–∞–π–º–∞—É—Ç AI –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–ª—è {telegram_id}")
                return self._get_fallback_ai_recommendations("–¢–∞–π–º–∞—É—Ç –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π")

            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ AI –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–ª—è {telegram_id}: {e}")
                return self._get_fallback_ai_recommendations(str(e))

        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ AI —Å–∏—Å—Ç–µ–º—ã –¥–ª—è {telegram_id}: {e}")
            return self._get_fallback_ai_recommendations(str(e))

    async def _get_ai_recommendations(self, telegram_id: int, user_profile: dict, prediction: dict, target_date: date):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π (—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)"""
        return await self.get_ai_recommendations_async(telegram_id, target_date, prediction, user_profile)

    def _prepare_optimized_ai_data(self, telegram_id: int, user_profile: dict, prediction: dict,
                                   target_date: date) -> dict:
        """
        –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–ê–Ø –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI –º–æ–¥–µ–ª–∏
        –£–±—Ä–∞–Ω—ã –∏–∑–±—ã—Ç–æ—á–Ω—ã–µ –ø–æ–ª—è, –¥–æ–±–∞–≤–ª–µ–Ω—ã –ø–æ–ª–µ–∑–Ω—ã–µ –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
        """
        try:
            daily_calculations = prediction.get('daily_calculations', {})
            biorhythm_data = daily_calculations.get('biorhythm_data', {})
            astro_data = daily_calculations.get('astro_data', {})

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –≤–æ–∑—Ä–∞—Å—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            user_age = self._calculate_user_age(user_profile.get('birth_date'))

            # –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–ª—é—á–µ–≤—ã–µ —Å–∏–ª—å–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã
            strong_aspects = self._extract_key_strong_aspects(astro_data)

            # –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤
            optimized_biorhythms = self._optimize_biorhythm_data(biorhythm_data)

            # –û–ø—Ç–∏–º–∏–∑–∏—Ä—É–µ–º –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
            optimized_astro = self._optimize_astro_data(astro_data)

            return {
                'user_profile': {
                    'profession': user_profile.get('profession', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞'),
                    'position': user_profile.get('job_position', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞'),
                    'current_city': user_profile.get('current_city', '–Ω–µ —É–∫–∞–∑–∞–Ω'),
                    'age': user_age
                },
                'energy_state': optimized_biorhythms,
                'astro_influences': optimized_astro,
                'key_aspects': strong_aspects,
                'target_date': target_date.strftime('%d.%m.%Y'),  # –ë–æ–ª–µ–µ —á–∏—Ç–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç
                'season': self._get_season(target_date),  # –î–æ–±–∞–≤–ª—è–µ–º —Å–µ–∑–æ–Ω –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
                'day_of_week': target_date.strftime('%A')  # –î–µ–Ω—å –Ω–µ–¥–µ–ª–∏ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI: {e}")
            # Fallback –Ω–∞ —Å—Ç–∞—Ä—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–∏ –æ—à–∏–±–∫–µ
            return self._prepare_ai_data_fallback(user_profile, prediction, target_date)

    def _calculate_user_age(self, birth_date: date) -> int:
        """–†–∞—Å—á–µ—Ç –≤–æ–∑—Ä–∞—Å—Ç–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            if not birth_date:
                return 0
            today = date.today()
            age = today.year - birth_date.year
            # –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º –µ—Å–ª–∏ –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è –µ—â–µ –Ω–µ –Ω–∞—Å—Ç—É–ø–∏–ª –≤ —ç—Ç–æ–º –≥–æ–¥—É
            if today.month < birth_date.month or (today.month == birth_date.month and today.day < birth_date.day):
                age -= 1
            return age
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –≤–æ–∑—Ä–∞—Å—Ç–∞: {e}")
            return 0

    def _extract_key_strong_aspects(self, astro_data: dict) -> List[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ –¥–ª—è AI"""
        try:
            key_aspects = astro_data.get('key_aspects', [])
            strong_aspects = []

            # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ–ø-5 —Å–∞–º—ã—Ö —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤
            sorted_aspects = sorted(key_aspects, key=lambda x: x.get('strength', 0), reverse=True)[:5]

            for aspect in sorted_aspects:
                if aspect.get('strength', 0) > 0.6:  # –ë–æ–ª–µ–µ —Å—Ç—Ä–æ–≥–∏–π –ø–æ—Ä–æ–≥ –¥–ª—è AI
                    transit = aspect.get('transit_planet', '')
                    natal = aspect.get('natal_planet', '')
                    aspect_type = aspect.get('aspect', '')

                    if transit and natal and aspect_type:
                        # –£–ø—Ä–æ—â–µ–Ω–Ω—ã–µ –Ω–∞–∑–≤–∞–Ω–∏—è –¥–ª—è AI
                        strong_aspects.append(f"{transit}-{natal}-{aspect_type}")

            return strong_aspects

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ –¥–ª—è AI: {e}")
            return []

    def _optimize_biorhythm_data(self, biorhythm_data: dict) -> Dict[str, Any]:
        """–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –±–∏–æ—Ä–∏—Ç–º–æ–≤ –¥–ª—è AI"""
        try:
            overall = biorhythm_data.get('overall_energy', {})
            cycles = biorhythm_data.get('cycles', {})

            return {
                'overall_energy_percentage': overall.get('percentage', 0),
                'overall_energy_level': overall.get('level', '—Å—Ä–µ–¥–Ω–∏–π'),
                'physical': {
                    'percentage': cycles.get('physical', {}).get('percentage', 0),
                    'phase': cycles.get('physical', {}).get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è'),
                    'trend': cycles.get('physical', {}).get('trend', '—Å—Ç–∞–±–∏–ª—å–Ω–æ')
                },
                'emotional': {
                    'percentage': cycles.get('emotional', {}).get('percentage', 0),
                    'phase': cycles.get('emotional', {}).get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è'),
                    'trend': cycles.get('emotional', {}).get('trend', '—Å—Ç–∞–±–∏–ª—å–Ω–æ')
                },
                'intellectual': {
                    'percentage': cycles.get('intellectual', {}).get('percentage', 0),
                    'phase': cycles.get('intellectual', {}).get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è'),
                    'trend': cycles.get('intellectual', {}).get('trend', '—Å—Ç–∞–±–∏–ª—å–Ω–æ')
                }
            }
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
            return {}

    def _optimize_astro_data(self, astro_data: dict) -> Dict[str, Any]:
        """–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è AI"""
        try:
            return {
                'total_aspects': astro_data.get('aspects_count', 0),
                'strong_aspects': astro_data.get('strong_aspects_count', 0),
                'retrograde_planets': len(astro_data.get('retrograde_planets', [])),
                'aspect_intensity': self._calculate_aspect_intensity(astro_data)
            }
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∞—Å—Ç—Ä–æ–¥–∞–Ω–Ω—ã—Ö: {e}")
            return {}

    def _calculate_aspect_intensity(self, astro_data: dict) -> str:
        """–†–∞—Å—á–µ—Ç –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –∞—Å–ø–µ–∫—Ç–æ–≤ –¥–ª—è AI"""
        try:
            strong_count = astro_data.get('strong_aspects_count', 0)
            total_count = astro_data.get('aspects_count', 0)

            if total_count == 0:
                return '–Ω–∏–∑–∫–∞—è'

            intensity_ratio = strong_count / total_count

            if intensity_ratio > 0.7:
                return '–æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è'
            elif intensity_ratio > 0.5:
                return '–≤—ã—Å–æ–∫–∞—è'
            elif intensity_ratio > 0.3:
                return '—Å—Ä–µ–¥–Ω—è—è'
            else:
                return '–Ω–∏–∑–∫–∞—è'

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏ –∞—Å–ø–µ–∫—Ç–æ–≤: {e}")
            return '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'

    def _get_season(self, target_date: date) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–µ–∑–æ–Ω–∞ –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞"""
        try:
            month = target_date.month
            if month in [12, 1, 2]:
                return '–∑–∏–º–∞'
            elif month in [3, 4, 5]:
                return '–≤–µ—Å–Ω–∞'
            elif month in [6, 7, 8]:
                return '–ª–µ—Ç–æ'
            else:
                return '–æ—Å–µ–Ω—å'
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Å–µ–∑–æ–Ω–∞: {e}")
            return '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'

    def _prepare_ai_data_fallback(self, user_profile: dict, prediction: dict, target_date: date) -> dict:
        """Fallback –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö (—Å—Ç–∞—Ä–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞)"""
        try:
            daily_calculations = prediction.get('daily_calculations', {})

            return {
                'user_context': {
                    'profession': user_profile.get('profession'),
                    'position': user_profile.get('job_position'),
                    'current_city': user_profile.get('current_city')
                },
                'energy_state': daily_calculations.get('biorhythm_data', {}),
                'astro_highlights': daily_calculations.get('astro_data', {}),
                'target_date': target_date.isoformat()
            }
        except Exception as e:
            logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ fallback –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
            return {
                'user_context': {'profession': '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ'},
                'energy_state': {},
                'astro_highlights': {},
                'target_date': target_date.isoformat()
            }

    def _get_fallback_ai_recommendations(self, error: str) -> dict:
        """–†–µ–∑–µ—Ä–≤–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø—Ä–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ AI"""
        logger.info(f"üîÑ –ò—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è —Ä–µ–∑–µ—Ä–≤–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏: {error}")

        return {
            'success': False,
            'is_fallback': True,
            'error': error,
            'recommendations': {
                'professional': [
                    "–°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á–∞—Ö",
                    "–ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ —Ä–∞–±–æ—Ç—É –ø–æ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–∞–º"
                ],
                'personal_effectiveness': [
                    "–°–æ–±–ª—é–¥–∞–π—Ç–µ –±–∞–ª–∞–Ω—Å —Ä–∞–±–æ—Ç—ã –∏ –æ—Ç–¥—ã—Ö–∞",
                    "–î–µ–ª–∞–π—Ç–µ —Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –ø–µ—Ä–µ—Ä—ã–≤—ã"
                ],
                'emotional': [
                    "–°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏–µ",
                    "–ò–∑–±–µ–≥–∞–π—Ç–µ –∏–º–ø—É–ª—å—Å–∏–≤–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π"
                ],
                'daily_focus': [
                    "–ë–∞–ª–∞–Ω—Å –º–µ–∂–¥—É –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—å—é –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º"
                ]
            }
        }

    async def get_todays_recommendations(self, telegram_id: int, include_ai: bool = False):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)"""
        return await self.get_recommendations(telegram_id, date.today(), include_ai)

    async def get_tomorrows_recommendations(self, telegram_id: int, include_ai: bool = False):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –∑–∞–≤—Ç—Ä–∞"""
        tomorrow = date.today() + timedelta(days=1)
        return await self.get_recommendations(telegram_id, tomorrow, include_ai)

    async def get_date_recommendations(self, telegram_id: int, target_date: date, include_ai: bool = False):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É (alias –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏—è)"""
        return await self.get_recommendations(telegram_id, target_date, include_ai)

    async def update_professional_info(self, telegram_id: int, current_city: str, profession: str,
                                       job_position: str = None, gender: str = None):
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
        try:
            await update_user_profession(telegram_id, profession, job_position)

            # –û–±–Ω–æ–≤–ª—è–µ–º –≥–æ—Ä–æ–¥ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è –∏ –ø–æ–ª
            user_profile = await get_user_profile(telegram_id)
            if user_profile:
                await create_or_update_user(
                    telegram_id=telegram_id,
                    birth_date=user_profile['birth_date'],
                    birth_time=user_profile['birth_time'],
                    birth_city=user_profile['birth_city'],
                    current_city=current_city,
                    profession=profession,
                    job_position=job_position,
                    gender=gender
                )

            logger.info(f"‚úÖ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è {telegram_id}")
            return {
                'success': True,
                'message': "‚úÖ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!"
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
            }

    async def get_user_data_status(self, telegram_id: int):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–æ–±—Ä–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            user_profile = await get_user_profile(telegram_id)
            natal_chart = await get_user_natal_chart(telegram_id)
            psyho_matrix = await get_user_matrix(telegram_id)
            biorhythms = await get_user_biorhythms(telegram_id)

            has_basic_data = user_profile is not None
            has_natal_chart = natal_chart is not None
            has_psyho_matrix = psyho_matrix is not None
            has_biorhythms = biorhythms is not None

            return {
                'has_basic_data': has_basic_data,
                'has_natal_chart': has_natal_chart,
                'has_psyho_matrix': has_psyho_matrix,
                'has_biorhythms': has_biorhythms,
                'is_complete': has_basic_data and has_natal_chart and has_psyho_matrix and has_biorhythms,
                'user_profile': user_profile
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'has_basic_data': False,
                'has_natal_chart': False,
                'has_psyho_matrix': False,
                'has_biorhythms': False,
                'is_complete': False
            }

    async def get_user_statistics(self, telegram_id: int):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            from backend.prediction_services import get_prediction_statistics
            from backend.biorhythm_services import get_biorhythm_statistics
            from backend.user_services import get_user_request_count

            data_status = await self.get_user_data_status(telegram_id)
            prediction_stats = await get_prediction_statistics(telegram_id)
            biorhythm_stats = await get_biorhythm_statistics(telegram_id)
            request_count = await get_user_request_count(telegram_id)

            return {
                'data_status': data_status,
                'prediction_stats': prediction_stats,
                'biorhythm_stats': biorhythm_stats,
                'request_count': request_count,
                'calculated_at': datetime.now().isoformat()
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è {telegram_id}: {e}")
            return {
                'data_status': {},
                'prediction_stats': {},
                'biorhythm_stats': {},
                'request_count': 0,
                'error': str(e)
            }

    async def cleanup_user_data(self, telegram_id: int):
        """–û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è)"""
        try:
            from backend.biorhythm_services import cleanup_old_biorhythms
            from backend.prediction_services import cleanup_old_predictions

            biorhythm_cleaned = await cleanup_old_biorhythms()
            prediction_cleaned = await cleanup_old_predictions()

            logger.info(f"üßπ –û—á–∏—â–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")
            return {
                'success': True,
                'biorhythm_records_cleaned': biorhythm_cleaned,
                'prediction_records_cleaned': prediction_cleaned,
                'message': f"‚úÖ –û—á–∏—â–µ–Ω–æ {biorhythm_cleaned} –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ –∏ {prediction_cleaned} –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π"
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
            }

    async def validate_user_data(self, telegram_id: int):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            from backend.prediction_services import validate_prediction_data

            data_status = await self.get_user_data_status(telegram_id)
            prediction_valid = await validate_prediction_data(telegram_id)

            issues = []

            if not data_status['has_basic_data']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            if not data_status['has_natal_chart']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞")
            if not data_status['has_psyho_matrix']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞")
            if not data_status['has_biorhythms']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –¥–∞–Ω–Ω—ã–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤")
            if not prediction_valid:
                issues.append("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π")

            return {
                'is_valid': len(issues) == 0,
                'issues': issues,
                'data_status': data_status,
                'prediction_valid': prediction_valid
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'is_valid': False,
                'issues': [f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {str(e)}"],
                'data_status': {},
                'prediction_valid': False
            }

    async def test_ai_connection(self):
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ AI —Å–µ—Ä–≤–∏—Å—É"""
        try:
            await self._initialize_ai_engine()

            if not self.ai_engine:
                return {
                    'available': False,
                    'error': 'AI –¥–≤–∏–∂–æ–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'
                }

            return await self.ai_engine.test_connection()

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è AI –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {e}")
            return {
                'available': False,
                'error': str(e)
            }


# –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–æ–º–æ—â–Ω–∏–∫–∞
assistant = PersonalAssistant()

biorhythm_calculator.py:

import math
from datetime import date, datetime, timedelta
from typing import Dict, List, Tuple
import logging

logger = logging.getLogger(__name__)


class BiorhythmCalculator:
    """
    –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è.
    –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª—ã.
    """

    def __init__(self):
        # –ü–µ—Ä–∏–æ–¥—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤ –≤ –¥–Ω—è—Ö
        self.PHYSICAL_CYCLE = 23
        self.EMOTIONAL_CYCLE = 28
        self.INTELLECTUAL_CYCLE = 33
        self.INTUITIVE_CYCLE = 38  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª

    def calculate_biorhythms(self, birth_date: date, target_date: date) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –∑–∞–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É

        Args:
            birth_date: –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è
            target_date: –î–∞—Ç–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞

        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤
        """
        try:
            # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            days_lived = (target_date - birth_date).days

            if days_lived < 0:
                raise ValueError("–î–∞—Ç–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è")

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤
            physical = self._calculate_cycle(days_lived, self.PHYSICAL_CYCLE)
            emotional = self._calculate_cycle(days_lived, self.EMOTIONAL_CYCLE)
            intellectual = self._calculate_cycle(days_lived, self.INTELLECTUAL_CYCLE)
            intuitive = self._calculate_cycle(days_lived, self.INTUITIVE_CYCLE)

            # –û–±—â–∏–π –ø–æ–∫–∞–∑–∞—Ç–µ–ª—å —ç–Ω–µ—Ä–≥–∏–∏
            overall_energy = self._calculate_overall_energy(physical, emotional, intellectual, intuitive)

            biorhythm_data = {
                'calculation_date': target_date.isoformat(),
                'days_lived': days_lived,
                'cycles': {
                    'physical': physical,
                    'emotional': emotional,
                    'intellectual': intellectual,
                    'intuitive': intuitive
                },
                'overall_energy': overall_energy,
                'critical_days': self._find_critical_days(physical, emotional, intellectual, target_date),
                'peak_days': self._find_peak_days(physical, emotional, intellectual, target_date)
            }

            logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –¥–ª—è {target_date}, –ø—Ä–æ–∂–∏—Ç–æ –¥–Ω–µ–π: {days_lived}")
            return biorhythm_data

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
            raise

    def _calculate_cycle(self, days_lived: int, cycle_length: int) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –æ–¥–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –±–∏–æ—Ä–∏—Ç–º–∞

        Args:
            days_lived: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            cycle_length: –î–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ –≤ –¥–Ω—è—Ö

        Returns:
            –î–∞–Ω–Ω—ã–µ —Ü–∏–∫–ª–∞
        """
        # –¢–µ–∫—É—â–∞—è —Ñ–∞–∑–∞ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö (2œÄ –∑–∞ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª)
        phase = (2 * math.pi * days_lived) / cycle_length

        # –ó–Ω–∞—á–µ–Ω–∏–µ —Å–∏–Ω—É—Å–æ–∏–¥—ã (-1 –¥–æ +1)
        value = math.sin(phase)

        # –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞ (0% –¥–æ 100%)
        percentage = ((value + 1) / 2) * 100

        # –î–µ–Ω—å –≤ —Ü–∏–∫–ª–µ (0 –¥–æ cycle_length-1)
        day_in_cycle = days_lived % cycle_length

        return {
            'value': round(value, 4),
            'percentage': round(percentage, 2),
            'day_in_cycle': day_in_cycle,
            'phase': self._get_phase_description(value),
            'trend': self._get_trend(phase)
        }

    def _get_phase_description(self, value: float) -> str:
        """–û–ø–∏—Å–∞–Ω–∏–µ —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–∞"""
        if value >= 0.7:
            return "–ø–∏–∫ —ç–Ω–µ—Ä–≥–∏–∏"
        elif value >= 0.3:
            return "–≤—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        elif value >= -0.3:
            return "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è —Ñ–∞–∑–∞"
        elif value >= -0.7:
            return "–Ω–∏–∑–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        else:
            return "–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Ç–æ—á–∫–∞"

    def _get_trend(self, phase: float) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞ (—Ä–∞—Å—Ç–µ—Ç/–ø–∞–¥–∞–µ—Ç)"""
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é (cos(phase))
        derivative = math.cos(phase)

        if derivative > 0.1:
            return "—Ä–∞—Å—Ç–µ—Ç"
        elif derivative < -0.1:
            return "–ø–∞–¥–∞–µ—Ç"
        else:
            return "—Å—Ç–∞–±–∏–ª—å–Ω–æ"

    def _calculate_overall_energy(self, physical: Dict, emotional: Dict, intellectual: Dict, intuitive: Dict) -> Dict:
        """–†–∞—Å—á–µ—Ç –æ–±—â–µ–≥–æ —É—Ä–æ–≤–Ω—è —ç–Ω–µ—Ä–≥–∏–∏"""
        # –í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –≤—Å–µ—Ö —Ü–∏–∫–ª–æ–≤
        total_energy = (
                physical['value'] * 0.3 +  # –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª - 30%
                emotional['value'] * 0.25 +  # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π - 25%
                intellectual['value'] * 0.25 +  # –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π - 25%
                intuitive['value'] * 0.2  # –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π - 20%
        )

        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–æ 0-100%
        energy_percentage = ((total_energy + 1) / 2) * 100

        return {
            'value': round(total_energy, 4),
            'percentage': round(energy_percentage, 2)
        }

    def _find_critical_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –¥–Ω–µ–π"""
        critical_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (abs(physical['value']) > 0.9 or
                abs(emotional['value']) > 0.9 or
                abs(intellectual['value']) > 0.9):
            critical_days.append({
                'date': target_date.isoformat(),
                'cycles': self._get_critical_cycles(physical, emotional, intellectual)
            })

        return critical_days

    def _find_peak_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–∏–∫–æ–≤—ã—Ö –¥–Ω–µ–π"""
        peak_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (physical['value'] > 0.8 or
                emotional['value'] > 0.8 or
                intellectual['value'] > 0.8):

            peak_cycles = []
            if physical['value'] > 0.8: peak_cycles.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
            if emotional['value'] > 0.8: peak_cycles.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
            if intellectual['value'] > 0.8: peak_cycles.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')

            peak_days.append({
                'date': target_date.isoformat(),
                'cycles': peak_cycles
            })

        return peak_days

    def _get_critical_cycles(self, physical: Dict, emotional: Dict, intellectual: Dict) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ü–∏–∫–ª–æ–≤"""
        critical = []
        if abs(physical['value']) > 0.9: critical.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
        if abs(emotional['value']) > 0.9: critical.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
        if abs(intellectual['value']) > 0.9: critical.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')
        return critical

    def calculate_weekly_forecast(self, birth_date: date, start_date: date, days: int = 7) -> List[Dict]:
        """–†–∞—Å—á–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π"""
        forecast = []

        for i in range(days):
            current_date = start_date + timedelta(days=i)
            biorhythms = self.calculate_biorhythms(birth_date, current_date)

            forecast.append({
                'date': current_date.isoformat(),
                'overall_energy': biorhythms['overall_energy']['percentage'],
                'physical': biorhythms['cycles']['physical']['percentage'],
                'emotional': biorhythms['cycles']['emotional']['percentage'],
                'intellectual': biorhythms['cycles']['intellectual']['percentage'],
                'is_critical': len(biorhythms['critical_days']) > 0,
                'is_peak': len(biorhythms['peak_days']) > 0
            })

        return forecast

biorhythm_services.py:

from backend.database import async_session, Biorhythms
from backend.biorhythm_calculator import BiorhythmCalculator
from backend.user_services import get_user_profile
from sqlalchemy.future import select
from sqlalchemy import func, and_
from datetime import date, datetime, timedelta
import logging
import asyncio

logger = logging.getLogger(__name__)


async def calculate_and_save_biorhythms(telegram_id: int, target_date: date = None):
    """–†–∞—Å—á–µ—Ç –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        if target_date is None:
            target_date = date.today()

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_profile = await get_user_profile(telegram_id)
        if not user_profile:
            raise ValueError(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∏–æ—Ä–∏—Ç–º—ã
        calculator = BiorhythmCalculator()
        biorhythm_data = calculator.calculate_biorhythms(
            user_profile['birth_date'],
            target_date
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î —Å –∞—Ç–æ–º–∞—Ä–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
        async with async_session() as session:
            try:
                # –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º –í–°–ï —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è —ç—Ç–æ–π –¥–∞—Ç—ã (–Ω–∞ —Å–ª—É—á–∞–π –¥—É–±–ª–µ–π)
                await session.execute(
                    Biorhythms.__table__.delete().where(
                        and_(
                            Biorhythms.telegram_id == telegram_id,
                            Biorhythms.calculation_date == target_date
                        )
                    )
                )

                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
                new_record = Biorhythms(
                    telegram_id=telegram_id,
                    biorhythm_data=biorhythm_data,
                    calculation_date=target_date
                )
                session.add(new_record)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –±–∏–æ—Ä–∏—Ç–º—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

                await session.commit()
                logger.info(f"üíæ –ë–∏–æ—Ä–∏—Ç–º—ã —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –¥–ª—è {telegram_id}")

            except Exception as db_error:
                await session.rollback()
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ë–î –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {db_error}")
                raise

        return biorhythm_data

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –¥–ª—è {telegram_id}: {e}")
        raise


async def get_user_biorhythms(telegram_id: int, target_date: date = None):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
    try:
        if target_date is None:
            target_date = date.today()

        async with async_session() as session:
            result = await session.execute(
                select(Biorhythms).where(
                    and_(
                        Biorhythms.telegram_id == telegram_id,
                        Biorhythms.calculation_date == target_date
                    )
                )
            )
            biorhythms = result.scalar_one_or_none()

            if biorhythms:
                logger.info(f"‚úÖ –ù–∞–π–¥–µ–Ω—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –±–∏–æ—Ä–∏—Ç–º—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")
                return biorhythms.biorhythm_data

            # –ï—Å–ª–∏ –∑–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–Ω–æ–≤–æ
            logger.info(f"üîÑ –ë–∏–æ—Ä–∏—Ç–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–Ω–æ–≤–æ –¥–ª—è {telegram_id}")
            return await calculate_and_save_biorhythms(telegram_id, target_date)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {e}")
        return None


async def get_biorhythm_weekly_forecast(telegram_id: int, start_date: date = None, days: int = 7):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π"""
    try:
        if start_date is None:
            start_date = date.today()

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_profile = await get_user_profile(telegram_id)
        if not user_profile:
            raise ValueError(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")

        calculator = BiorhythmCalculator()
        forecast = calculator.calculate_weekly_forecast(
            user_profile['birth_date'],
            start_date,
            days
        )

        logger.info(f"‚úÖ –ü—Ä–æ–≥–Ω–æ–∑ –±–∏–æ—Ä–∏—Ç–º–æ–≤ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –¥–ª—è {telegram_id} –Ω–∞ {days} –¥–Ω–µ–π")
        return forecast

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {e}")
        return None


async def cleanup_duplicate_biorhythms():
    """–û—á–∏—Å—Ç–∫–∞ –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤"""
    try:
        async with async_session() as session:
            # –ù–∞—Ö–æ–¥–∏–º –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è –∑–∞–ø–∏—Å–∏
            duplicate_query = """
            DELETE FROM biorhythms 
            WHERE ctid NOT IN (
                SELECT MIN(ctid) 
                FROM biorhythms 
                GROUP BY telegram_id, calculation_date
            )
            """

            result = await session.execute(duplicate_query)
            deleted_count = result.rowcount

            await session.commit()

            if deleted_count > 0:
                logger.warning(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {deleted_count} –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤")
            else:
                logger.info("‚úÖ –î—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

            return deleted_count

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
        return 0


async def get_biorhythm_statistics(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –±–∏–æ—Ä–∏—Ç–º–∞–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤
            count_result = await session.execute(
                select(func.count(Biorhythms.telegram_id)).where(
                    Biorhythms.telegram_id == telegram_id
                )
            )
            total_records = count_result.scalar() or 0

            # –°–∞–º–∞—è —Å—Ç–∞—Ä–∞—è –∏ –Ω–æ–≤–∞—è –∑–∞–ø–∏—Å—å
            dates_result = await session.execute(
                select(
                    func.min(Biorhythms.calculation_date),
                    func.max(Biorhythms.calculation_date)
                ).where(Biorhythms.telegram_id == telegram_id)
            )
            min_date, max_date = dates_result.first() or (None, None)

            statistics = {
                'total_records': total_records,
                'first_calculation': min_date.isoformat() if min_date else None,
                'last_calculation': max_date.isoformat() if max_date else None,
                'calculation_range_days': (max_date - min_date).days if min_date and max_date else 0
            }

            logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–ª—É—á–µ–Ω–∞ –¥–ª—è {telegram_id}")
            return statistics

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {e}")
        return {
            'total_records': 0,
            'first_calculation': None,
            'last_calculation': None,
            'calculation_range_days': 0
        }


async def cleanup_old_biorhythms(days_old: int = 30):
    """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤"""
    try:
        cutoff_date = date.today() - timedelta(days=days_old)

        async with async_session() as session:
            result = await session.execute(
                Biorhythms.__table__.delete().where(
                    Biorhythms.calculation_date < cutoff_date
                )
            )
            deleted_count = result.rowcount

            await session.commit()

            if deleted_count > 0:
                logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {deleted_count} —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ (—Å—Ç–∞—Ä—à–µ {days_old} –¥–Ω–µ–π)")
            else:
                logger.info("‚úÖ –°—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

            return deleted_count

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å—Ç–∞—Ä—ã—Ö –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
        return 0

chart_services.py:

from backend.database import async_session, UserNatalChart
from backend.natal_chart import MLNatalChartCalculator
from sqlalchemy.future import select
import logging

logger = logging.getLogger(__name__)


async def create_and_save_natal_chart(telegram_id: int, city: str, birth_datetime, timezone: str):
    """–°–æ–∑–¥–∞–Ω–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã"""
    try:
        calculator = MLNatalChartCalculator()
        natal_data = calculator.calculate_natal_chart_ml(city, birth_datetime, timezone)

        logger.info(f"–°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")

        async with async_session() as session:
            result = await session.execute(
                select(UserNatalChart).where(UserNatalChart.telegram_id == telegram_id)
            )
            natal_chart = result.scalar_one_or_none()

            if natal_chart:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É
                natal_chart.natal_data = natal_data
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –¥–ª—è {telegram_id}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É
                natal_chart = UserNatalChart(
                    telegram_id=telegram_id,
                    natal_data=natal_data
                )
                session.add(natal_chart)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –¥–ª—è {telegram_id}")

            await session.commit()
            logger.info(f"üíæ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è {telegram_id}")
            return natal_chart

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –¥–ª—è {telegram_id}: {e}")
        raise


async def get_user_natal_chart(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(UserNatalChart).where(UserNatalChart.telegram_id == telegram_id)
            )
            natal_chart = result.scalar_one_or_none()

            if natal_chart:
                return natal_chart.natal_data
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã {telegram_id}: {e}")
        return None

database.py:

import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, BigInteger, JSON, TIMESTAMP, String, Date, Time, Text
from sqlalchemy.sql import func
from sqlalchemy import ForeignKey
from sqlalchemy import Column, BigInteger, JSON, TIMESTAMP, String, Date, Time, Text, ForeignKey, Integer
from sqlalchemy.sql import func
import logging

logger = logging.getLogger(__name__)

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql+asyncpg://pers_assist:astra123@localhost:5432/p_assistant_bd"
)

logger.info(f"–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ë–î: postgresql+asyncpg://pers_assist:******@localhost:5432/p_assistant_bd")

async_engine = create_async_engine(
    DATABASE_URL,
    echo=True,
    pool_pre_ping=True,
    pool_recycle=300
)

async_session = sessionmaker(
    async_engine,
    expire_on_commit=False,
    class_=AsyncSession
)

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    telegram_id = Column(BigInteger, primary_key=True, index=True)
    birth_date = Column(Date, nullable=False)
    birth_time = Column(Time, nullable=False)
    birth_city = Column(String(100), nullable=False)
    profession = Column(String(100), nullable=True)
    job_position = Column(String(100), nullable=True)
    current_city = Column(String(100), nullable=True)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())
    gender = Column(String(10), nullable=True)  # 'male', 'female', None
    request_count = Column(Integer, default=0)

    def __repr__(self):
        return f"<User(telegram_id={self.telegram_id}, birth_date={self.birth_date})>"

class UserNatalChart(Base):
    __tablename__ = 'user_natal_charts'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    natal_data = Column(JSON, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<UserNatalChart(telegram_id={self.telegram_id})>"

class PsyhoMatrix(Base):
    __tablename__ = 'psyho_matrix'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    matrix_data = Column(JSON, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<PsyhoMatrix(telegram_id={self.telegram_id})>"

class NatalPredictions(Base):
    __tablename__ = 'natal_predictions'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    predictions = Column(JSON, nullable=False)
    assistant_data = Column(JSON, nullable=False, default={})
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<NatalPredictions(telegram_id={self.telegram_id})>"


class Biorhythms(Base):
    __tablename__ = 'biorhythms'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    biorhythm_data = Column(JSON, nullable=False)
    calculation_date = Column(Date, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<Biorhythms(telegram_id={self.telegram_id}, date={self.calculation_date})>"



# –î–æ–±–∞–≤–∏—Ç—å –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ –º–æ–¥–µ–ª–∏ –¥–ª—è AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π:
class AIRecommendations(Base):
    __tablename__ = 'ai_recommendations'
    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id'), primary_key=True)
    target_date = Column(Date, primary_key=True)
    data_hash = Column(String(64), nullable=False)
    recommendations = Column(Text, nullable=False)
    model_version = Column(String(20), default='gemma:2b')
    created_at = Column(TIMESTAMP, server_default=func.now())

class AstroInsights(Base):
    __tablename__ = 'astro_insights'
    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id'), primary_key=True)
    dominant_energy = Column(JSON, nullable=False)
    personality_traits = Column(JSON, nullable=False)
    planetary_strengths = Column(JSON, nullable=False)


async def get_db():
    async with async_session() as session:
        try:
            yield session
        finally:
            await session.close()


class Biorhythms(Base):
    __tablename__ = 'biorhythms'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    biorhythm_data = Column(JSON, nullable=False)
    calculation_date = Column(Date, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<Biorhythms(telegram_id={self.telegram_id}, date={self.calculation_date})>"



async def get_db():
    async with async_session() as session:
        try:
            yield session
        finally:
            await session.close()





db_connection.py:

from backend.database import async_session
from sqlalchemy import text
import logging

logger = logging.getLogger(__name__)

async def check_db_connection():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async with async_session() as session:
            await session.execute(text("SELECT 1"))
        logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î —É—Å–ø–µ—à–Ω–æ")
        return True
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
        return False

matrix_services.py:

from backend.database import async_session, PsyhoMatrix
from backend.psyho_matrix import PsyhoMatrixCalculator
from backend.user_services import get_user_profile
from sqlalchemy.future import select
import logging

logger = logging.getLogger(__name__)


async def calculate_and_save_psyho_matrix(telegram_id: int):
    """–†–∞—Å—á–µ—Ç –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_profile = await get_user_profile(telegram_id)
        if not user_profile:
            raise ValueError("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

        calculator = PsyhoMatrixCalculator()
        matrix_data = calculator.calculate_matrix(user_profile['birth_date'])

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
        async with async_session() as session:
            result = await session.execute(
                select(PsyhoMatrix).where(PsyhoMatrix.telegram_id == telegram_id)
            )
            psyho_matrix = result.scalar_one_or_none()

            if psyho_matrix:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
                psyho_matrix.matrix_data = matrix_data
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω–∞ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ –¥–ª—è {telegram_id}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
                psyho_matrix = PsyhoMatrix(
                    telegram_id=telegram_id,
                    matrix_data=matrix_data
                )
                session.add(psyho_matrix)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ –¥–ª—è {telegram_id}")

            await session.commit()
            logger.info(f"‚úÖ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è {telegram_id}")

        return matrix_data

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –¥–ª—è {telegram_id}: {e}")
        raise


async def get_user_matrix(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(PsyhoMatrix).where(PsyhoMatrix.telegram_id == telegram_id)
            )
            matrix = result.scalar_one_or_none()

            if matrix:
                return matrix.matrix_data
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã {telegram_id}: {e}")
        return None

natal_chart.py:

import os
import pytz
from datetime import datetime
import swisseph as swe
from math import floor
from typing import Dict, List, Tuple, Any
import logging
import requests
import time
from urllib.parse import quote

from backend.database import async_session, UserNatalChart

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MLNatalChartCalculator:
    def __init__(self):
        current_dir = os.getcwd()
        ephe_path = os.path.join(current_dir, 'ephe')
        swe.set_ephe_path(ephe_path)
        swe.set_jpl_file('de441.eph')

        # –ö—ç—à –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≥–æ—Ä–æ–¥–æ–≤
        self.coordinates_cache = {}

        # –û—Å–Ω–æ–≤–Ω—ã–µ –≥–æ—Ä–æ–¥–∞ –†–æ—Å—Å–∏–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
        self.major_cities = {
            "–º–æ—Å–∫–≤–∞": (55.7558, 37.6173, 156),
            "—Å–∞–Ω–∫—Ç-–ø–µ—Ç–µ—Ä–±—É—Ä–≥": (59.9343, 30.3351, 3),
            "–Ω–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫": (55.0084, 82.9357, 150),
            "–µ–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥": (56.8389, 60.6057, 237),
            "–Ω–∏–∂–Ω–∏–π –Ω–æ–≤–≥–æ—Ä–æ–¥": (56.3269, 44.0075, 78),
            "–∫–∞–∑–∞–Ω—å": (55.8304, 49.0661, 60),
            "—á–µ–ª—è–±–∏–Ω—Å–∫": (55.1644, 61.4368, 228),
            "–æ–º—Å–∫": (54.9884, 73.3242, 85),
            "—Å–∞–º–∞—Ä–∞": (53.2415, 50.2212, 87),
            "—Ä–æ—Å—Ç–æ–≤-–Ω–∞-–¥–æ–Ω—É": (47.2225, 39.7187, 70),
            "—É—Ñ–∞": (54.7355, 55.9587, 158),
            "–∫—Ä–∞—Å–Ω–æ—è—Ä—Å–∫": (56.0153, 92.8932, 136),
            "–ø–µ—Ä–º—å": (58.0105, 56.2502, 149),
            "–≤–æ—Ä–æ–Ω–µ–∂": (51.6720, 39.1843, 104),
            "–≤–æ–ª–≥–æ–≥—Ä–∞–¥": (48.7080, 44.5133, 80),
            "–∫—Ä–∞—Å–Ω–æ–¥–∞—Ä": (45.0355, 38.9750, 25),
            "—Å–∞—Ä–∞—Ç–æ–≤": (51.5924, 45.9608, 50),
            "—Ç—é–º–µ–Ω—å": (57.1613, 65.5250, 70),
            "—Ç–æ–ª—å—è—Ç—Ç–∏": (53.5088, 49.4192, 90),
            "–∏–∂–µ–≤—Å–∫": (56.8527, 53.2115, 140),
            "—É–ª—å—è–Ω–æ–≤—Å–∫": (54.3282, 48.3866, 80),
            "–∏—Ä–∫—É—Ç—Å–∫": (52.2864, 104.2806, 440),
            "—Ö–∞–±–∞—Ä–æ–≤—Å–∫": (48.4802, 135.0719, 72),
            "—è—Ä–æ—Å–ª–∞–≤–ª—å": (57.6261, 39.8845, 100),
            "–≤–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫": (43.1332, 131.9113, 8),
            "–º–≥–∞": (59.7569, 31.0609, 33)
        }

        self.ORBS = {
            'conjunction': 8, 'opposition': 8, 'square': 8, 'trine': 8, 'sextile': 6,
            'quincunx': 3, 'semi-square': 3, 'semi-sextile': 3
        }

        self.planets_ml = {
            swe.SUN: 'Sun',
            swe.MOON: 'Moon',
            swe.MERCURY: 'Mercury',
            swe.VENUS: 'Venus',
            swe.MARS: 'Mars',
            swe.JUPITER: 'Jupiter',
            swe.SATURN: 'Saturn',
            swe.URANUS: 'Uranus',
            swe.NEPTUNE: 'Neptune',
            swe.PLUTO: 'Pluto',
            swe.TRUE_NODE: 'North_Node'
        }

        self.zodiac_signs = [
            "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo",
            "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces"
        ]

        self.aspects_ml = {
            0: ('conjunction', self.ORBS['conjunction']),
            60: ('sextile', self.ORBS['sextile']),
            90: ('square', self.ORBS['square']),
            120: ('trine', self.ORBS['trine']),
            180: ('opposition', self.ORBS['opposition'])
        }

    def get_city_coordinates(self, city_name: str) -> Tuple[float, float, float]:
        """
        –ù–∞–¥–µ–∂–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≥–æ—Ä–æ–¥–∞.
        –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫—ç—à, –∑–∞—Ç–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –≥–æ—Ä–æ–¥–∞, –∑–∞—Ç–µ–º –≥–µ–æ–∫–æ–¥–∏–Ω–≥.
        """
        city_lower = city_name.strip().lower()

        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        if city_lower in self.coordinates_cache:
            logger.info(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –∫—ç—à–∞ –¥–ª—è: {city_name}")
            return self.coordinates_cache[city_lower]

        # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –≥–æ—Ä–æ–¥–∞ –†–æ—Å—Å–∏–∏
        if city_lower in self.major_cities:
            coords = self.major_cities[city_lower]
            self.coordinates_cache[city_lower] = coords
            logger.info(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –±–∞–∑—ã –æ—Å–Ω–æ–≤–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤ –¥–ª—è: {city_name}")
            return coords

        # 3. –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–µ–æ–∫–æ–¥–∏–Ω–≥ —á–µ—Ä–µ–∑ Nominatim (OpenStreetMap)
        try:
            coords = self._geocode_city(city_name)
            if coords:
                self.coordinates_cache[city_lower] = coords
                logger.info(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ–ª—É—á–µ–Ω—ã —á–µ—Ä–µ–∑ –≥–µ–æ–∫–æ–¥–∏–Ω–≥ –¥–ª—è: {city_name}")
                return coords
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ –¥–ª—è {city_name}: {e}")

        # 4. –†–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç - –ú–æ—Å–∫–≤–∞
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è {city_name}, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ú–æ—Å–∫–≤—É")
        return (55.7558, 37.6173, 156)

    def _geocode_city(self, city_name: str) -> Tuple[float, float, float]:
        """
        –ì–µ–æ–∫–æ–¥–∏–Ω–≥ –≥–æ—Ä–æ–¥–∞ —á–µ—Ä–µ–∑ Nominatim API (OpenStreetMap)
        """
        # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–∞–Ω—É –¥–ª—è –ª—É—á—à–µ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
        search_query = f"{city_name}, –†–æ—Å—Å–∏—è"
        encoded_query = quote(search_query)

        url = f"https://nominatim.openstreetmap.org/search?q={encoded_query}&format=json&limit=1"

        headers = {
            'User-Agent': 'AstrologyBot/1.0 (leostuchchi@example.com)',
            'Accept': 'application/json'
        }

        try:
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()

            data = response.json()

            if data and len(data) > 0:
                lat = float(data[0]['lat'])
                lon = float(data[0]['lon'])

                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—ã—Å–æ—Ç—É (–ø—Ä–∏–º–µ—Ä–Ω–æ, —Ç–∞–∫ –∫–∞–∫ Nominatim –Ω–µ –¥–∞–µ—Ç —Ç–æ—á–Ω—É—é –≤—ã—Å–æ—Ç—É)
                elevation = self._estimate_elevation(lat, lon)

                logger.info(f"–ì–µ–æ–∫–æ–¥–∏–Ω–≥ —É—Å–ø–µ—à–µ–Ω: {city_name} -> {lat}, {lon}, {elevation}–º")
                return (lat, lon, elevation)

        except requests.exceptions.RequestException as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ –¥–ª—è {city_name}: {e}")
        except (KeyError, ValueError, IndexError) as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–≤–µ—Ç–∞ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ –¥–ª—è {city_name}: {e}")

        return None

    def _estimate_elevation(self, lat: float, lon: float) -> float:
        """
        –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –≤—ã—Å–æ—Ç—ã –Ω–∞–¥ —É—Ä–æ–≤–Ω–µ–º –º–æ—Ä—è.
        –î–ª—è —Ç–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ API.
        """
        # –ü—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞: –ø—Ä–∏–±—Ä–µ–∂–Ω—ã–µ –≥–æ—Ä–æ–¥–∞ ~0–º, –≥–æ—Ä–Ω—ã–µ ~500–º, —Ä–∞–≤–Ω–∏–Ω–Ω—ã–µ ~100-200–º
        if 43 <= lat <= 49 and 131 <= lon <= 142:  # –î–∞–ª—å–Ω–∏–π –í–æ—Å—Ç–æ–∫
            return 200
        elif 53 <= lat <= 58 and 48 <= lon <= 56:  # –ü–æ–≤–æ–ª–∂—å–µ
            return 100
        elif 55 <= lat <= 57 and 37 <= lon <= 40:  # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –†–æ—Å—Å–∏—è
            return 150
        elif 44 <= lat <= 46 and 38 <= lon <= 40:  # –Æ–≥ –†–æ—Å—Å–∏–∏
            return 50
        elif 51 <= lat <= 53 and 103 <= lon <= 108:  # –ë–∞–π–∫–∞–ª
            return 500
        else:
            return 100  # –°—Ä–µ–¥–Ω—è—è –≤—ã—Å–æ—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

    def _geocode_fallback(self, city_name: str) -> Tuple[float, float, float]:
        """
        –†–µ–∑–µ—Ä–≤–Ω—ã–π –º–µ—Ç–æ–¥ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ —á–µ—Ä–µ–∑ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–µ—Ä–≤–∏—Å
        """
        try:
            # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–µ—Ä–≤–∏—Å - GeoNames (—Ç—Ä–µ–±—É–µ—Ç API key)
            # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
            pass
        except Exception as e:
            logger.warning(f"–†–µ–∑–µ—Ä–≤–Ω—ã–π –≥–µ–æ–∫–æ–¥–∏–Ω–≥ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")

        return None

    def add_city_to_cache(self, city_name: str, lat: float, lon: float, elevation: float = 100):
        """
        –†—É—á–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ –≤ –∫—ç—à
        """
        city_lower = city_name.strip().lower()
        self.coordinates_cache[city_lower] = (lat, lon, elevation)
        logger.info(f"–ì–æ—Ä–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫—ç—à: {city_name}")

    def get_cached_cities(self) -> List[str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤
        """
        return list(self.coordinates_cache.keys())

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∫–ª–∞—Å—Å–∞ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def calculate_planet_positions(self, jd_ut: float) -> Dict[str, Dict]:
        positions = {}
        for planet_id, name in self.planets_ml.items():
            try:
                flags = swe.FLG_SWIEPH | swe.FLG_SPEED
                pos, ret_flags = swe.calc_ut(jd_ut, planet_id, flags)
                lon = pos[0] % 360
                sign_index = floor(lon / 30)
                positions[name] = {
                    'longitude': round(lon, 6),
                    'sign': self.zodiac_signs[sign_index],
                    'sign_index': sign_index,
                    'position_in_sign': round(lon % 30, 4),
                    'retrograde': pos[3] < 0,
                    'speed': round(pos[3], 6)
                }
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –¥–ª—è {name}: {e}")
                continue
        return positions

    def calculate_houses_ml(self, jd_ut: float, lat: float, lon: float) -> Dict:
        try:
            hsys = b'P'
            cusps, ascmc = swe.houses(jd_ut, lat, lon, hsys)
            houses = {}
            for i, cusp in enumerate(cusps[:12]):
                cusp_deg = cusp % 360
                sign_index = floor(cusp_deg / 30)
                houses[i + 1] = {
                    'cusp_longitude': round(cusp_deg, 6),
                    'sign': self.zodiac_signs[sign_index],
                    'sign_index': sign_index,
                    'position_in_sign': round(cusp_deg % 30, 4)
                }
            return {
                'houses': houses,
                'ascendant': round(ascmc[0] % 360, 6),
                'midheaven': round(ascmc[1] % 360, 6),
                'house_system': 'Placidus'
            }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –¥–æ–º–æ–≤: {e}")
            return self._get_default_houses()

    def _get_default_houses(self) -> Dict:
        houses = {}
        for i in range(12):
            houses[i + 1] = {
                'cusp_longitude': round(i * 30.0, 6),
                'sign': self.zodiac_signs[i],
                'sign_index': i,
                'position_in_sign': 0.0
            }
        return {
            'houses': houses,
            'ascendant': 0.0,
            'midheaven': 0.0,
            'house_system': 'Placidus'
        }

    def calculate_aspects_ml(self, planets: Dict, asc: float, mc: float) -> List[Dict]:
        aspects = []
        all_points = {**planets}
        all_points['Ascendant'] = {'longitude': asc}
        all_points['Midheaven'] = {'longitude': mc}
        point_names = list(all_points.keys())
        for i in range(len(point_names)):
            for j in range(i + 1, len(point_names)):
                p1, p2 = point_names[i], point_names[j]
                lon1, lon2 = all_points[p1]['longitude'], all_points[p2]['longitude']
                distance = abs(lon1 - lon2)
                angle = min(distance, 360 - distance)
                for aspect_angle, (aspect_name, orb) in self.aspects_ml.items():
                    if abs(angle - aspect_angle) <= orb:
                        aspects.append({
                            'point1': p1,
                            'point2': p2,
                            'aspect': aspect_name,
                            'exact_angle': aspect_angle,
                            'actual_angle': round(angle, 4),
                            'orb': round(abs(angle - aspect_angle), 4),
                            'strength': 1.0 - (abs(angle - aspect_angle) / orb)
                        })
                        break
        aspects.sort(key=lambda x: x['strength'], reverse=True)
        return aspects

    def get_planet_house_placement(self, planets: Dict, houses: Dict) -> Dict:
        house_placement = {}
        for planet_name, planet_data in planets.items():
            planet_lon = planet_data['longitude']
            for house_num, house_data in houses.items():
                next_house_num = house_num + 1 if house_num < 12 else 1
                next_house_lon = houses[next_house_num]['cusp_longitude']
                current_lon = house_data['cusp_longitude']
                if next_house_lon < current_lon:
                    next_house_lon += 360
                    adjusted_planet_lon = planet_lon + 360 if planet_lon < current_lon else planet_lon
                else:
                    adjusted_planet_lon = planet_lon
                if current_lon <= adjusted_planet_lon < next_house_lon:
                    house_placement[planet_name] = house_num
                    break
            else:
                house_placement[planet_name] = 1
        return house_placement

    def calculate_natal_chart_ml(self, city_name: str, birth_datetime_local: datetime, timezone_str: str) -> Dict[
        str, Any]:
        try:
            lat, lon, elevation = self.get_city_coordinates(city_name)
            local_tz = pytz.timezone(timezone_str)
            birth_local = local_tz.localize(birth_datetime_local)
            birth_utc = birth_local.astimezone(pytz.utc)
            jd_ut = swe.julday(
                birth_utc.year,
                birth_utc.month,
                birth_utc.day,
                birth_utc.hour + birth_utc.minute / 60 + birth_utc.second / 3600
            )
            planets = self.calculate_planet_positions(jd_ut)
            houses_data = self.calculate_houses_ml(jd_ut, lat, lon)
            house_placement = self.get_planet_house_placement(planets, houses_data['houses'])
            aspects = self.calculate_aspects_ml(planets, houses_data['ascendant'], houses_data['midheaven'])
            return {
                'metadata': {
                    'location': {
                        'city': city_name,
                        'lat': round(lat, 4),
                        'lon': round(lon, 4),
                        'elevation': round(elevation, 1)
                    },
                    'datetime': {
                        'local': birth_local.isoformat(),
                        'utc': birth_utc.isoformat(),
                        'jd': round(jd_ut, 6)
                    },
                    'calculation': {
                        'house_system': houses_data['house_system'],
                        'ephemeris': 'DE441'
                    }
                },
                'planets': planets,
                'houses': houses_data['houses'],
                'angles': {
                    'ascendant': {
                        'longitude': houses_data['ascendant'],
                        'sign': self.zodiac_signs[floor(houses_data['ascendant'] / 30)],
                        'sign_index': floor(houses_data['ascendant'] / 30)
                    },
                    'midheaven': {
                        'longitude': houses_data['midheaven'],
                        'sign': self.zodiac_signs[floor(houses_data['midheaven'] / 30)],
                        'sign_index': floor(houses_data['midheaven'] / 30)
                    }
                },
                'placements': house_placement,
                'aspects': aspects,
                'ml_features': {
                    'sign_distribution': self._get_sign_distribution(planets, houses_data),
                    'aspect_patterns': self._get_aspect_patterns(aspects),
                    'element_balance': self._get_element_balance(planets)
                }
            }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã: {e}")
            raise

    def _get_sign_distribution(self, planets: Dict, houses_data: Dict) -> Dict[str, int]:
        distribution = {sign: 0 for sign in self.zodiac_signs}
        for planet_data in planets.values():
            distribution[planet_data['sign']] += 1
        return distribution

    def _get_aspect_patterns(self, aspects: List[Dict]) -> Dict[str, int]:
        patterns = {
            'conjunctions': 0,
            'squares': 0,
            'trines': 0,
            'oppositions': 0,
            'sextiles': 0
        }
        for aspect in aspects:
            if aspect['aspect'] in patterns:
                patterns[aspect['aspect']] += 1
        return patterns

    def _get_element_balance(self, planets: Dict) -> Dict[str, int]:
        elements = {
            'fire': ['Aries', 'Leo', 'Sagittarius'],
            'earth': ['Taurus', 'Virgo', 'Capricorn'],
            'air': ['Gemini', 'Libra', 'Aquarius'],
            'water': ['Cancer', 'Scorpio', 'Pisces']
        }
        balance = {element: 0 for element in elements}
        for planet_data in planets.values():
            for element, signs in elements.items():
                if planet_data['sign'] in signs:
                    balance[element] += 1
                    break
        return balance

    def save_ml_chart(self, natal_chart: Dict, filename: str = 'natal_chart_ml.json') -> None:
        import json
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(natal_chart, f, ensure_ascii=False, indent=2, separators=(',', ':'))
        logger.info(f"ML-–Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {filename}")

predictions.py:

from math import floor
import json
from datetime import date, datetime
import swisseph as swe
from sqlalchemy.future import select

from backend.database import async_session, NatalPredictions


class AstroPredictor:
    def __init__(self, natal_chart):
        self.natal_chart = natal_chart
        self.planets_ml = {
            swe.SUN: 'Sun', swe.MOON: 'Moon', swe.MERCURY: 'Mercury',
            swe.VENUS: 'Venus', swe.MARS: 'Mars', swe.JUPITER: 'Jupiter',
            swe.SATURN: 'Saturn', swe.URANUS: 'Uranus',
            swe.NEPTUNE: 'Neptune', swe.PLUTO: 'Pluto'
        }
        self.planet_names_to_ids = {v: k for k, v in self.planets_ml.items()}

    def calculate_transits(self, target_date):
        jd_target = swe.julday(target_date.year, target_date.month, target_date.day, 12.0)
        transits = {}
        for planet_id, name in self.planets_ml.items():
            pos, _ = swe.calc_ut(jd_target, planet_id, swe.FLG_SWIEPH)
            lon = pos[0] % 360
            transits[name] = {
                'longitude': lon,
                'sign': self.get_sign_from_longitude(lon),
                'position_in_sign': lon % 30,
                'retrograde': pos[3] < 0
            }
        return transits

    def get_sign_from_longitude(self, longitude):
        signs = ["Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo",
                 "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces"]
        return signs[floor(longitude / 30)]

    def analyze_aspects(self, transits, natal_positions):
        """–ê–Ω–∞–ª–∏–∑ –∞—Å–ø–µ–∫—Ç–æ–≤ —Å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ–º —Å–∏–ª—ã"""
        aspects = []
        for t_planet, t_data in transits.items():
            for n_planet, n_data in natal_positions.items():
                if t_planet == n_planet:
                    continue
                t_lon = t_data['longitude']
                n_lon = n_data['longitude']
                distance = abs(t_lon - n_lon)
                angle = min(distance, 360 - distance)
                aspect_info = self.check_aspect(angle)
                if aspect_info:
                    aspect_data = {
                        'transit_planet': t_planet,
                        'natal_planet': n_planet,
                        'aspect': aspect_info[0],
                        'exact_angle': aspect_info[1],
                        'actual_angle': round(angle, 2),
                        'orb': round(abs(angle - aspect_info[1]), 2),
                        'strength': round(1.0 - (abs(angle - aspect_info[1]) / aspect_info[2]), 2)
                    }

                    # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –§–õ–ê–ì –°–ò–õ–¨–ù–û–ì–û –ê–°–ü–ï–ö–¢–ê
                    aspect_data['is_strong'] = aspect_data['strength'] > 0.7

                    aspects.append(aspect_data)

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ —Å–∏–ª–µ –∞—Å–ø–µ–∫—Ç–æ–≤
        aspects.sort(key=lambda x: x['strength'], reverse=True)
        return aspects

    def check_aspect(self, angle):
        aspects = {
            0: ('conjunction', 0, 8),
            60: ('sextile', 60, 6),
            90: ('square', 90, 8),
            120: ('trine', 120, 8),
            180: ('opposition', 180, 8)
        }
        for aspect_angle, (name, exact, orb) in aspects.items():
            if abs(angle - aspect_angle) <= orb:
                return (name, exact, orb)
        return None

    def generate_prediction(self, target_date):
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –†–ê–°–ß–ï–¢–û–í"""
        try:
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∏—Ç—ã
            transits = self.calculate_transits(target_date)

            # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Ç–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            natal_positions = {}
            for name, data in self.natal_chart['planets'].items():
                if name in self.planets_ml.values():
                    natal_positions[name] = {
                        'longitude': data['longitude'],
                        'sign': data['sign'],
                        'position_in_sign': data['position_in_sign']
                    }

            # –î–æ–±–∞–≤–ª—è–µ–º —É–≥–ª—ã –∫–∞—Ä—Ç—ã
            if 'angles' in self.natal_chart:
                natal_positions['Ascendant'] = {
                    'longitude': self.natal_chart['angles']['ascendant']['longitude'],
                    'sign': self.natal_chart['angles']['ascendant']['sign'],
                    'position_in_sign': self.natal_chart['angles']['ascendant']['longitude'] % 30
                }

            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∞—Å–ø–µ–∫—Ç—ã
            aspects = self.analyze_aspects(transits, natal_positions)

            # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –ü–æ–¥—Å—á–µ—Ç —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤
            strong_aspects_count = len([a for a in aspects if a.get('is_strong', False)])

            return {
                'prediction_date': target_date.strftime('%Y-%m-%d'),
                'transits': transits,
                'aspects': aspects,
                'aspects_count': len(aspects),
                'strong_aspects_count': strong_aspects_count,  # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û
                'retrograde_planets': [p for p, data in transits.items() if data.get('retrograde')]
            }

        except Exception as e:
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –æ—à–∏–±–∫–µ
            return {
                'prediction_date': target_date.strftime('%Y-%m-%d'),
                'transits': {},
                'aspects': [],
                'aspects_count': 0,
                'strong_aspects_count': 0,
                'retrograde_planets': [],
                'calculation_error': True,
                'error_message': str(e)
            }

    async def save_prediction_to_db(self, telegram_id: int, prediction_date: date):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
        prediction = self.generate_prediction(prediction_date)
        async with async_session() as session:
            result = await session.execute(
                select(NatalPredictions).where(NatalPredictions.telegram_id == telegram_id)
            )
            existing_record = result.scalar_one_or_none()

            if existing_record:
                existing_record.predictions = prediction
                existing_record.updated_at = datetime.utcnow()
            else:
                new_record = NatalPredictions(
                    telegram_id=telegram_id,
                    predictions=prediction,
                    assistant_data={},
                )
                session.add(new_record)

            await session.commit()
        return prediction
        
        
prediction_services.py:

from backend.database import async_session, NatalPredictions
from backend.predictions import AstroPredictor
from backend.chart_services import get_user_natal_chart
from backend.matrix_services import get_user_matrix
from backend.biorhythm_services import calculate_and_save_biorhythms
from backend.aspect_recommendations import aspect_recommendations
from sqlalchemy.future import select
from sqlalchemy import func, and_
import logging
import json
from datetime import datetime, date
from typing import List, Dict, Any  # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–ù–´–ô –ò–ú–ü–û–†–¢

logger = logging.getLogger(__name__)


class DataCombiner:
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∞—Å—Ç—Ä–æ–ª–æ–≥–∏–∏ –∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤"""

    def __init__(self):
        pass

    def combine_calculation_data(self, astro_prediction: dict, biorhythm_data: dict) -> dict:
        """–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∞—Å—Ç—Ä–æ–ª–æ–≥–∏–∏ –∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤"""

        return {
            'calculation_date': datetime.now().isoformat(),
            'target_date': astro_prediction.get('prediction_date', datetime.now().date().isoformat()),
            'astro_data': {
                'transits_count': len(astro_prediction.get('transits', {})),
                'aspects_count': astro_prediction.get('aspects_count', 0),
                'strong_aspects_count': astro_prediction.get('strong_aspects_count', 0),
                'retrograde_planets': astro_prediction.get('retrograde_planets', []),
                'key_aspects': astro_prediction.get('aspects', [])[:5]  # ‚úÖ –¢–ï–ü–ï–†–¨ –°–û–î–ï–†–ñ–ò–¢ –î–ê–ù–ù–´–ï –î–õ–Ø –°–ò–õ–¨–ù–´–• –ê–°–ü–ï–ö–¢–û–í
            },
            'biorhythm_data': {
                'overall_energy': biorhythm_data.get('overall_energy', {}),
                'physical_cycle': biorhythm_data.get('cycles', {}).get('physical', {}),
                'emotional_cycle': biorhythm_data.get('cycles', {}).get('emotional', {}),
                'intellectual_cycle': biorhythm_data.get('cycles', {}).get('intellectual', {}),
                'critical_days_count': len(biorhythm_data.get('critical_days', [])),
                'peak_days_count': len(biorhythm_data.get('peak_days', []))
            },
            'calculation_metadata': {
                'calculation_timestamp': datetime.now().isoformat(),
                'data_sources': ['astrology', 'biorhythms'],
                'calculation_methods': ['swiss_ephemeris', 'sine_wave_analysis']
            }
        }


def _extract_strong_aspects(astro_data: dict) -> List[str]:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤"""
    strong_aspects = []

    try:
        key_aspects = astro_data.get('key_aspects', [])

        # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∞—Å–ø–µ–∫—Ç—ã –ø–æ —Å–∏–ª–µ (–æ—Ç —Å–∞–º—ã—Ö —Å–∏–ª—å–Ω—ã—Ö)
        sorted_aspects = sorted(key_aspects, key=lambda x: x.get('strength', 0), reverse=True)

        for aspect in sorted_aspects:
            # –§–∏–ª—å—Ç—Ä—É–µ–º —Ç–æ–ª—å–∫–æ —Å–∏–ª—å–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã (strength > 0.7)
            if aspect.get('strength', 0) > 0.7:
                transit_planet = aspect.get('transit_planet', '')
                natal_planet = aspect.get('natal_planet', '')
                aspect_type = aspect.get('aspect', '')
                strength = aspect.get('strength', 0)

                # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                if transit_planet and natal_planet and aspect_type:
                    # –ü–µ—Ä–µ–≤–æ–¥–∏–º –Ω–∞–∑–≤–∞–Ω–∏—è –ø–ª–∞–Ω–µ—Ç –Ω–∞ —Ä—É—Å—Å–∫–∏–π
                    planet_names = {
                        'Sun': '–°–æ–ª–Ω—Ü–µ', 'Moon': '–õ—É–Ω–∞', 'Mercury': '–ú–µ—Ä–∫—É—Ä–∏–π',
                        'Venus': '–í–µ–Ω–µ—Ä–∞', 'Mars': '–ú–∞—Ä—Å', 'Jupiter': '–Æ–ø–∏—Ç–µ—Ä',
                        'Saturn': '–°–∞—Ç—É—Ä–Ω', 'Uranus': '–£—Ä–∞–Ω', 'Neptune': '–ù–µ–ø—Ç—É–Ω',
                        'Pluto': '–ü–ª—É—Ç–æ–Ω', 'North_Node': '–°–µ–≤–µ—Ä–Ω—ã–π —É–∑–µ–ª',
                        'Ascendant': '–ê—Å—Ü–µ–Ω–¥–µ–Ω—Ç', 'Midheaven': '–ú–°'
                    }

                    aspect_names = {
                        'conjunction': '—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ', 'opposition': '–æ–ø–ø–æ–∑–∏—Ü–∏—è',
                        'square': '–∫–≤–∞–¥—Ä–∞—Ç', 'trine': '—Ç—Ä–∏–Ω', 'sextile': '—Å–µ–∫—Å—Ç–∏–ª—å'
                    }

                    transit_ru = planet_names.get(transit_planet, transit_planet)
                    natal_ru = planet_names.get(natal_planet, natal_planet)
                    aspect_ru = aspect_names.get(aspect_type, aspect_type)

                    # –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–ª—É –∞—Å–ø–µ–∫—Ç–∞ (‚òÖ –∑–∞ –∫–∞–∂–¥—ã–µ 0.2 —Å–∏–ª—ã)
                    strength_stars = "‚òÖ" * int(strength * 5)

                    strong_aspects.append(f"{transit_ru} ‚Üí {natal_ru} ({aspect_ru}) {strength_stars}")

        return strong_aspects

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤: {e}")
        return []


# –î–æ–±–∞–≤–∏—Ç—å –≤ –Ω–∞—á–∞–ª–æ —Ñ–∞–π–ª–∞:
from backend.aspect_recommendations import aspect_recommendations


# –û–±–Ω–æ–≤–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é format_data_for_user:
async def format_data_for_user(prediction: dict) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
    if not prediction:
        return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ä–∞—Å—á–µ—Ç–æ–≤"

    try:
        daily_data = prediction.get('daily_calculations', {})
        target_date_str = daily_data.get('target_date', '—Å–µ–≥–æ–¥–Ω—è')

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –¥–∞—Ç—ã –≤ —á–∏—Ç–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç
        try:
            target_date = datetime.fromisoformat(target_date_str).date()
            formatted_date = target_date.strftime('%d.%m.%Y')
        except:
            formatted_date = target_date_str

        lines = []
        lines.append(f"üìä **–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—á–µ—Ç–æ–≤ –Ω–∞ {formatted_date}**")
        lines.append("")

        # –ë–∏–æ—Ä–∏—Ç–º—ã
        biorhythms = daily_data.get('biorhythm_data', {})
        if biorhythms:
            overall_energy = biorhythms.get('overall_energy', {})
            lines.append(
                f"‚ö° **–û–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è:** {overall_energy.get('percentage', 0):.1f}%")

            physical = biorhythms.get('physical_cycle', {})
            emotional = biorhythms.get('emotional_cycle', {})
            intellectual = biorhythms.get('intellectual_cycle', {})

            lines.append(
                f"üí™ **–§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª:** {physical.get('percentage', 0):.1f}% ({physical.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è')})")
            lines.append(
                f"üòä **–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª:** {emotional.get('percentage', 0):.1f}% ({emotional.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è')})")
            lines.append(
                f"üß† **–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª:** {intellectual.get('percentage', 0):.1f}% ({intellectual.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è')})")
            lines.append("")

        # –ê—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
        astro_data = daily_data.get('astro_data', {})
        if astro_data:
            lines.append(
                f"üåü **–ê—Å—Ç—Ä–æ–ª–æ–≥–∏—è:** {astro_data.get('aspects_count', 0)} –∞—Å–ø–µ–∫—Ç–æ–≤, {astro_data.get('strong_aspects_count', 0)} —Å–∏–ª—å–Ω—ã—Ö")

            # ‚úÖ –î–û–ë–ê–í–õ–ï–ù–û: –ü–†–û–°–¢–´–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò –ü–û –ê–°–ü–ï–ö–¢–ê–ú
            key_aspects = astro_data.get('key_aspects', [])
            aspect_recommendations_list = aspect_recommendations.generate_aspect_recommendations(key_aspects)

            if aspect_recommendations_list:
                lines.append("üîÆ **–ê—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**")
                for rec in aspect_recommendations_list[:3]:  # –ú–∞–∫—Å–∏–º—É–º 3 —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
                    lines.append(f"   ‚Ä¢ {rec}")
                lines.append("")

            # –°–∏–ª—å–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã (–¥–µ—Ç–∞–ª—å–Ω—ã–µ)
            strong_aspects = _extract_strong_aspects(astro_data)
            if strong_aspects:
                lines.append("üìà **–°–∏–ª—å–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã:**")
                for aspect in strong_aspects[:2]:  # –¢–æ–ª—å–∫–æ 2 —Å–∞–º—ã—Ö —Å–∏–ª—å–Ω—ã—Ö
                    lines.append(f"   ‚Ä¢ {aspect}")
                lines.append("")

            retrograde_planets = astro_data.get('retrograde_planets', [])
            if retrograde_planets:
                planet_names = {
                    'Sun': '–°–æ–ª–Ω—Ü–µ', 'Moon': '–õ—É–Ω–∞', 'Mercury': '–ú–µ—Ä–∫—É—Ä–∏–π',
                    'Venus': '–í–µ–Ω–µ—Ä–∞', 'Mars': '–ú–∞—Ä—Å', 'Jupiter': '–Æ–ø–∏—Ç–µ—Ä',
                    'Saturn': '–°–∞—Ç—É—Ä–Ω', 'Uranus': '–£—Ä–∞–Ω', 'Neptune': '–ù–µ–ø—Ç—É–Ω',
                    'Pluto': '–ü–ª—É—Ç–æ–Ω'
                }
                retrograde_ru = [planet_names.get(p, p) for p in retrograde_planets]
                lines.append(f"üîÑ **–†–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω—ã–µ –ø–ª–∞–Ω–µ—Ç—ã:** {', '.join(retrograde_ru)}")

        lines.append("")
        lines.append("üéØ *–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç—Ç–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å–≤–æ–µ–≥–æ –¥–Ω—è*")

        return "\n".join(lines)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")
        return "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Ä–∞—Å—á–µ—Ç–æ–≤"


# –û–°–¢–ê–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò –û–°–¢–ê–Æ–¢–°–Ø –ë–ï–ó –ò–ó–ú–ï–ù–ï–ù–ò–ô
async def generate_and_save_prediction(telegram_id: int, target_date: date):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –¥–∞—Ç—ã (–ø–µ—Ä–µ–∑–∞–ø–∏—Å—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö)"""
    try:
        logger.info(f"üîÆ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id} –Ω–∞ {target_date}")

        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        natal_data = await get_user_natal_chart(telegram_id)
        if not natal_data:
            logger.warning(f"‚ö†Ô∏è –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")
            raise ValueError("–ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É —Å –ø–æ–º–æ—â—å—é /start")

        logger.info(f"‚úÖ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è {telegram_id}")

        # –ü–æ–ª—É—á–∞–µ–º –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        matrix_data = await get_user_matrix(telegram_id)
        logger.info(f"‚úÖ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ –ø–æ–ª—É—á–µ–Ω–∞ –¥–ª—è {telegram_id}")

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∏–æ—Ä–∏—Ç–º—ã –Ω–∞ —Ü–µ–ª–µ–≤—É—é –¥–∞—Ç—É
        biorhythm_data = await calculate_and_save_biorhythms(telegram_id, target_date)
        logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Ü–µ–ª–µ–≤—É—é –¥–∞—Ç—É
        predictor = AstroPredictor(natal_data)
        astro_prediction = predictor.generate_prediction(target_date)
        logger.info(f"‚úÖ –ê—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
        combiner = DataCombiner()
        combined_data = combiner.combine_calculation_data(astro_prediction, biorhythm_data)

        logger.info(f"‚úÖ –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–∑–¥–∞–Ω—ã –¥–ª—è {telegram_id}")

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ë–î —Å –ü–ï–†–ï–ó–ê–ü–ò–°–¨–Æ
        async with async_session() as session:
            result = await session.execute(
                select(NatalPredictions).where(NatalPredictions.telegram_id == telegram_id)
            )
            existing_record = result.scalar_one_or_none()

            # –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
            prediction_data = {
                'calculation_date': datetime.now().isoformat(),
                'target_date': target_date.isoformat(),
                'natal_chart': natal_data,
                'psyho_matrix': matrix_data,
                'daily_calculations': combined_data
            }

            if existing_record:
                # –ü–ï–†–ï–ó–ê–ü–ò–°–´–í–ê–ï–ú —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å—å
                existing_record.predictions = prediction_data
                existing_record.updated_at = func.now()
                logger.info(f"üìù –ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {telegram_id} –Ω–∞ {target_date}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
                new_record = NatalPredictions(
                    telegram_id=telegram_id,
                    predictions=prediction_data,
                    assistant_data={},
                )
                session.add(new_record)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

            await session.commit()
            logger.info(f"üíæ –î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –ë–î –¥–ª—è {telegram_id}")

        return prediction_data

    except ValueError as e:
        logger.warning(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–ª—è {telegram_id}: {e}")
        raise
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
        raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞—Å—á–µ—Ç–æ–≤: {str(e)}")



async def format_data_for_model(telegram_id: int, user_profile: dict, prediction: dict) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–æ–¥–µ–ª–∏ –ò–ò"""
    if not prediction:
        return "‚ùå No calculation data available"

    try:
        model_data = {
            'user_profile': {
                'telegram_id': telegram_id,
                'gender': user_profile.get('gender'),
                'profession': user_profile.get('profession'),
                'job_position': user_profile.get('job_position'),
                'current_city': user_profile.get('current_city'),
                'birth_date': user_profile.get('birth_date').isoformat() if user_profile.get('birth_date') else None,
                'birth_city': user_profile.get('birth_city')
            },
            'natal_chart': prediction.get('natal_chart', {}),
            'psyho_matrix': prediction.get('psyho_matrix', {}),
            'daily_calculations': prediction.get('daily_calculations', {}),
            'target_date': prediction.get('target_date'),
            'timestamp': datetime.now().isoformat()
        }

        # –ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        print("\n" + "=" * 80)
        print("ü§ñ DATA FOR AI MODEL:")
        print("=" * 80)
        print(f"üë§ User ID: {telegram_id}")
        print(f"üìÖ Target Date: {prediction.get('target_date', 'Unknown')}")
        print(f"üíº Profession: {user_profile.get('profession', 'Not specified')}")
        print(f"üìã Position: {user_profile.get('job_position', 'Not specified')}")
        print(f"üèôÔ∏è City: {user_profile.get('current_city', 'Not specified')}")

        # –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞
        natal_chart = prediction.get('natal_chart', {})
        if natal_chart:
            planets = natal_chart.get('planets', {})
            print(f"\nüåü Natal Chart: {len(planets)} planets calculated")
            print(f"   üìç Birth location: {natal_chart.get('metadata', {}).get('location', {}).get('city', 'Unknown')}")

        # –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞
        matrix = prediction.get('psyho_matrix', {})
        if matrix:
            basic_numbers = matrix.get('basic_numbers', {})
            print(f"üî¢ Psyho Matrix: First number: {basic_numbers.get('first', 'N/A')}")

        # –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã
        daily = prediction.get('daily_calculations', {})
        if daily:
            biorhythms = daily.get('biorhythm_data', {})
            astro = daily.get('astro_data', {})
            print(f"üìä Daily Calculations:")
            print(f"   ‚ö° Energy: {biorhythms.get('overall_energy', {}).get('percentage', 0):.1f}%")
            print(f"   üåü Aspects: {astro.get('aspects_count', 0)}")

        print("=" * 80)
        print("JSON Data for AI Model:")
        print("=" * 80)
        print(json.dumps(model_data, ensure_ascii=False, indent=2))
        print("=" * 80 + "\n")

        return json.dumps(model_data, ensure_ascii=False)

    except Exception as e:
        logger.error(f"‚ùå Error formatting data for model: {e}")
        return json.dumps({'error': str(e)})



async def get_user_predictions(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(NatalPredictions).where(NatalPredictions.telegram_id == telegram_id)
            )
            predictions = result.scalar_one_or_none()

            if predictions:
                return predictions.predictions
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö {telegram_id}: {e}")
        return None



async def get_prediction_statistics(telegram_id: int) -> dict:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        prediction = await get_user_predictions(telegram_id)
        if not prediction:
            return {}

        daily_data = prediction.get('daily_calculations', {})
        return {
            'last_calculation_date': prediction.get('calculation_date'),
            'target_date': prediction.get('target_date'),
            'biorhythm_energy': daily_data.get('biorhythm_data', {}).get('overall_energy', {}).get('percentage', 0),
            'astro_aspects_count': daily_data.get('astro_data', {}).get('aspects_count', 0)
        }

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è {telegram_id}: {e}")
        return {}


async def validate_prediction_data(telegram_id: int) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö"""
    try:
        prediction = await get_user_predictions(telegram_id)
        if not prediction:
            return False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        required_fields = ['natal_chart', 'psyho_matrix', 'daily_calculations', 'target_date']
        for field in required_fields:
            if field not in prediction:
                return False

        return True

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
        return False


async def cleanup_old_predictions():
    """–û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
    try:
        logger.info("üîÑ –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ")
        return 0

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return 0
        
        
prompt_builder.py

import logging
from typing import Dict, Any
from datetime import datetime

logger = logging.getLogger(__name__)


class PromptBuilder:
    """
    –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Å—Ç—Ä–æ–∏—Ç–µ–ª—å –ø—Ä–æ–º–ø—Ç–æ–≤ –¥–ª—è AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
    """

    def __init__(self):
        self.templates = {
            'daily_recommendations': self._daily_recommendations_template,
            'professional_focus': self._professional_focus_template,
            'energy_management': self._energy_management_template
        }

    def build_prompt(self, data: Dict[str, Any], prompt_type: str = 'daily_recommendations') -> str:
        """
        –°—Ç—Ä–æ–∏—Ç –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø—Ä–æ–º–ø—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        """
        template = self.templates.get(prompt_type, self._daily_recommendations_template)
        return template(data)

    def _daily_recommendations_template(self, data: Dict[str, Any]) -> str:
        """–®–∞–±–ª–æ–Ω –¥–ª—è –µ–∂–µ–¥–Ω–µ–≤–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        user_context = data.get('user_context', {})
        energy_state = data.get('energy_state', {})
        astro_highlights = data.get('astro_highlights', {})

        # –ö–ª—é—á–µ–≤—ã–µ –∏–Ω—Å–∞–π—Ç—ã –∏–∑ –∞—Å—Ç—Ä–æ–¥–∞–Ω–Ω—ã—Ö
        key_insights = self._extract_key_insights(astro_highlights)

        prompt = f"""–ù–∞ –æ—Å–Ω–æ–≤–µ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã—Ö —Ä–∞—Å—á–µ—Ç–æ–≤ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å –ö–û–ù–ö–†–ï–¢–ù–´–ï –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –¥–µ–Ω—å.

–ö–û–ù–¢–ï–ö–°–¢ –ü–û–õ–¨–ó–û–í–ê–¢–ï–õ–Ø:
‚Ä¢ –ü—Ä–æ—Ñ–µ—Å—Å–∏—è: {user_context.get('profession', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}
‚Ä¢ –î–æ–ª–∂–Ω–æ—Å—Ç—å: {user_context.get('position', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}
‚Ä¢ –ì–æ—Ä–æ–¥: {user_context.get('current_city', '–Ω–µ —É–∫–∞–∑–∞–Ω')}

–≠–ù–ï–†–ì–ï–¢–ò–ß–ï–°–ö–ò–ô –ü–†–û–§–ò–õ–¨:
{self._format_energy_state(energy_state)}

–ê–°–¢–†–û–õ–û–ì–ò–ß–ï–°–ö–ò–ï –ò–ù–°–ê–ô–¢–´:
{key_insights}

–°–§–û–†–ú–£–õ–ò–†–£–ô 3-5 –ö–û–ù–ö–†–ï–¢–ù–´–• –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ô:
1. üíº –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ñ–æ–∫—É—Å (—á—Ç–æ –¥–µ–ª–∞—Ç—å –Ω–∞ —Ä–∞–±–æ—Ç–µ)
2. üèÉ –õ–∏—á–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (–∫–∞–∫ –æ—Ä–≥–∞–Ω–∏–∑–æ–≤–∞—Ç—å –¥–µ–Ω—å)  
3. ‚ù§Ô∏è –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å (–Ω–∞ —á—Ç–æ –æ–±—Ä–∞—Ç–∏—Ç—å –≤–Ω–∏–º–∞–Ω–∏–µ)
4. üéØ –ö–ª—é—á–µ–≤–∞—è –∑–∞–¥–∞—á–∞ –¥–Ω—è (—Å–∞–º–æ–µ –≤–∞–∂–Ω–æ–µ)

–û–¢–í–ï–¢ (—Ç–æ–ª—å–∫–æ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏, –±–µ–∑ –ø–æ—è—Å–Ω–µ–Ω–∏–π):"""

        return prompt

    def _professional_focus_template(self, data: Dict[str, Any]) -> str:
        """–®–∞–±–ª–æ–Ω –¥–ª—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        user_context = data.get('user_context', {})

        return f"""–°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Å—è –Ω–∞ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è—Ö –¥–ª—è:

–ü—Ä–æ—Ñ–µ—Å—Å–∏—è: {user_context.get('profession', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}
–î–æ–ª–∂–Ω–æ—Å—Ç—å: {user_context.get('position', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}

–î–∞–π 3 –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö —Å–æ–≤–µ—Ç–∞ –ø–æ:
1. –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–∞–±–æ—á–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞
2. –†–µ—à–µ–Ω–∏—é –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –∑–∞–¥–∞—á
3. –†–∞–∑–≤–∏—Ç–∏—é –Ω–∞–≤—ã–∫–æ–≤

–û–¢–í–ï–¢:"""

    def _energy_management_template(self, data: Dict[str, Any]) -> str:
        """–®–∞–±–ª–æ–Ω –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–µ–π"""
        energy_state = data.get('energy_state', {})

        return f"""–î–∞–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—é —ç–Ω–µ—Ä–≥–∏–µ–π –Ω–∞ –æ—Å–Ω–æ–≤–µ:

{self._format_energy_state(energy_state)}

–°–æ–≤–µ—Ç—ã –ø–æ:
1. –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é –Ω–∞–≥—Ä—É–∑–∫–∏
2. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—é —Å–∏–ª
3. –ü–∏–∫–∞–º –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏

–û–¢–í–ï–¢:"""

    def _format_energy_state(self, energy_state: Dict[str, Any]) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –æ–± —ç–Ω–µ—Ä–≥–∏–∏"""
        overall = energy_state.get('overall_energy', {})
        physical = energy_state.get('physical_cycle', {})
        emotional = energy_state.get('emotional_cycle', {})
        intellectual = energy_state.get('intellectual_cycle', {})

        return f"""‚Ä¢ –û–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è: {overall.get('percentage', 0)}% ({overall.get('level', '—Å—Ä–µ–¥–Ω–∏–π')})
‚Ä¢ –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª: {physical.get('percentage', 0)}% ({physical.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π')})
‚Ä¢ –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª: {emotional.get('percentage', 0)}% ({emotional.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π')})
‚Ä¢ –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª: {intellectual.get('percentage', 0)}% ({intellectual.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π')})"""

    def _extract_key_insights(self, astro_highlights: Dict[str, Any]) -> str:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–ª—é—á–µ–≤—ã—Ö –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –∏–Ω—Å–∞–π—Ç–æ–≤"""
        if not astro_highlights:
            return "‚Ä¢ –°—Ç–∞–±–∏–ª—å–Ω—ã–π –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ñ–æ–Ω"

        insights = []

        # –°–∏–ª—å–Ω—ã–µ –∞—Å–ø–µ–∫—Ç—ã
        strong_aspects = astro_highlights.get('strong_aspects_count', 0)
        if strong_aspects > 3:
            insights.append(f"‚Ä¢ {strong_aspects} —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ - –¥–µ–Ω—å –≤–∞–∂–Ω—ã—Ö —Å–æ–±—ã—Ç–∏–π")
        elif strong_aspects > 0:
            insights.append(f"‚Ä¢ {strong_aspects} –∑–Ω–∞—á–∏–º—ã—Ö –∞—Å–ø–µ–∫—Ç–∞")

        # –†–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω—ã–µ –ø–ª–∞–Ω–µ—Ç—ã
        retrograde = astro_highlights.get('retrograde_planets', [])
        if retrograde:
            insights.append(f"‚Ä¢ –†–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω—ã–µ: {', '.join(retrograde)} - –≤—Ä–µ–º—è –ø–µ—Ä–µ—Å–º–æ—Ç—Ä–∞")

        return '\n'.join(insights) if insights else "‚Ä¢ –ë–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω—ã–π –¥–µ–Ω—å –¥–ª—è –ø–ª–∞–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á"


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
prompt_builder = PromptBuilder()


psyho_matrix.py:

from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class PsyhoMatrixCalculator:
    def __init__(self):
        pass

    def calculate_matrix(self, birth_date: datetime.date):
        """–†–∞—Å—á–µ—Ç –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ø–æ –¥–∞—Ç–µ —Ä–æ–∂–¥–µ–Ω–∏—è (–Ω—É–º–µ—Ä–æ–ª–æ–≥–∏—è –ü–∏—Ñ–∞–≥–æ—Ä–∞)"""
        day = birth_date.day
        month = birth_date.month
        year = birth_date.year

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞—Ç—É –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
        date_str = f"{day:02d}{month:02d}{year}"

        # –ü–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ - —Å—É–º–º–∞ –≤—Å–µ—Ö —Ü–∏—Ñ—Ä –¥–∞—Ç—ã
        first_number = sum(int(d) for d in date_str)

        # –í—Ç–æ—Ä–æ–µ —á–∏—Å–ª–æ - —Å—É–º–º–∞ —Ü–∏—Ñ—Ä –ø–µ—Ä–≤–æ–≥–æ —á–∏—Å–ª–∞
        second_number = sum(int(d) for d in str(first_number))

        # –¢—Ä–µ—Ç—å–µ —á–∏—Å–ª–æ - –ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Å —É–¥–≤–æ–µ–Ω–Ω–∞—è –ø–µ—Ä–≤–∞—è —Ü–∏—Ñ—Ä–∞ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è
        first_digit_of_day = day // 10
        third_number = first_number - 2 * first_digit_of_day

        # –ß–µ—Ç–≤–µ—Ä—Ç–æ–µ —á–∏—Å–ª–æ - —Å—É–º–º–∞ —Ü–∏—Ñ—Ä —Ç—Ä–µ—Ç—å–µ–≥–æ —á–∏—Å–ª–∞
        fourth_number = sum(int(d) for d in str(third_number))

        # –°—Ç—Ä–æ–∏–º –º–∞—Ç—Ä–∏—Ü—É 3x3 –ø–æ –º–µ—Ç–æ–¥—É –ü–∏—Ñ–∞–≥–æ—Ä–∞
        matrix_numbers = self._build_pythagoras_matrix(day, month, year)

        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –†–ê–°–ß–ï–¢–û–í
        matrix_data = {
            'basic_numbers': {
                'first': first_number,
                'second': second_number,
                'third': third_number,
                'fourth': fourth_number
            },
            'pythagoras_matrix': matrix_numbers,
            'digit_counts': self._calculate_digit_counts(matrix_numbers),
            'calculated_at': datetime.now().isoformat()
        }

        return matrix_data

    def _build_pythagoras_matrix(self, day: int, month: int, year: int):
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ü–∏—Ñ–∞–≥–æ—Ä–∞ 3x3"""
        # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ü–∏—Ñ—Ä—ã –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è
        all_digits = []
        all_digits.extend([int(d) for d in str(day)])
        all_digits.extend([int(d) for d in str(month)])
        all_digits.extend([int(d) for d in str(year)])

        # –°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–∂–¥–æ–π —Ü–∏—Ñ—Ä—ã –æ—Ç 1 –¥–æ 9
        matrix = {}
        for i in range(1, 10):
            matrix[str(i)] = all_digits.count(i)

        return matrix

    def _calculate_digit_counts(self, matrix):
        """–†–∞—Å—á–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —Ü–∏—Ñ—Ä–∞–º"""
        return {
            'total_digits': sum(matrix.values()),
            'strong_digits': [digit for digit, count in matrix.items() if count >= 2],
            'missing_digits': [digit for digit in map(str, range(1, 10)) if matrix.get(digit, 0) == 0]
        }

user_services.py:  

from backend.database import async_session, User
from sqlalchemy.future import select
from sqlalchemy import func  # ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–û–¢ –ò–ú–ü–û–†–¢
from datetime import datetime  # ‚Üê –î–û–ë–ê–í–ò–¢–¨ –î–õ–Ø calculated_at
import logging

logger = logging.getLogger(__name__)


async def create_or_update_user(
        telegram_id: int,
        birth_date,
        birth_time,
        birth_city: str,
        profession: str = None,
        job_position: str = None,
        current_city: str = None,
        gender: str = None
):
    """–°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user.birth_date = birth_date
                user.birth_time = birth_time
                user.birth_city = birth_city
                if profession:
                    user.profession = profession
                if job_position:
                    user.job_position = job_position
                if current_city:
                    user.current_city = current_city
                if gender is not None:
                    user.gender = gender
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user = User(
                    telegram_id=telegram_id,
                    birth_date=birth_date,
                    birth_time=birth_time,
                    birth_city=birth_city,
                    profession=profession,
                    job_position=job_position,
                    current_city=current_city,
                    gender=gender,
                    request_count=0
                )
                session.add(user)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id}")

            await session.commit()
            return user

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {telegram_id}: {e}")
        raise


async def get_user_profile(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                return {
                    'telegram_id': user.telegram_id,
                    'birth_date': user.birth_date,
                    'birth_time': user.birth_time,
                    'birth_city': user.birth_city,
                    'profession': user.profession,
                    'job_position': user.job_position,
                    'current_city': user.current_city,
                    'gender': user.gender,
                    'request_count': user.request_count or 0,
                    'created_at': user.created_at
                }
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è {telegram_id}: {e}")
        return None


async def update_user_profession(telegram_id: int, profession: str, job_position: str = None):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                user.profession = profession
                if job_position:
                    user.job_position = job_position
                await session.commit()
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è {telegram_id}")
                return user
            else:
                raise ValueError("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ {telegram_id}: {e}")
        raise


async def increment_request_count(telegram_id: int):
    """–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                current_count = user.request_count or 0
                user.request_count = current_count + 1
                await session.commit()
                logger.info(f"üìà –£–≤–µ–ª–∏—á–µ–Ω —Å—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π –¥–ª—è {telegram_id}: {current_count} -> {user.request_count}")
                return user.request_count
            else:
                logger.warning(f"‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ —Å—á–µ—Ç—á–∏–∫–∞")
                return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ —Å—á–µ—Ç—á–∏–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏–π {telegram_id}: {e}")
        return None


async def get_user_request_count(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–±—Ä–∞—â–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User.request_count).where(User.telegram_id == telegram_id)
            )
            count = result.scalar_one_or_none()
            return count or 0

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—á–µ—Ç—á–∏–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏–π {telegram_id}: {e}")
        return 0


async def update_user_gender(telegram_id: int, gender: str):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                user.gender = gender
                await session.commit()
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}: {gender}")
                return user
            else:
                raise ValueError("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª–∞ {telegram_id}: {e}")
        raise


async def get_users_statistics():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    try:
        async with async_session() as session:
            # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            total_users_result = await session.execute(
                select(User).where(User.telegram_id.isnot(None))
            )
            total_users = len(total_users_result.scalars().all())

            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–º –ø–æ–ª–æ–º
            users_with_gender_result = await session.execute(
                select(User).where(User.gender.isnot(None))
            )
            users_with_gender = len(users_with_gender_result.scalars().all())

            # –°—Ä–µ–¥–Ω–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞—â–µ–Ω–∏–π
            avg_requests_result = await session.execute(
                select(func.avg(User.request_count)).where(User.request_count > 0)
            )
            avg_requests = avg_requests_result.scalar() or 0

            return {
                'total_users': total_users,
                'users_with_gender': users_with_gender,
                'gender_fill_rate': round((users_with_gender / total_users * 100) if total_users > 0 else 0, 2),
                'average_requests': round(avg_requests, 2),
                'calculated_at': datetime.now().isoformat()
            }

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return {
            'total_users': 0,
            'users_with_gender': 0,
            'gender_fill_rate': 0,
            'average_requests': 0,
            'error': str(e)
        }
        
ai_engine.py:

import aiohttp
import asyncio
import logging
import os
import time
import hashlib
import json
from typing import Dict, Any, List, Optional
from datetime import datetime

logger = logging.getLogger(__name__)


class AIPredictionEngine:
    """
    –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –¥–≤–∏–∂–æ–∫ –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Ollama API —Å –æ–¥–Ω–æ–π –º–æ–¥–µ–ª—å—é (gemma:2b)
    –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω —Å prompt_builder –∏ recommendation_service
    """

    def __init__(self, base_url: str = None):
        self.base_url = base_url or os.getenv('OLLAMA_URL', 'http://localhost:11435')

        # –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –º–æ–¥–µ–ª—å - gemma:2b
        #self.model = "gemma:2b"
        self.model = "tinyllama:1.1b"

        # –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ç–∞–π–º–∞—É—Ç—ã
        self.timeout = aiohttp.ClientTimeout(total=600)  # 180 —Å–µ–∫—É–Ω–¥
        self.max_retries = 2
        self.retry_delay = 2

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
        self.prompt_builder = None
        self.recommendation_service = None
        self._dependencies_initialized = False

        # –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        self.stats = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "average_response_time": 0,
            "current_model": self.model,
            "last_health_check": None,
            "service_available": False
        }

        logger.info(f"ü§ñ AI –¥–≤–∏–∂–æ–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω: {self.base_url}, –º–æ–¥–µ–ª—å: {self.model}")

    async def _initialize_dependencies(self):
        """–õ–µ–Ω–∏–≤–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π"""
        if not self._dependencies_initialized:
            try:
                from backend.prompt_builder import prompt_builder
                from backend.recommendation_service import recommendation_service

                self.prompt_builder = prompt_builder
                self.recommendation_service = recommendation_service
                self._dependencies_initialized = True
                logger.info("‚úÖ –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ AI –¥–≤–∏–∂–∫–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã")
            except ImportError as e:
                logger.warning(f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: {e}")
                self._dependencies_initialized = True  # –ü–æ–º–µ—á–∞–µ–º –∫–∞–∫ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ, –¥–∞–∂–µ –µ—Å–ª–∏ –µ—Å—Ç—å –æ—à–∏–±–∫–∏

    def _generate_data_hash(self, data: Dict[str, Any]) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö—ç—à–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è"""
        try:
            # –°–æ–∑–¥–∞–µ–º —Å—Ç–∞–±–∏–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è
            stable_data = {
                'user_context': data.get('user_context', {}),
                'energy_state': data.get('energy_state', {}),
                'target_date': data.get('target_date'),
                'telegram_id': data.get('user_profile', {}).get('telegram_id')
            }

            data_str = json.dumps(stable_data, sort_keys=True, ensure_ascii=False)
            return hashlib.sha256(data_str.encode()).hexdigest()
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ö—ç—à–∞ –¥–∞–Ω–Ω—ã—Ö: {e}")
            return "fallback_hash"

    async def test_connection(self) -> Dict[str, Any]:
        """
        –ë—ã—Å—Ç—Ä–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ –º–æ–¥–µ–ª–∏
        """
        test_result = {
            "ollama_available": False,
            "model_loaded": False,
            "test_passed": False,
            "response_time": None,
            "error": None,
            "details": {
                "available_models": [],
                "test_response": None,
                "model_details": {}
            }
        }

        try:
            start_time = time.time()

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Ollama
            test_result["ollama_available"] = await self.check_health()

            if test_result["ollama_available"]:
                # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –º–æ–¥–µ–ª–∏
                available_models = await self.get_available_models()
                test_result["model_loaded"] = self.model in available_models
                test_result["details"]["available_models"] = available_models

                # –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª–∏ –º–æ–¥–µ–ª–∏
                if test_result["model_loaded"]:
                    model_details = await self.get_model_details()
                    test_result["details"]["model_details"] = model_details

                # –ë—ã—Å—Ç—Ä—ã–π —Ç–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å
                if test_result["model_loaded"]:
                    test_data = {
                        "user_context": {"profession": "—Ç–µ—Å—Ç", "position": "—Ç–µ—Å—Ç"},
                        "energy_state": {
                            "overall_energy": {"percentage": 75},
                            "physical_cycle": {"phase": "–≤—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"},
                            "emotional_cycle": {"phase": "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è"}
                        },
                        "target_date": datetime.now().date().isoformat()
                    }

                    test_response = await self.generate_recommendations(test_data)
                    test_result["test_passed"] = test_response["success"]
                    test_result["response_time"] = test_response.get("response_time_seconds")

            test_result["response_time"] = time.time() - start_time
            self.stats["service_available"] = test_result["ollama_available"]
            self.stats["last_health_check"] = datetime.now().isoformat()

        except Exception as e:
            test_result["error"] = str(e)
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {e}")
            self.stats["service_available"] = False

        return test_result

    async def get_available_models(self) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π"""
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                async with session.get(f"{self.base_url}/api/tags") as response:
                    if response.status == 200:
                        data = await response.json()
                        return [model["name"] for model in data.get("models", [])]
                    else:
                        logger.warning(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–æ–¥–µ–ª–µ–π: {response.status}")
                        return []
        except Exception as e:
            logger.debug(f"–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–¥–µ–ª–µ–π: {e}")
            return []

    async def get_model_details(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª–µ–π —Ç–µ–∫—É—â–µ–π –º–æ–¥–µ–ª–∏"""
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                async with session.post(f"{self.base_url}/api/show", json={"name": self.model}) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        return {"error": f"Status {response.status}"}
        except Exception as e:
            return {"error": str(e)}

    async def check_health(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ Ollama —Å–µ—Ä–≤–∏—Å–∞"""
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                async with session.get(f"{self.base_url}/api/tags") as response:
                    if response.status == 200:
                        self.stats["service_available"] = True
                        return True
        except Exception as e:
            logger.debug(f"‚ùå Ollama –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {e}")

        self.stats["service_available"] = False
        return False

    async def ensure_model_loaded(self) -> bool:
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∏ –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∑–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏"""
        try:
            available_models = await self.get_available_models()
            if self.model not in available_models:
                logger.info(f"üîÑ –ú–æ–¥–µ–ª—å {self.model} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –ø—ã—Ç–∞—é—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å...")
                return await self.pull_model()
            return True
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –º–æ–¥–µ–ª–∏: {e}")
            return False

    async def pull_model(self) -> bool:
        """–ó–∞–≥—Ä—É–∑–∫–∞ –º–æ–¥–µ–ª–∏"""
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=300)) as session:
                async with session.post(f"{self.base_url}/api/pull", json={"name": self.model}) as response:
                    if response.status == 200:
                        logger.info(f"‚úÖ –ú–æ–¥–µ–ª—å {self.model} —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")
                        return True
                    else:
                        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏: {response.status}")
                        return False
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –º–æ–¥–µ–ª–∏: {e}")
            return False

    async def generate_recommendations(self, prepared_data: Dict) -> Dict[str, Any]:
        """
        –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        """
        start_time = time.time()
        self.stats["total_requests"] += 1

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
        await self._initialize_dependencies()

        # –ü–†–û–í–ï–†–Ø–ï–ú –ö–≠–®
        try:
            if self.recommendation_service:
                data_hash = self._generate_data_hash(prepared_data)
                telegram_id = prepared_data.get('user_profile', {}).get('telegram_id')
                target_date_str = prepared_data.get('target_date')

                if telegram_id and target_date_str:
                    target_date = datetime.fromisoformat(target_date_str).date()
                    cached = await self.recommendation_service.get_cached_recommendations(
                        telegram_id, target_date, data_hash
                    )
                    if cached:
                        logger.info(f"‚úÖ –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω—ã –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è {telegram_id}")
                        return {
                            "success": True,
                            "recommendations": cached['recommendations'],
                            "from_cache": True,
                            "model_used": cached.get('model_version', self.model),
                            "response_time_seconds": 0.1,
                            "timestamp": datetime.now().isoformat()
                        }
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∫—ç—à–∞: {e}")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–µ—Ä–≤–∏—Å–∞
        if not await self.check_health():
            return self._get_fallback_response(prepared_data, "–°–µ—Ä–≤–∏—Å AI –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω")

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –º–æ–¥–µ–ª–∏
        if not await self.ensure_model_loaded():
            return self._get_fallback_response(prepared_data, "–ú–æ–¥–µ–ª—å AI –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–∞")

        try:
            # –§–æ—Ä–º–∏—Ä—É–µ–º –ø—Ä–æ–º–ø—Ç —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º prompt_builder
            prompt = await self._build_prompt_optimized(prepared_data)
            response_text = await self._make_ollama_request(prompt)
            recommendations = self._parse_response(response_text)

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –∫—ç—à
            try:
                if self.recommendation_service and telegram_id and target_date_str:
                    await self.recommendation_service.save_recommendations(
                        telegram_id,
                        datetime.fromisoformat(target_date_str).date(),
                        data_hash,
                        response_text,
                        self.model
                    )
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –∫—ç—à: {e}")

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            response_time = time.time() - start_time
            self.stats["successful_requests"] += 1

            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–µ–¥–Ω–µ–µ –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞
            prev_avg = self.stats["average_response_time"]
            prev_count = self.stats["successful_requests"] - 1
            self.stats["average_response_time"] = (
                (prev_avg * prev_count + response_time) / self.stats["successful_requests"]
                if self.stats["successful_requests"] > 0 else response_time
            )

            logger.info(f"‚úÖ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –∑–∞ {response_time:.2f}—Å")

            return {
                "success": True,
                "recommendations": recommendations,
                "response_text": response_text,
                "model_used": self.model,
                "response_time_seconds": round(response_time, 2),
                "timestamp": datetime.now().isoformat(),
                "from_cache": False
            }

        except Exception as e:
            self.stats["failed_requests"] += 1
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π: {e}")
            return self._get_fallback_response(prepared_data, str(e))

    async def _build_prompt_optimized(self, data: Dict) -> str:
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Ä–æ–º–ø—Ç–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º prompt_builder"""
        try:
            if self.prompt_builder:
                return self.prompt_builder.build_prompt(data)
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ prompt_builder, –∏—Å–ø–æ–ª—å–∑—É–µ–º fallback: {e}")

        # Fallback –ø—Ä–æ–º–ø—Ç
        user_context = data.get("user_context", {})
        energy_state = data.get("energy_state", {})

        return f"""–ù–∞ –æ—Å–Ω–æ–≤–µ –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø—Ä–µ–¥–æ—Å—Ç–∞–≤—å –∫—Ä–∞—Ç–∫–∏–µ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –¥–µ–Ω—å.

–ü–†–û–§–ò–õ–¨:
‚Ä¢ –ü—Ä–æ—Ñ–µ—Å—Å–∏—è: {user_context.get('profession', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}
‚Ä¢ –î–æ–ª–∂–Ω–æ—Å—Ç—å: {user_context.get('position', '–Ω–µ —É–∫–∞–∑–∞–Ω–∞')}

–°–û–°–¢–û–Ø–ù–ò–ï:
‚Ä¢ –û–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è: {energy_state.get('overall_energy', {}).get('percentage', 0)}%
‚Ä¢ –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª: {energy_state.get('physical_cycle', {}).get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π')}
‚Ä¢ –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª: {energy_state.get('emotional_cycle', {}).get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω—ã–π')}

–°–§–û–†–ú–£–õ–ò–†–£–ô –ö–†–ê–¢–ö–ò–ï –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò:
1. üíº –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å
2. üèÉ –õ–∏—á–Ω–∞—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å  
3. ‚ù§Ô∏è –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ

–û–¢–í–ï–¢:"""

    async def _make_ollama_request(self, prompt: str) -> str:
        """–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å –∫ Ollama API"""
        last_exception = None

        for attempt in range(self.max_retries):
            try:
                async with aiohttp.ClientSession(timeout=self.timeout) as session:
                    # –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è gemma:2b
                    options = {
                        "temperature": 0.7,
                        "top_p": 0.9,
                        "num_predict": 250,
                        "num_thread": 2,
                        "repeat_penalty": 1.1,
                        "top_k": 40
                    }

                    request_data = {
                        "model": self.model,
                        "prompt": prompt,
                        "stream": False,
                        "options": options
                    }

                    logger.info(f"üîÑ –ó–∞–ø—Ä–æ—Å –∫ {self.model} (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}/{self.max_retries})")

                    async with session.post(f"{self.base_url}/api/generate", json=request_data) as response:
                        if response.status == 200:
                            result = await response.json()
                            response_text = result.get("response", "").strip()

                            # –õ–æ–≥–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å
                            if "eval_duration" in result:
                                eval_time = result["eval_duration"] / 1_000_000_000
                                logger.debug(f"‚è±Ô∏è –í—Ä–µ–º—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –º–æ–¥–µ–ª–∏: {eval_time:.2f}—Å")

                            return response_text
                        else:
                            error_text = await response.text()
                            raise Exception(f"Ollama API error {response.status}: {error_text}")

            except asyncio.TimeoutError:
                last_exception = Exception(f"–¢–∞–π–º–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞ (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1})")
                logger.warning(f"‚è∞ –¢–∞–π–º–∞—É—Ç –∑–∞–ø—Ä–æ—Å–∞, –ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}")

            except Exception as e:
                last_exception = e
                logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ (–ø–æ–ø—ã—Ç–∫–∞ {attempt + 1}): {e}")

            # –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–æ–π
            if attempt < self.max_retries - 1:
                await asyncio.sleep(self.retry_delay * (attempt + 1))

        raise last_exception or Exception("–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∑–∞–ø—Ä–æ—Å –∫ AI")

    def _parse_response(self, response_text: str) -> Dict[str, Any]:
        """–£–ø—Ä–æ—â–µ–Ω–Ω—ã–π –ø–∞—Ä—Å–∏–Ω–≥ –æ—Ç–≤–µ—Ç–∞ –º–æ–¥–µ–ª–∏"""
        try:
            # –ë–∞–∑–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
            categories = {
                "professional": [],
                "personal_effectiveness": [],
                "emotional": [],
                "daily_focus": []
            }

            lines = [line.strip() for line in response_text.split('\n') if line.strip()]
            current_category = None

            for line in lines:
                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏—é –ø–æ –º–∞—Ä–∫–µ—Ä–∞–º
                line_lower = line.lower()
                if any(marker in line_lower for marker in ['üíº', '—Ä–∞–±–æ—Ç–∞', '–ø—Ä–æ—Ñ–µ—Å—Å–∏', 'professional']):
                    current_category = "professional"
                elif any(marker in line_lower for marker in ['üèÉ', '–ª–∏—á–Ω', '—ç—Ñ—Ñ–µ–∫—Ç–∏–≤', 'personal']):
                    current_category = "personal_effectiveness"
                elif any(marker in line_lower for marker in ['‚ù§Ô∏è', '—ç–º–æ—Ü', '–Ω–∞—Å—Ç—Ä–æ–µ–Ω', 'emotional']):
                    current_category = "emotional"
                elif any(marker in line_lower for marker in ['üéØ', '–∞–∫—Ü–µ–Ω—Ç', '—Ñ–æ–∫—É—Å', 'focus']):
                    current_category = "daily_focus"

                # –î–æ–±–∞–≤–ª—è–µ–º –ø—É–Ω–∫—Ç—ã –≤ —Ç–µ–∫—É—â—É—é –∫–∞—Ç–µ–≥–æ—Ä–∏—é
                elif current_category and line.startswith(('‚Ä¢', '-', '‚Äî', '1.', '2.', '3.')):
                    clean_line = line.lstrip('‚Ä¢-‚Äî123456789. ').strip()
                    if clean_line and len(clean_line) > 5:  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞
                        categories[current_category].append(clean_line)

            # –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –≤—ã–¥–µ–ª–∏—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–∞–∫ –µ—Å—Ç—å
            if not any(categories.values()):
                return {"raw_recommendations": response_text}

            return categories

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–≤–µ—Ç–∞: {e}")
            return {"raw_recommendations": response_text}

    def _get_fallback_response(self, data: Dict, error: str) -> Dict[str, Any]:
        """–†–µ–∑–µ—Ä–≤–Ω—ã–π –æ—Ç–≤–µ—Ç –ø—Ä–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ AI"""
        logger.warning(f"üîÑ –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è fallback –∏–∑-–∑–∞: {error}")

        return {
            "success": False,
            "error": error,
            "is_fallback": True,
            "recommendations": self._get_fallback_recommendations(data),
            "timestamp": datetime.now().isoformat(),
            "model_used": self.model
        }

    def _get_fallback_recommendations(self, data: Dict) -> Dict[str, Any]:
        """–£–º–Ω—ã–µ —Ä–µ–∑–µ—Ä–≤–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö"""
        energy_state = data.get("energy_state", {})
        overall_energy = energy_state.get("overall_energy", {}).get("percentage", 50)
        user_context = data.get("user_context", {})

        # –ü–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —ç–Ω–µ—Ä–≥–∏–∏
        if overall_energy > 75:
            energy_advice = "–ò–¥–µ–∞–ª—å–Ω—ã–π –¥–µ–Ω—å –¥–ª—è —Å–ª–æ–∂–Ω—ã—Ö –∑–∞–¥–∞—á –∏ –≤–∞–∂–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π."
            professional_tip = "–ë–µ—Ä–∏—Ç–µ—Å—å –∑–∞ –∞–º–±–∏—Ü–∏–æ–∑–Ω—ã–µ –ø—Ä–æ–µ–∫—Ç—ã"
        elif overall_energy > 50:
            energy_advice = "–•–æ—Ä–æ—à–∏–π —É—Ä–æ–≤–µ–Ω—å —ç–Ω–µ—Ä–≥–∏–∏ –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã."
            professional_tip = "–°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Ç–µ—Å—å –Ω–∞ —Ç–µ–∫—É—â–∏—Ö –∑–∞–¥–∞—á–∞—Ö"
        elif overall_energy > 25:
            energy_advice = "–≠–Ω–µ—Ä–≥–∏–∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è —Ä—É—Ç–∏–Ω–Ω—ã—Ö –∑–∞–¥–∞—á."
            professional_tip = "–ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ —Ä–∞–±–æ—Ç—É –Ω–µ–±–æ–ª—å—à–∏–º–∏ –±–ª–æ–∫–∞–º–∏"
        else:
            energy_advice = "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –±–µ—Ä–µ—á—å —Å–∏–ª—ã –∏ –¥–µ–ª–∞—Ç—å –ø–µ—Ä–µ—Ä—ã–≤—ã."
            professional_tip = "–û—Ç–ª–æ–∂–∏—Ç–µ —Å–ª–æ–∂–Ω—ã–µ –∑–∞–¥–∞—á–∏ –Ω–∞ –¥—Ä—É–≥–æ–π –¥–µ–Ω—å"

        # –£—á–∏—Ç—ã–≤–∞–µ–º –ø—Ä–æ—Ñ–µ—Å—Å–∏—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        profession = user_context.get('profession', '').lower()
        if any(word in profession for word in ['—Ä–∞–∑—Ä–∞–±–æ—Ç', '–ø—Ä–æ–≥—Ä–∞–º–º', '—Ç–µ—Ö–Ω']):
            professional_tip += ", —É–¥–µ–ª–∏—Ç–µ –≤—Ä–µ–º—è —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–º –∑–∞–¥–∞—á–∞–º"
        elif any(word in profession for word in ['—É–ø—Ä–∞–≤–ª', '–º–µ–Ω–µ–¥–∂', '—Ä—É–∫–æ–≤–æ–¥']):
            professional_tip += ", –ø—Ä–æ–≤–µ–¥–∏—Ç–µ –ø–ª–∞–Ω–µ—Ä–∫–∏ –∏ –≤—Å—Ç—Ä–µ—á–∏"

        return {
            "professional": [
                professional_tip,
                "–†–∞—Å—Å—Ç–∞–≤—å—Ç–µ –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã –≤ –∑–∞–¥–∞—á–∞—Ö"
            ],
            "personal_effectiveness": [
                energy_advice,
                "–°–æ–±–ª—é–¥–∞–π—Ç–µ –±–∞–ª–∞–Ω—Å —Ä–∞–±–æ—Ç—ã –∏ –æ—Ç–¥—ã—Ö–∞",
                "–î–µ–ª–∞–π—Ç–µ —Ä–µ–≥—É–ª—è—Ä–Ω—ã–µ –ø–µ—Ä–µ—Ä—ã–≤—ã"
            ],
            "emotional": [
                "–°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏–µ",
                "–ò–∑–±–µ–≥–∞–π—Ç–µ –∏–º–ø—É–ª—å—Å–∏–≤–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π"
            ],
            "daily_focus": [
                "–ë–∞–ª–∞–Ω—Å –º–µ–∂–¥—É –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ—Å—Ç—å—é –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ–º"
            ]
        }

    def get_stats(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è"""
        return self.stats.copy()

    async def cleanup(self):
        """–û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤"""
        try:
            # –ó–¥–µ—Å—å –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –æ—á–∏—Å—Ç–∫—É –∫—ç—à–∞ –∏–ª–∏ –¥—Ä—É–≥–∏—Ö —Ä–µ—Å—É—Ä—Å–æ–≤
            logger.info("üßπ –†–µ—Å—É—Ä—Å—ã AI –¥–≤–∏–∂–∫–∞ –æ—á–∏—â–µ–Ω—ã")
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Ä–µ—Å—É—Ä—Å–æ–≤: {e}")


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –¥–≤–∏–∂–∫–∞
ai_engine = AIPredictionEngine()



aspect_recommendations.py

import logging
from typing import Dict, List, Any
import random

logger = logging.getLogger(__name__)


class AspectRecommendationEngine:
    """
    –ü—Ä–æ—Å—Ç–æ–π –¥–≤–∏–∂–æ–∫ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –∞—Å–ø–µ–∫—Ç–æ–≤
    –ò—Å–ø–æ–ª—å–∑—É–µ—Ç —à–∞–±–ª–æ–Ω—ã –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–æ–Ω—è—Ç–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
    """

    def __init__(self):
        # –®–∞–±–ª–æ–Ω—ã —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –ø–æ —Ç–∏–ø–∞–º –∞—Å–ø–µ–∫—Ç–æ–≤
        self.aspect_templates = {
            'conjunction': {
                'positive': [
                    "–≠–Ω–µ—Ä–≥–∏—è {transit} –∏ {natal} –æ–±—ä–µ–¥–∏–Ω—è–µ—Ç—Å—è - –∏–¥–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è –Ω–∞—á–∞–ª–∞ –Ω–æ–≤—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤",
                    "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ {transit} —Å {natal} –¥–∞–µ—Ç –º–æ—â–Ω—ã–π –∏–º–ø—É–ª—å—Å –¥–ª—è –¥–µ–π—Å—Ç–≤–∏–π",
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–Ω—É—é —ç–Ω–µ—Ä–≥–∏—é {transit} –∏ {natal} –¥–ª—è —Ä–µ—à–∏—Ç–µ–ª—å–Ω—ã—Ö —à–∞–≥–æ–≤"
                ],
                'challenge': [
                    "–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ {transit} –∏ {natal} –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ - –±—É–¥—å—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã –≤ –æ–±—â–µ–Ω–∏–∏",
                    "–≠–Ω–µ—Ä–≥–∏—è –∞—Å–ø–µ–∫—Ç–∞ –æ—á–µ–Ω—å –∫–æ–Ω—Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω–∞—è - –∏–∑–±–µ–≥–∞–π—Ç–µ –ø–æ—Å–ø–µ—à–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π",
                    "–°—Ñ–æ–∫—É—Å–∏—Ä—É–π—Ç–µ –º–æ—â–Ω—É—é —ç–Ω–µ—Ä–≥–∏—é —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–∞ –æ–¥–Ω–æ–π –≤–∞–∂–Ω–æ–π –∑–∞–¥–∞—á–µ"
                ]
            },
            'opposition': {
                'positive': [
                    "–û–ø–ø–æ–∑–∏—Ü–∏—è {transit} –∏ {natal} –ø–æ–º–æ–≥–∞–µ—Ç —É–≤–∏–¥–µ—Ç—å —Ä–∞–∑–Ω—ã–µ —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è",
                    "–ò–¥–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è –ø–µ—Ä–µ–≥–æ–≤–æ—Ä–æ–≤ –∏ –ø–æ–∏—Å–∫–∞ –∫–æ–º–ø—Ä–æ–º–∏—Å—Å–æ–≤",
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–æ—Ç–∏–≤–æ—Å—Ç–æ—è–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–π –¥–ª—è –±–∞–ª–∞–Ω—Å–∞ –≤ –æ—Ç–Ω–æ—à–µ–Ω–∏—è—Ö"
                ],
                'challenge': [
                    "–û–ø–ø–æ–∑–∏—Ü–∏—è {transit}-{natal} –º–æ–∂–µ—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å –∫–æ–Ω—Ñ–ª–∏–∫—Ç—ã - –ø—Ä–æ—è–≤–ª—è–π—Ç–µ –≥–∏–±–∫–æ—Å—Ç—å",
                    "–í–æ–∑–º–æ–∂–Ω—ã –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—è - –∏—â–∏—Ç–µ –∑–æ–ª–æ—Ç—É—é —Å–µ—Ä–µ–¥–∏–Ω—É",
                    "–ò–∑–±–µ–≥–∞–π—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—á–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π –ø—Ä–∏ —ç—Ç–æ–º –∞—Å–ø–µ–∫—Ç–µ"
                ]
            },
            'square': {
                'positive': [
                    "–ö–≤–∞–¥—Ä–∞—Ç {transit} –∏ {natal} –¥–∞–µ—Ç —ç–Ω–µ—Ä–≥–∏—é –¥–ª—è –ø—Ä–µ–æ–¥–æ–ª–µ–Ω–∏—è –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏–π",
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–∞–ø—Ä—è–∂–µ–Ω–∏–µ –∞—Å–ø–µ–∫—Ç–∞ –¥–ª—è –º–æ–±–∏–ª–∏–∑–∞—Ü–∏–∏ —Å–∏–ª",
                    "–≠—Ç–æ –≤—Ä–µ–º—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –∏ —Ä–µ—à–µ–Ω–∏—è –Ω–∞–∫–æ–ø–∏–≤—à–∏—Ö—Å—è –ø—Ä–æ–±–ª–µ–º"
                ],
                'challenge': [
                    "–ö–≤–∞–¥—Ä–∞—Ç—É—Ä–∞ {transit}-{natal} —Ç—Ä–µ–±—É–µ—Ç –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç–∏ –≤ –¥–µ–π—Å—Ç–≤–∏—è—Ö",
                    "–í–æ–∑–º–æ–∂–Ω—ã –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω—ã–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ - –∏–º–µ–π—Ç–µ –∑–∞–ø–∞—Å–Ω–æ–π –ø–ª–∞–Ω",
                    "–ò–∑–±–µ–≥–∞–π—Ç–µ –∫–æ–Ω—Ñ—Ä–æ–Ω—Ç–∞—Ü–∏–∏, —Ä–µ—à–∞–π—Ç–µ –≤–æ–ø—Ä–æ—Å—ã –¥–∏–ø–ª–æ–º–∞—Ç–∏—á–Ω–æ"
                ]
            },
            'trine': {
                'positive': [
                    "–¢—Ä–∏–Ω {transit} –∏ {natal} –ø—Ä–∏–Ω–æ—Å–∏—Ç –≥–∞—Ä–º–æ–Ω–∏—é –∏ —É–¥–∞—á–Ω—ã–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏",
                    "–ë–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–∞ –∏ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–∞",
                    "–≠–Ω–µ—Ä–≥–∏—è —Ç–µ—á–µ—Ç –ª–µ–≥–∫–æ - –¥–æ–≤–µ—Ä—è–π—Ç–µ –∏–Ω—Ç—É–∏—Ü–∏–∏ –∏ –¥–µ–π—Å—Ç–≤—É–π—Ç–µ"
                ],
                'challenge': [
                    "–ü—Ä–∏ –ª–µ–≥–∫–æ–π —ç–Ω–µ—Ä–≥–∏–∏ —Ç—Ä–∏–Ω–∞ –≤–∞–∂–Ω–æ –Ω–µ —É–ø—É—Å–∫–∞—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏",
                    "–ù–µ —Ä–∞—Å—Å–ª–∞–±–ª—è–π—Ç–µ—Å—å —Å–ª–∏—à–∫–æ–º - –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –±–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω—ã–π –ø–µ—Ä–∏–æ–¥",
                    "–°–æ—Ö—Ä–∞–Ω—è–π—Ç–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å, –¥–∞–∂–µ –∫–æ–≥–¥–∞ –≤—Å–µ –¥–∞–µ—Ç—Å—è –ª–µ–≥–∫–æ"
                ]
            },
            'sextile': {
                'positive': [
                    "–°–µ–∫—Å—Ç–∏–ª—å {transit} –∏ {natal} –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç –Ω–æ–≤—ã–µ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤—ã",
                    "–ò–¥–µ–∞–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–ª–µ–∑–Ω—ã—Ö —Å–≤—è–∑–µ–π",
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–ª—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Ä–æ—Å—Ç–∞"
                ],
                'challenge': [
                    "–ü—Ä–∏ –º–Ω–æ–∂–µ—Å—Ç–≤–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –≤–∞–∂–Ω–æ –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞—Å—Å—Ç–∞–≤–∏—Ç—å –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã",
                    "–ù–µ —Ä–∞—Å–ø—ã–ª—è–π—Ç–µ—Å—å - –≤—ã–±–µ—Ä–∏—Ç–µ —Å–∞–º—ã–µ –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è",
                    "–£–¥–µ–ª–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—é –Ω–∞ –±—É–¥—É—â–µ–µ"
                ]
            }
        }

        # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º –ø–ª–∞–Ω–µ—Ç–∞–º
        self.planet_recommendations = {
            'Sun': {
                'focus': "–ª–∏—á–Ω–∞—è —ç–Ω–µ—Ä–≥–∏—è, —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å, —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–æ",
                'action': "–ø—Ä–æ—è–≤–ª—è–π—Ç–µ –∏–Ω–∏—Ü–∏–∞—Ç–∏–≤—É, –±—É–¥—å—Ç–µ –≤ —Ü–µ–Ω—Ç—Ä–µ –≤–Ω–∏–º–∞–Ω–∏—è"
            },
            'Moon': {
                'focus': "—ç–º–æ—Ü–∏–∏, –∏–Ω—Ç—É–∏—Ü–∏—è, –¥–æ–º–∞—à–Ω–∏–µ –¥–µ–ª–∞",
                'action': "–ø—Ä–∏—Å–ª—É—à–∏–≤–∞–π—Ç–µ—Å—å –∫ —á—É–≤—Å—Ç–≤–∞–º, –∑–∞–±–æ—Ç—å—Ç–µ—Å—å –æ –∫–æ–º—Ñ–æ—Ä—Ç–µ"
            },
            'Mercury': {
                'focus': "–æ–±—â–µ–Ω–∏–µ, –æ–±—É—á–µ–Ω–∏–µ, –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
                'action': "—É—á–∏—Ç–µ—Å—å, –¥–æ–≥–æ–≤–∞—Ä–∏–≤–∞–π—Ç–µ—Å—å, –ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ"
            },
            'Venus': {
                'focus': "–æ—Ç–Ω–æ—à–µ–Ω–∏—è, –∫—Ä–∞—Å–æ—Ç–∞, —Ñ–∏–Ω–∞–Ω—Å—ã",
                'action': "—É–∫—Ä–µ–ø–ª—è–π—Ç–µ —Å–≤—è–∑–∏, —Å–æ–∑–¥–∞–≤–∞–π—Ç–µ –≥–∞—Ä–º–æ–Ω–∏—é"
            },
            'Mars': {
                'focus': "–¥–µ–π—Å—Ç–≤–∏—è, —ç–Ω–µ—Ä–≥–∏—è, –∫–æ–Ω–∫—É—Ä–µ–Ω—Ü–∏—è",
                'action': "–±—É–¥—å—Ç–µ –∞–∫—Ç–∏–≤–Ω—ã, —Ä–µ—à–∞–π—Ç–µ –∑–∞–¥–∞—á–∏"
            },
            'Jupiter': {
                'focus': "—Ä–æ—Å—Ç, –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏, –ø—É—Ç–µ—à–µ—Å—Ç–≤–∏—è",
                'action': "—Ä–∞—Å—à–∏—Ä—è–π—Ç–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç—ã, —É—á–∏—Ç–µ—Å—å –Ω–æ–≤–æ–º—É"
            },
            'Saturn': {
                'focus': "–æ—Ç–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ—Å—Ç—å, —Å—Ç—Ä—É–∫—Ç—É—Ä–∞, –¥–∏—Å—Ü–∏–ø–ª–∏–Ω–∞",
                'action': "–ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ, –æ—Ä–≥–∞–Ω–∏–∑—É–π—Ç–µ, –∑–∞–≤–µ—Ä—à–∞–π—Ç–µ –¥–µ–ª–∞"
            },
            'Uranus': {
                'focus': "–∏–∑–º–µ–Ω–µ–Ω–∏—è, –∏–Ω–Ω–æ–≤–∞—Ü–∏–∏, —Å–≤–æ–±–æ–¥–∞",
                'action': "–±—É–¥—å—Ç–µ –≥–∏–±–∫–∏–º–∏, —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∏—Ä—É–π—Ç–µ"
            },
            'Neptune': {
                'focus': "–∏–Ω—Ç—É–∏—Ü–∏—è, —Ç–≤–æ—Ä—á–µ—Å—Ç–≤–æ, –¥—É—Ö–æ–≤–Ω–æ—Å—Ç—å",
                'action': "–º–µ—á—Ç–∞–π—Ç–µ, —Ç–≤–æ—Ä–∏—Ç–µ, –¥–æ–≤–µ—Ä—è–π—Ç–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–º—É –≥–æ–ª–æ—Å—É"
            },
            'Pluto': {
                'focus': "—Ç—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è, –≥–ª—É–±–∏–Ω–∞, –≤–ª–∞—Å—Ç—å",
                'action': "–∏–∑–±–∞–≤–ª—è–π—Ç–µ—Å—å –æ—Ç —Å—Ç–∞—Ä–æ–≥–æ, –æ–±–Ω–æ–≤–ª—è–π—Ç–µ—Å—å"
            }
        }

        # –†—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ø–ª–∞–Ω–µ—Ç
        self.planet_names_ru = {
            'Sun': '–°–æ–ª–Ω—Ü–∞', 'Moon': '–õ—É–Ω—ã', 'Mercury': '–ú–µ—Ä–∫—É—Ä–∏—è',
            'Venus': '–í–µ–Ω–µ—Ä—ã', 'Mars': '–ú–∞—Ä—Å–∞', 'Jupiter': '–Æ–ø–∏—Ç–µ—Ä–∞',
            'Saturn': '–°–∞—Ç—É—Ä–Ω–∞', 'Uranus': '–£—Ä–∞–Ω–∞', 'Neptune': '–ù–µ–ø—Ç—É–Ω–∞',
            'Pluto': '–ü–ª—É—Ç–æ–Ω–∞', 'North_Node': '–°–µ–≤–µ—Ä–Ω–æ–≥–æ –£–∑–ª–∞',
            'Ascendant': '–ê—Å—Ü–µ–Ω–¥–µ–Ω—Ç–∞', 'Midheaven': '–°–µ—Ä–µ–¥–∏–Ω—ã –ù–µ–±–∞'
        }

    def generate_aspect_recommendations(self, aspects_data: List[Dict]) -> List[str]:
        """
        –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–æ—Å—Ç—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞—Å–ø–µ–∫—Ç–æ–≤
        """
        recommendations = []

        try:
            # –°–æ—Ä—Ç–∏—Ä—É–µ–º –∞—Å–ø–µ–∫—Ç—ã –ø–æ —Å–∏–ª–µ (—Å–∞–º—ã–µ —Å–∏–ª—å–Ω—ã–µ –ø–µ—Ä–≤—ã–µ)
            strong_aspects = [a for a in aspects_data if a.get('strength', 0) > 0.7]
            sorted_aspects = sorted(strong_aspects, key=lambda x: x.get('strength', 0), reverse=True)

            # –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ —Ç–æ–ø-3 —Å–∞–º—ã—Ö —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–∞
            for aspect in sorted_aspects[:3]:
                rec = self._generate_single_aspect_recommendation(aspect)
                if rec:
                    recommendations.append(rec)

            # –ï—Å–ª–∏ —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ –º–∞–ª–æ, –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
            if len(recommendations) < 2:
                general_recs = self._get_general_recommendations(aspects_data)
                recommendations.extend(general_recs[:2])

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –∞—Å–ø–µ–∫—Ç–æ–≤: {e}")
            recommendations = ["–°–µ–≥–æ–¥–Ω—è —Å—Ç–∞–±–∏–ª—å–Ω—ã–π –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ñ–æ–Ω - —Ö–æ—Ä–æ—à–µ–µ –≤—Ä–µ–º—è –¥–ª—è –ø–ª–∞–Ω–æ–≤—ã—Ö –¥–µ–ª"]

        return recommendations

    def _generate_single_aspect_recommendation(self, aspect: Dict) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –æ–¥–Ω–æ–≥–æ –∞—Å–ø–µ–∫—Ç–∞"""
        try:
            transit_planet = aspect.get('transit_planet', '')
            natal_planet = aspect.get('natal_planet', '')
            aspect_type = aspect.get('aspect', '')
            strength = aspect.get('strength', 0)

            if not all([transit_planet, natal_planet, aspect_type]):
                return None

            # –ü–æ–ª—É—á–∞–µ–º —Ä—É—Å—Å–∫–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –ø–ª–∞–Ω–µ—Ç
            transit_ru = self.planet_names_ru.get(transit_planet, transit_planet)
            natal_ru = self.planet_names_ru.get(natal_planet, natal_planet)

            # –í—ã–±–∏—Ä–∞–µ–º —Ç–∏–ø —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ (–ø–æ–∑–∏—Ç–∏–≤–Ω–∞—è –∏–ª–∏ –≤—ã–∑–æ–≤)
            rec_type = 'positive' if strength > 0.8 else 'challenge'

            # –ü–æ–ª—É—á–∞–µ–º —à–∞–±–ª–æ–Ω—ã –¥–ª—è —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –∞—Å–ø–µ–∫—Ç–∞
            templates = self.aspect_templates.get(aspect_type, {}).get(rec_type, [])

            if templates:
                template = random.choice(templates)
                recommendation = template.format(transit=transit_ru, natal=natal_ru)

                # –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –∞—Å–ø–µ–∫—Ç–∞
                emoji_map = {
                    'conjunction': '‚ö°', 'opposition': '‚öñÔ∏è',
                    'square': 'üéØ', 'trine': 'üåü', 'sextile': 'üí´'
                }
                emoji = emoji_map.get(aspect_type, '‚ú®')

                return f"{emoji} {recommendation}"

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –∞—Å–ø–µ–∫—Ç–∞: {e}")

        return None

    def _get_general_recommendations(self, aspects_data: List[Dict]) -> List[str]:
        """–û–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–±—â–µ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –∞—Å–ø–µ–∫—Ç–æ–≤"""
        general_recs = []

        try:
            total_aspects = len(aspects_data)
            strong_aspects = len([a for a in aspects_data if a.get('strength', 0) > 0.7])

            # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –∞—Å–ø–µ–∫—Ç–æ–≤
            if total_aspects == 0:
                general_recs.append("üåô –°–µ–≥–æ–¥–Ω—è —Å–ø–æ–∫–æ–π–Ω—ã–π –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–π —Ñ–æ–Ω - —Ö–æ—Ä–æ—à–µ–µ –≤—Ä–µ–º—è –¥–ª—è –æ—Ç–¥—ã—Ö–∞ –∏ —Ä—É—Ç–∏–Ω–Ω—ã—Ö –¥–µ–ª")
            elif total_aspects <= 3:
                general_recs.append("‚öñÔ∏è –ù–µ–±–æ–ª—å—à–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞—Å–ø–µ–∫—Ç–æ–≤ - –¥–µ–Ω—å –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è —Ä–∞–∑–º–µ—Ä–µ–Ω–Ω–æ–π —Ä–∞–±–æ—Ç—ã")
            elif total_aspects > 8:
                general_recs.append("üéØ –ú–Ω–æ–≥–æ –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –≤–ª–∏—è–Ω–∏–π - –±—É–¥—å—Ç–µ –≥–æ—Ç–æ–≤—ã –∫ —Ä–∞–∑–Ω—ã–º —Å–æ–±—ã—Ç–∏—è–º")

            # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Å–∏–ª–µ –∞—Å–ø–µ–∫—Ç–æ–≤
            if strong_aspects >= 3:
                general_recs.append("üí• –ù–µ—Å–∫–æ–ª—å–∫–æ —Å–∏–ª—å–Ω—ã—Ö –∞—Å–ø–µ–∫—Ç–æ–≤ - –≤–∞–∂–Ω—ã–π –¥–µ–Ω—å –¥–ª—è —Ä–µ—à–µ–Ω–∏–π –∏ –¥–µ–π—Å—Ç–≤–∏–π")
            elif strong_aspects == 0 and total_aspects > 0:
                general_recs.append("üåä –ê—Å–ø–µ–∫—Ç—ã —Å–ª–∞–±—ã–µ - —Ö–æ—Ä–æ—à–µ–µ –≤—Ä–µ–º—è –¥–ª—è –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∏ –∏ –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è")

            # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Ä–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω—ã–º –ø–ª–∞–Ω–µ—Ç–∞–º
            retrograde_planets = self._detect_retrograde_influences(aspects_data)
            if retrograde_planets:
                planet_names = [self.planet_names_ru.get(p, p) for p in retrograde_planets]
                general_recs.append(
                    f"üîÑ –í–ª–∏—è–Ω–∏–µ —Ä–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω—ã—Ö –ø–ª–∞–Ω–µ—Ç ({', '.join(planet_names)}) - –≤—Ä–µ–º—è –¥–ª—è –ø–µ—Ä–µ—Å–º–æ—Ç—Ä–∞ –∏ –∞–Ω–∞–ª–∏–∑–∞")

        except Exception as e:
            logger.warning(f"‚ö†Ô∏è –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –æ–±—â–∏—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π: {e}")

        return general_recs

    def _detect_retrograde_influences(self, aspects_data: List[Dict]) -> List[str]:
        """–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ —Ä–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω—ã—Ö –≤–ª–∏—è–Ω–∏–π –≤ –∞—Å–ø–µ–∫—Ç–∞—Ö"""
        retrograde_planets = set()

        for aspect in aspects_data:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç—Ä–∞–Ω–∑–∏—Ç–Ω—ã–µ –ø–ª–∞–Ω–µ—Ç—ã –Ω–∞ —Ä–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω–æ—Å—Ç—å
            if aspect.get('transit_planet') in ['Mercury', 'Venus', 'Mars', 'Jupiter', 'Saturn', 'Uranus', 'Neptune',
                                                'Pluto']:
                # –í —Ä–µ–∞–ª—å–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ –∑–¥–µ—Å—å –±—ã–ª–∞ –±—ã –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Ä–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω–æ—Å—Ç—å
                # –°–µ–π—á–∞—Å –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª—É—á–∞–π–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏
                if random.random() < 0.3:  # 30% —à–∞–Ω—Å —á—Ç–æ –ø–ª–∞–Ω–µ—Ç–∞ —Ä–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω–∞—è
                    retrograde_planets.add(aspect['transit_planet'])

        return list(retrograde_planets)


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –¥–≤–∏–∂–∫–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
aspect_recommendations = AspectRecommendationEngine()


recommendation_service.py

import logging
import hashlib
import json
from datetime import date, datetime, timedelta
from typing import Dict, Any, Optional

from backend.database import async_session, AIRecommendations
from sqlalchemy.future import select
from sqlalchemy import and_

logger = logging.getLogger(__name__)


class RecommendationService:
    """
    –£–ø—Ä–æ—â–µ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏ –∏ –∫—ç—à–µ–º
    –û–±—ä–µ–¥–∏–Ω—è–µ—Ç –ª–æ–≥–∏–∫—É –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è –∏ —Ä–∞–±–æ—Ç—ã —Å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏
    """

    def __init__(self):
        self.cache_ttl_days = 1  # –ö—ç—à–∏—Ä—É–µ–º –Ω–∞ 1 –¥–µ–Ω—å

    def _generate_data_hash(self, data: Dict[str, Any]) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ö—ç—à–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏—è"""
        data_str = json.dumps(data, sort_keys=True, ensure_ascii=False)
        return hashlib.sha256(data_str.encode()).hexdigest()

    async def get_cached_recommendations(self, telegram_id: int, target_date: date, data_hash: str) -> Optional[
        Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        try:
            async with async_session() as session:
                result = await session.execute(
                    select(AIRecommendations).where(
                        and_(
                            AIRecommendations.telegram_id == telegram_id,
                            AIRecommendations.target_date == target_date,
                            AIRecommendations.data_hash == data_hash
                        )
                    )
                )
                cached = result.scalar_one_or_none()

                if cached:
                    logger.info(f"‚úÖ –ù–∞–π–¥–µ–Ω—ã –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è {telegram_id} –Ω–∞ {target_date}")
                    return {
                        'recommendations': cached.recommendations,
                        'model_version': cached.model_version,
                        'from_cache': True
                    }

                return None

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—ç—à–∞ –¥–ª—è {telegram_id}: {e}")
            return None

    async def save_recommendations(self, telegram_id: int, target_date: date, data_hash: str,
                                   recommendations: str, model_version: str = 'gemma:2b') -> bool:
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –≤ –∫—ç—à"""
        try:
            async with async_session() as session:
                # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è —ç—Ç–æ–π –¥–∞—Ç—ã
                await session.execute(
                    AIRecommendations.__table__.delete().where(
                        and_(
                            AIRecommendations.telegram_id == telegram_id,
                            AIRecommendations.target_date == target_date
                        )
                    )
                )

                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –Ω–æ–≤—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
                new_recommendation = AIRecommendations(
                    telegram_id=telegram_id,
                    target_date=target_date,
                    data_hash=data_hash,
                    recommendations=recommendations,
                    model_version=model_version,
                    created_at=datetime.now()
                )

                session.add(new_recommendation)
                await session.commit()

                logger.info(f"üíæ –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –∫—ç—à –¥–ª—è {telegram_id} –Ω–∞ {target_date}")
                return True

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –¥–ª—è {telegram_id}: {e}")
            return False

    async def cleanup_old_recommendations(self, days_old: int = 7) -> int:
        """–û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π"""
        try:
            cutoff_date = date.today() - timedelta(days=days_old)

            async with async_session() as session:
                result = await session.execute(
                    AIRecommendations.__table__.delete().where(
                        AIRecommendations.target_date < cutoff_date
                    )
                )
                deleted_count = result.rowcount
                await session.commit()

                if deleted_count > 0:
                    logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {deleted_count} —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π")

                return deleted_count

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π: {e}")
            return 0


# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
recommendation_service = RecommendationService()


