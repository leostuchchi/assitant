–ø—Ä–æ–µ–∫—Ç personal_assistant

–∏—Ç–æ–≥–æ–≤–∞—è –∑–∞–¥–∞—á–∞ –ø—Ä–æ–µ–∫—Ç–∞: 
–ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ —Ä–∞—Å—á–µ—Ç–∞—Ö –∏ –¥–∞–Ω–Ω—ã—Ö, —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–∏ —á–µ–ª–æ–≤–µ–∫—É –Ω–∞ –æ–¥–∏–Ω –¥–µ–Ω—å. –¥–ª—è —Ä–∞–∑–≤–∏—Ç–∏—è, —Å–∞–º–æ—Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —á–µ–ª–æ–≤–µ–∫–∞ –Ω–∞ –±–∞–∑–µ –º–æ–¥–µ–ª–∏ –ò–ò.

—Ç–µ–∫—É—â–∞—è –∑–∞–¥–∞—á–∞ –ø—Ä–æ–µ–∫—Ç–∞: 
—Å–±–æ—Ä, –ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –¥–∞–Ω–Ω—ã—Ö, –ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö, –æ–±–æ—Å–Ω–æ–≤–∞–Ω–Ω—ã—Ö, –∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Ä–∞—Å—á–µ—Ç–æ–≤. –∫–æ—Ç–æ—Ä—ã–µ –ø–æ—Ç—Ä–µ–±—É—é—Ç—Å—è –¥–ª—è –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–ª–Ω—ã—Ö, –ø–æ–ª–µ–∑–Ω—ã—Ö, —Å—Ç—Ä–æ–≥–æ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–π. –∏—Ç–æ–≥–æ–≤—ã–µ —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–∏ –≤–ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏–∏ –±—É–¥—É—Ç –≥–æ—Ç–æ–≤–∏—Ç—Å—è –º–æ–¥–µ–ª—å—é. 

–ª–æ–≥–∏–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞:
—Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (tegram bot)
–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã
–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã
—Ä–∞—Å—á–µ—Ç –±–∏–æ—Ä–∏—Ç–º–æ–≤
–ø–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ–¥–∏–Ω –¥–µ–Ω—å, –Ω–∞ –æ—Å–Ω–æ–≤–µ: –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã, –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã, –±–∏–æ—Ä–∏—Ç–º–æ–≤
 –ø–æ–∑–∂–µ –±—É–¥—É—Ç –¥–æ–±–∞–≤–ª–µ–Ω—ã —Ä–∞—Å—á–µ—Ç—ã –∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫ —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏—è–º –ª—É–Ω–Ω—ã—Ö —Ñ–∞–∑
–ø–µ—Ä–µ–¥–∞—á–∞ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è –ò–ò –¥–∞–Ω–Ω—ã—Ö –≤ –º–æ–¥—É–ª—å assistant (–≤—Å–µ —Å–æ–±—Ä–∞–Ω–Ω—ã–µ –∏ —Ä–∞—Å—á–∏—Ç–∞–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)
 –ø–æ–∑–∂–µ –±—É–¥–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ –º–æ–¥–µ–ª—å –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–π
–≤—ã–≤–æ–¥ —Ä–µ–∫–æ–º–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ–¥–∏–Ω –¥–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é (telegram bot)

—Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ personal_assistant:

docker-compose.yml

bot: 
config.py
handlers.py
__init__.py
main.py

backend: 
__init__.py
assistant.py
biorhythm_calculator.py
biorhythm_services.py
chart_services.py
database.py
db_connection.py
matrix_services.py
moon.py
natal_chart.py
predictions.py
prediction_services.py
psyho_matrix.py
user_services.py

data_base p_assistant_bd: postges


-- –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
-- –°–æ–∑–¥–∞–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–Ω–æ–π —Ç–∞–±–ª–∏—Ü—ã users —Å –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å—é
CREATE TABLE IF NOT EXISTS users (
    telegram_id BIGINT PRIMARY KEY,
    birth_date DATE NOT NULL,
    birth_time TIME NOT NULL,
    birth_city VARCHAR(100) NOT NULL,
    profession VARCHAR(100),
    job_position VARCHAR(100),
    current_city VARCHAR(100),
    -- –ù–æ–≤—ã–µ –ø–æ–ª—è —Å –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏

-- –û–±–Ω–æ–≤–ª—è–µ–º —Ç–∞–±–ª–∏—Ü—É –Ω–∞—Ç–∞–ª—å–Ω—ã—Ö –∫–∞—Ä—Ç
CREATE TABLE user_natal_charts (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    natal_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü (–Ω—É–º–µ—Ä–æ–ª–æ–≥–∏—è)
CREATE TABLE psyho_matrix (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    matrix_data JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –¢–∞–±–ª–∏—Ü–∞ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å)
CREATE TABLE natal_predictions (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    predictions JSONB NOT NULL,
    assistant_data JSONB NOT NULL DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã
CREATE INDEX idx_users_telegram_id ON users(telegram_id);
CREATE INDEX idx_users_birth_date ON users(birth_date);
CREATE INDEX idx_user_natal_charts_telegram_id ON user_natal_charts(telegram_id);
CREATE INDEX idx_psyho_matrix_telegram_id ON psyho_matrix(telegram_id);
CREATE INDEX idx_natal_predictions_telegram_id ON natal_predictions(telegram_id);

-- –î–∞–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO pers_assist;

select * from psyho_matrix


-- –¢–∞–±–ª–∏—Ü–∞ –¥–ª—è –±–∏–æ—Ä–∏—Ç–º–æ–≤
CREATE TABLE biorhythms (
    telegram_id BIGINT PRIMARY KEY REFERENCES users(telegram_id) ON DELETE CASCADE,
    biorhythm_data JSONB NOT NULL,
    calculation_date DATE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- –ò–Ω–¥–µ–∫—Å –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –ø–æ–∏—Å–∫–∞
CREATE INDEX idx_biorhythms_telegram_id ON biorhythms(telegram_id);
CREATE INDEX idx_biorhythms_calculation_date ON biorhythms(calculation_date);

docker-compose.yml:
version: '3.8'

services:
  postgres:
    image: postgres:16
    container_name: postgres_astrology
    environment:
      POSTGRES_DB: p_assistant_bd
      POSTGRES_USER: pers_assist
      POSTGRES_PASSWORD: astra123  # –ü—Ä–æ—Å—Ç–æ–π –ø–∞—Ä–æ–ª—å –±–µ–∑ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U pers_assist -d p_assistant_bd"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
  
–º–æ–¥—É–ª–∏ –ø—Ä–æ–µ–∫—Ç–∞:

bot: 

config.py:

import os
from dotenv import load_dotenv

load_dotenv()

TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

handlers.py:

from aiogram import Router, types
from aiogram.filters import Command, StateFilter
from aiogram.fsm.state import State, StatesGroup
from aiogram.fsm.context import FSMContext
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from datetime import datetime, date, timedelta
import logging

from backend.assistant import assistant

logger = logging.getLogger(__name__)

# –°–æ–∑–¥–∞–µ–º —Ä–æ—É—Ç–µ—Ä
router = Router()


# –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è –¥–ª—è —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö
class DataCollectionStates(StatesGroup):
    waiting_for_birth_date = State()
    waiting_for_birth_time = State()
    waiting_for_birth_city = State()
    waiting_for_current_city = State()
    waiting_for_profession = State()
    waiting_for_job_position = State()
    waiting_for_gender = State()  # –ù–û–í–û–ï –°–û–°–¢–û–Ø–ù–ò–ï


# –°–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –≤–≤–æ–¥–∞ –¥–∞—Ç—ã
class DateSelectionStates(StatesGroup):
    waiting_for_custom_date = State()


# –û—Å–Ω–æ–≤–Ω–∞—è –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞
def get_main_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã")],
            [KeyboardButton(text="üìÖ –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")],
        ],
        resize_keyboard=True
    )


# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –¥–∞—Ç—ã
def get_date_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üìÖ –°–µ–≥–æ–¥–Ω—è"), KeyboardButton(text="üìÖ –ó–∞–≤—Ç—Ä–∞")],
            [KeyboardButton(text="üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É")],
            [KeyboardButton(text="üîô –ù–∞–∑–∞–¥")]
        ],
        resize_keyboard=True
    )


# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è –≤—ã–±–æ—Ä–∞ –ø–æ–ª–∞
def get_gender_keyboard():
    return ReplyKeyboardMarkup(
        keyboard=[
            [KeyboardButton(text="üë® –ú—É–∂—Å–∫–æ–π"), KeyboardButton(text="üë© –ñ–µ–Ω—Å–∫–∏–π")],
            [KeyboardButton(text="ü§∑ –ù–µ —É–∫–∞–∑—ã–≤–∞—Ç—å")]
        ],
        resize_keyboard=True
    )


@router.message(Command("start"))
async def cmd_start(message: types.Message):
    """–ö–æ–º–∞–Ω–¥–∞ –Ω–∞—á–∞–ª–∞ —Ä–∞–±–æ—Ç—ã —Å –±–æ—Ç–æ–º"""
    welcome_text = """
üëã –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –≤–∞—à –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç!

–Ø –ø–æ–º–æ–≥—É –≤–∞–º –ø–æ–ª—É—á–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ:
‚Ä¢ üåü –ù–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –∏ –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —Ç—Ä–∞–Ω–∑–∏—Ç–æ–≤
‚Ä¢ üî¢ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ø–æ –¥–∞—Ç–µ —Ä–æ–∂–¥–µ–Ω–∏—è  
‚Ä¢ ‚ö° –ë–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –∫–∞–∂–¥—ã–π –¥–µ–Ω—å
‚Ä¢ üíº –í–∞—à–µ–π –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –¥–µ—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:
    """

    await message.answer(welcome_text, reply_markup=get_main_keyboard())


@router.message(lambda message: message.text == "üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã")
async def start_data_collection(message: types.Message, state: FSMContext):
    """–ù–∞—á–∞–ª–æ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    status = await assistant.get_user_data_status(message.from_user.id)

    if status['is_complete']:
        await message.answer(
            "‚úÖ –í–∞—à–∏ –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —É–∂–µ —Å–æ–±—Ä–∞–Ω—ã!\n"
            "–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –æ–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Ñ–µ—Å—Å–∏—é –∏–ª–∏ –≥–æ—Ä–æ–¥, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â—É—é –∫–æ–º–∞–Ω–¥—É.",
            reply_markup=get_main_keyboard()
        )
    else:
        await message.answer(
            "üìä –ù–∞—á–Ω–µ–º —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö!\n\n"
            "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à—É –¥–∞—Ç—É —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î:",
            reply_markup=types.ReplyKeyboardRemove()
        )
        await state.set_state(DataCollectionStates.waiting_for_birth_date)


@router.message(DataCollectionStates.waiting_for_birth_date)
async def process_birth_date(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è"""
    try:
        birth_date = datetime.strptime(message.text, "%Y-%m-%d").date()
        await state.update_data(birth_date=birth_date)

        await message.answer(
            "‚úÖ –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n"
            "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤—Ä–µ–º—è —Ä–æ–∂–¥–µ–Ω–∏—è –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ß–ß:–ú–ú (24 —á–∞—Å–∞):"
        )
        await state.set_state(DataCollectionStates.waiting_for_birth_time)

    except ValueError:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –ì–ì–ì–ì-–ú–ú-–î–î:")


@router.message(DataCollectionStates.waiting_for_birth_time)
async def process_birth_time(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ —Ä–æ–∂–¥–µ–Ω–∏—è"""
    try:
        birth_time = datetime.strptime(message.text, "%H:%M").time()
        await state.update_data(birth_time=birth_time)

        await message.answer(
            "‚úÖ –í—Ä–µ–º—è —Ä–æ–∂–¥–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ!\n\n"
            "–í–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ —Ä–æ–∂–¥–µ–Ω–∏—è:"
        )
        await state.set_state(DataCollectionStates.waiting_for_birth_city)

    except ValueError:
        await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –≤—Ä–µ–º–µ–Ω–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç –ß–ß:–ú–ú:")


@router.message(DataCollectionStates.waiting_for_birth_city)
async def process_birth_city(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ—Ä–æ–¥–∞ —Ä–æ–∂–¥–µ–Ω–∏—è"""
    birth_city = message.text.strip()
    await state.update_data(birth_city=birth_city)

    await message.answer(
        "‚úÖ –ì–æ—Ä–æ–¥ —Ä–æ–∂–¥–µ–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n"
        "–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≥–æ—Ä–æ–¥ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è:"
    )
    await state.set_state(DataCollectionStates.waiting_for_current_city)


@router.message(DataCollectionStates.waiting_for_current_city)
async def process_current_city(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≥–æ—Ä–æ–¥–∞ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è"""
    current_city = message.text.strip()
    await state.update_data(current_city=current_city)

    await message.answer(
        "‚úÖ –ì–æ—Ä–æ–¥ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à—É —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ—Å—Ç—å –∏–ª–∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏—é:"
    )
    await state.set_state(DataCollectionStates.waiting_for_profession)


@router.message(DataCollectionStates.waiting_for_profession)
async def process_profession(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏"""
    profession = message.text.strip()
    await state.update_data(profession=profession)

    await message.answer(
        "‚úÖ –ü—Ä–æ—Ñ–µ—Å—Å–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –≤–∞—à—É –¥–æ–ª–∂–Ω–æ—Å—Ç—å (–µ—Å–ª–∏ –Ω–µ—Ç - –Ω–∞–ø–∏—à–∏—Ç–µ '–Ω–µ—Ç'):"
    )
    await state.set_state(DataCollectionStates.waiting_for_job_position)


@router.message(DataCollectionStates.waiting_for_job_position)
async def process_job_position(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–æ–ª–∂–Ω–æ—Å—Ç–∏ –∏ –ø–µ—Ä–µ—Ö–æ–¥ –∫ –≤—ã–±–æ—Ä—É –ø–æ–ª–∞"""
    job_position = message.text.strip()
    if job_position.lower() == '–Ω–µ—Ç':
        job_position = None

    await state.update_data(job_position=job_position)

    await message.answer(
        "‚úÖ –î–æ–ª–∂–Ω–æ—Å—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n\n"
        "–£–∫–∞–∂–∏—Ç–µ –≤–∞—à –ø–æ–ª:",
        reply_markup=get_gender_keyboard()
    )
    await state.set_state(DataCollectionStates.waiting_for_gender)


@router.message(DataCollectionStates.waiting_for_gender)
async def process_gender(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–ª–∞ –∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö"""
    gender_map = {
        "üë® –º—É–∂—Å–∫–æ–π": "male",
        "üë© –∂–µ–Ω—Å–∫–∏–π": "female",
        "ü§∑ –Ω–µ —É–∫–∞–∑—ã–≤–∞—Ç—å": None
    }

    gender_text = message.text.lower()
    gender = None

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–æ–ª –ø–æ —Ç–µ–∫—Å—Ç—É
    for key, value in gender_map.items():
        if key in gender_text:
            gender = value
            break

    # –ï—Å–ª–∏ –ø–æ–ª –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω, –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–µ–∫—Å—Ç –∫–∞–∫ –µ—Å—Ç—å
    if gender is None:
        if any(word in gender_text for word in ["–º—É–∂", "male", "–º"]):
            gender = "male"
        elif any(word in gender_text for word in ["–∂–µ–Ω", "female", "–∂"]):
            gender = "female"
        else:
            gender = None

    await state.update_data(gender=gender)
    user_data = await state.get_data()

    try:
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ –¥–∞–Ω–Ω—ã–µ —á–µ—Ä–µ–∑ –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞
        result = await assistant.collect_user_data(
            telegram_id=message.from_user.id,
            birth_date=user_data['birth_date'],
            birth_time=user_data['birth_time'],
            birth_city=user_data['birth_city'],
            current_city=user_data['current_city'],
            profession=user_data['profession'],
            job_position=user_data.get('job_position'),
            gender=gender  # –ü–ï–†–ï–î–ê–ï–ú –ü–û–õ
        )

        if result['success']:
            await message.answer(
                "üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–±—Ä–∞–Ω—ã!\n\n"
                "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:",
                reply_markup=get_main_keyboard()
            )
        else:
            await message.answer(
                f"‚ùå {result['message']}\n\n"
                "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∑–∞–Ω–æ–≤–æ.",
                reply_markup=get_main_keyboard()
            )

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö: {e}")
        await message.answer(
            f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö: {str(e)}\n\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–∞—á–∞—Ç—å —Å–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∑–∞–Ω–æ–≤–æ.",
            reply_markup=get_main_keyboard()
        )

    await state.clear()


@router.message(lambda message: message.text == "üìÖ –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ")
async def select_date_option(message: types.Message):
    """–í—ã–±–æ—Ä –¥–∞—Ç—ã –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö"""
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –¥–∞–Ω–Ω—ã—Ö
    status = await assistant.get_user_data_status(message.from_user.id)
    if not status['is_complete']:
        await message.answer(
            "‚ùå –°–Ω–∞—á–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–æ–±—Ä–∞—Ç—å –¥–∞–Ω–Ω—ã–µ!\n"
            "–ù–∞–∂–º–∏—Ç–µ 'üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã'",
            reply_markup=get_main_keyboard()
        )
        return

    await message.answer(
        "üìÖ –í—ã–±–µ—Ä–∏—Ç–µ –¥–∞—Ç—É –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤:",
        reply_markup=get_date_keyboard()
    )


@router.message(lambda message: message.text == "üìÖ –°–µ–≥–æ–¥–Ω—è")
async def get_todays_data(message: types.Message):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è"""
    await process_date_selection(message, date.today())


@router.message(lambda message: message.text == "üìÖ –ó–∞–≤—Ç—Ä–∞")
async def get_tomorrows_data(message: types.Message):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –∑–∞–≤—Ç—Ä–∞"""
    tomorrow = date.today() + timedelta(days=1)
    await process_date_selection(message, tomorrow)


@router.message(lambda message: message.text == "üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É")
async def request_custom_date(message: types.Message, state: FSMContext):
    """–ó–∞–ø—Ä–æ—Å –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π –¥–∞—Ç—ã"""
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ –¥–∞—Ç—É –≤ —Ñ–æ—Ä–º–∞—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î:",
        reply_markup=types.ReplyKeyboardRemove()
    )
    await state.set_state(DateSelectionStates.waiting_for_custom_date)


@router.message(DateSelectionStates.waiting_for_custom_date)
async def process_custom_date(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–µ–¥–µ–Ω–Ω–æ–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º –¥–∞—Ç—ã"""
    try:
        target_date = datetime.strptime(message.text, "%Y-%m-%d").date()

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –¥–∞—Ç–∞ –Ω–µ –≤ –ø—Ä–æ—à–ª–æ–º
        if target_date < date.today():
            await message.answer(
                "‚ùå –ú–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ç–æ–ª—å–∫–æ –Ω–∞ —Å–µ–≥–æ–¥–Ω—è –∏–ª–∏ –±—É–¥—É—â–∏–µ –¥–∞—Ç—ã",
                reply_markup=get_date_keyboard()
            )
            return

        await process_date_selection(message, target_date)

    except ValueError:
        await message.answer(
            "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞—Ç—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ì–ì–ì–ì-–ú–ú-–î–î",
            reply_markup=get_date_keyboard()
        )

    await state.clear()


@router.message(lambda message: message.text == "üîô –ù–∞–∑–∞–¥")
async def go_back_to_main(message: types.Message):
    """–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
    await message.answer(
        "–í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
        reply_markup=get_main_keyboard()
    )


async def process_date_selection(message: types.Message, target_date: date):
    """–û–±—â–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –¥–∞—Ç—ã"""
    processing_msg = await message.answer(f"üîÑ –§–æ—Ä–º–∏—Ä—É—é –¥–∞–Ω–Ω—ã–µ –Ω–∞ {target_date.strftime('%d.%m.%Y')}...")

    try:
        result = await assistant.get_recommendations(message.from_user.id, target_date)

        if result['success']:
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            await message.answer(result['user_data'], parse_mode="Markdown")

            # –î–∞–Ω–Ω—ã–µ –¥–ª—è –º–æ–¥–µ–ª–∏ —É–∂–µ –≤—ã–≤–æ–¥—è—Ç—Å—è —á–µ—Ä–µ–∑ print –≤ assistant.py
            await message.answer(
                f"ü§ñ *–î–∞–Ω–Ω—ã–µ –Ω–∞ {target_date.strftime('%d.%m.%Y')} –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω—ã –≤ AI –º–æ–¥–µ–ª—å*\n"
                "–†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—É–¥—É—Ç –¥–æ—Å—Ç—É–ø–Ω—ã –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è!",
                parse_mode="Markdown",
                reply_markup=get_main_keyboard()
            )
        else:
            await message.answer(
                result['message'],
                reply_markup=get_main_keyboard()
            )

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è: {e}")
        await message.answer(
            "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö\n"
            "–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –≤ –ø–æ–¥–¥–µ—Ä–∂–∫—É.",
            reply_markup=get_main_keyboard()
        )

    await processing_msg.delete()


@router.message(Command("status"))
async def cmd_status(message: types.Message):
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        status = await assistant.get_user_data_status(message.from_user.id)

        status_text = "üìä **–°—Ç–∞—Ç—É—Å –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö:**\n\n"

        if status['is_complete']:
            status_text += "‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é\n\n"
        else:
            status_text += "‚ùå –ù–µ –≤—Å–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–±—Ä–∞–Ω—ã\n\n"

        status_text += f"‚Ä¢ –û—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: {'‚úÖ' if status['has_basic_data'] else '‚ùå'}\n"
        status_text += f"‚Ä¢ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞: {'‚úÖ' if status['has_natal_chart'] else '‚ùå'}\n"
        status_text += f"‚Ä¢ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞: {'‚úÖ' if status['has_psyho_matrix'] else '‚ùå'}\n"
        status_text += f"‚Ä¢ –ë–∏–æ—Ä–∏—Ç–º—ã: {'‚úÖ' if status['has_biorhythms'] else '‚ùå'}\n\n"

        if not status['is_complete']:
            status_text += "–ù–∞–∂–º–∏—Ç–µ 'üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã' –¥–ª—è —Å–±–æ—Ä–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö"

        await message.answer(status_text, parse_mode="Markdown")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞: {e}")
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –¥–∞–Ω–Ω—ã—Ö")


@router.message(Command("help"))
async def cmd_help(message: types.Message):
    """–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º –±–æ—Ç–∞"""
    help_text = """
üìã **–î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:**

/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É —Å –±–æ—Ç–æ–º
/status - –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤–∞—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É

**–û—Å–Ω–æ–≤–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è:**

üìä –†–∞—Å—á–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã - –°–æ–±—Ä–∞—Ç—å –∏–ª–∏ –æ–±–Ω–æ–≤–∏—Ç—å –≤–∞—à–∏ –¥–∞–Ω–Ω—ã–µ
üìÖ –ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ - –ü–æ–ª—É—á–∏—Ç—å —Ä–∞—Å—á–µ—Ç—ã –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É

**–í—ã–±–æ—Ä –¥–∞—Ç—ã:**
‚Ä¢ üìÖ –°–µ–≥–æ–¥–Ω—è - –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
‚Ä¢ üìÖ –ó–∞–≤—Ç—Ä–∞ - –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å  
‚Ä¢ üìÖ –í—ã–±—Ä–∞—Ç—å –¥–∞—Ç—É - –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–∞—è –¥–∞—Ç–∞ (–ì–ì–ì–ì-–ú–ú-–î–î)

**–ß—Ç–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è:**
‚Ä¢ –ê—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Ç—Ä–∞–Ω–∑–∏—Ç—ã –∏ –∞—Å–ø–µ–∫—Ç—ã
‚Ä¢ –ë–∏–æ—Ä–∏—Ç–º—ã (—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π, –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π)
‚Ä¢ –ù—É–º–µ—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∞—è –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞
‚Ä¢ –í—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ AI –º–æ–¥–µ–ª—å –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
    """

    await message.answer(help_text, parse_mode="Markdown")


@router.message()
async def handle_other_messages(message: types.Message):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π"""
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –º–µ–Ω—é –Ω–∏–∂–µ:",
        reply_markup=get_main_keyboard()
    )


__init__.py

main.py:

from aiogram import Bot, Dispatcher
import asyncio
import logging

from bot.config import TOKEN
from bot.handlers import router
from backend.db_connection import check_db_connection
import math
from datetime import date, datetime
from typing import Dict, List, Tuple
import logging

logger = logging.getLogger(__name__)


class BiorhythmCalculator:
    """
    –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è.
    –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª—ã.
    """

    def __init__(self):
        # –ü–µ—Ä–∏–æ–¥—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤ –≤ –¥–Ω—è—Ö
        self.PHYSICAL_CYCLE = 23
        self.EMOTIONAL_CYCLE = 28
        self.INTELLECTUAL_CYCLE = 33
        self.INTUITIVE_CYCLE = 38  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª

    def calculate_biorhythms(self, birth_date: date, target_date: date) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –∑–∞–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É

        Args:
            birth_date: –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è
            target_date: –î–∞—Ç–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞

        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤
        """
        try:
            # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            days_lived = (target_date - birth_date).days

            if days_lived < 0:
                raise ValueError("–î–∞—Ç–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è")

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤
            physical = self._calculate_cycle(days_lived, self.PHYSICAL_CYCLE)
            emotional = self._calculate_cycle(days_lived, self.EMOTIONAL_CYCLE)
            intellectual = self._calculate_cycle(days_lived, self.INTELLECTUAL_CYCLE)
            intuitive = self._calculate_cycle(days_lived, self.INTUITIVE_CYCLE)

            # –û–±—â–∏–π –ø–æ–∫–∞–∑–∞—Ç–µ–ª—å —ç–Ω–µ—Ä–≥–∏–∏
            overall_energy = self._calculate_overall_energy(physical, emotional, intellectual, intuitive)

            # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤
            recommendations = self._generate_recommendations(physical, emotional, intellectual, intuitive,
                                                             overall_energy)

            biorhythm_data = {
                'calculation_date': target_date.isoformat(),
                'days_lived': days_lived,
                'cycles': {
                    'physical': physical,
                    'emotional': emotional,
                    'intellectual': intellectual,
                    'intuitive': intuitive
                },
                'overall_energy': overall_energy,
                'recommendations': recommendations,
                'critical_days': self._find_critical_days(physical, emotional, intellectual, target_date),
                'peak_days': self._find_peak_days(physical, emotional, intellectual, target_date)
            }

            logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –¥–ª—è {target_date}, –ø—Ä–æ–∂–∏—Ç–æ –¥–Ω–µ–π: {days_lived}")
            return biorhythm_data

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
            raise

    def _calculate_cycle(self, days_lived: int, cycle_length: int) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –æ–¥–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –±–∏–æ—Ä–∏—Ç–º–∞

        Args:
            days_lived: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            cycle_length: –î–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ –≤ –¥–Ω—è—Ö

        Returns:
            –î–∞–Ω–Ω—ã–µ —Ü–∏–∫–ª–∞
        """
        # –¢–µ–∫—É—â–∞—è —Ñ–∞–∑–∞ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö (2œÄ –∑–∞ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª)
        phase = (2 * math.pi * days_lived) / cycle_length

        # –ó–Ω–∞—á–µ–Ω–∏–µ —Å–∏–Ω—É—Å–æ–∏–¥—ã (-1 –¥–æ +1)
        value = math.sin(phase)

        # –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞ (0% –¥–æ 100%)
        percentage = ((value + 1) / 2) * 100

        # –î–µ–Ω—å –≤ —Ü–∏–∫–ª–µ (0 –¥–æ cycle_length-1)
        day_in_cycle = days_lived % cycle_length

        return {
            'value': round(value, 4),
            'percentage': round(percentage, 2),
            'day_in_cycle': day_in_cycle,
            'phase': self._get_phase_description(value),
            'trend': self._get_trend(phase)
        }

    def _get_phase_description(self, value: float) -> str:
        """–û–ø–∏—Å–∞–Ω–∏–µ —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–∞"""
        if value >= 0.7:
            return "–ø–∏–∫ —ç–Ω–µ—Ä–≥–∏–∏"
        elif value >= 0.3:
            return "–≤—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        elif value >= -0.3:
            return "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è —Ñ–∞–∑–∞"
        elif value >= -0.7:
            return "–Ω–∏–∑–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        else:
            return "–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Ç–æ—á–∫–∞"

    def _get_trend(self, phase: float) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞ (—Ä–∞—Å—Ç–µ—Ç/–ø–∞–¥–∞–µ—Ç)"""
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é (cos(phase))
        derivative = math.cos(phase)

        if derivative > 0.1:
            return "—Ä–∞—Å—Ç–µ—Ç"
        elif derivative < -0.1:
            return "–ø–∞–¥–∞–µ—Ç"
        else:
            return "—Å—Ç–∞–±–∏–ª—å–Ω–æ"

    def _calculate_overall_energy(self, physical: Dict, emotional: Dict, intellectual: Dict, intuitive: Dict) -> Dict:
        """–†–∞—Å—á–µ—Ç –æ–±—â–µ–≥–æ —É—Ä–æ–≤–Ω—è —ç–Ω–µ—Ä–≥–∏–∏"""
        # –í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –≤—Å–µ—Ö —Ü–∏–∫–ª–æ–≤
        total_energy = (
                physical['value'] * 0.3 +  # –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª - 30%
                emotional['value'] * 0.25 +  # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π - 25%
                intellectual['value'] * 0.25 +  # –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π - 25%
                intuitive['value'] * 0.2  # –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π - 20%
        )

        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–æ 0-100%
        energy_percentage = ((total_energy + 1) / 2) * 100

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å —ç–Ω–µ—Ä–≥–∏–∏
        if energy_percentage >= 80:
            level = "–æ—á–µ–Ω—å –≤—ã—Å–æ–∫–∏–π"
            description = "–û—Ç–ª–∏—á–Ω—ã–π –¥–µ–Ω—å –¥–ª—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –¥–µ–π—Å—Ç–≤–∏–π –∏ –≤–∞–∂–Ω—ã—Ö —Ä–µ—à–µ–Ω–∏–π"
        elif energy_percentage >= 60:
            level = "–≤—ã—Å–æ–∫–∏–π"
            description = "–•–æ—Ä–æ—à–∏–π –¥–µ–Ω—å –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–∏–≤–Ω–æ–π —Ä–∞–±–æ—Ç—ã"
        elif energy_percentage >= 40:
            level = "—Å—Ä–µ–¥–Ω–∏–π"
            description = "–°—Ç–∞–±–∏–ª—å–Ω—ã–π –¥–µ–Ω—å, –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è —Ä—É—Ç–∏–Ω–Ω—ã—Ö –∑–∞–¥–∞—á"
        elif energy_percentage >= 20:
            level = "–Ω–∏–∑–∫–∏–π"
            description = "–î–µ–Ω—å –¥–ª—è –æ—Ç–¥—ã—Ö–∞ –∏ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–∏–ª"
        else:
            level = "–æ—á–µ–Ω—å –Ω–∏–∑–∫–∏–π"
            description = "–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –±–µ—Ä–µ—á—å —ç–Ω–µ—Ä–≥–∏—é, –∏–∑–±–µ–≥–∞—Ç—å –Ω–∞–≥—Ä—É–∑–æ–∫"

        return {
            'value': round(total_energy, 4),
            'percentage': round(energy_percentage, 2),
            'level': level,
            'description': description
        }

    def _generate_recommendations(self, physical: Dict, emotional: Dict, intellectual: Dict, intuitive: Dict,
                                  overall: Dict) -> List[str]:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤"""
        recommendations = []

        # –§–∏–∑–∏—á–µ—Å–∫–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if physical['value'] > 0.5:
            recommendations.append("üí™ –ò–¥–µ–∞–ª—å–Ω—ã–π –¥–µ–Ω—å –¥–ª—è —Å–ø–æ—Ä—Ç–∞ –∏ —Ñ–∏–∑–∏—á–µ—Å–∫–æ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏")
        elif physical['value'] < -0.5:
            recommendations.append("üõå –ò–∑–±–µ–≥–∞–π—Ç–µ —Ç—è–∂–µ–ª—ã—Ö —Ñ–∏–∑–∏—á–µ—Å–∫–∏—Ö –Ω–∞–≥—Ä—É–∑–æ–∫")

        # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if emotional['value'] > 0.6:
            recommendations.append("üòä –û—Ç–ª–∏—á–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è –æ–±—â–µ–Ω–∏—è –∏ –Ω–æ–≤—ã—Ö –∑–Ω–∞–∫–æ–º—Å—Ç–≤")
        elif emotional['value'] < -0.4:
            recommendations.append("üßò –ö–æ–Ω—Ç—Ä–æ–ª–∏—Ä—É–π—Ç–µ —ç–º–æ—Ü–∏–∏, –∏–∑–±–µ–≥–∞–π—Ç–µ –∫–æ–Ω—Ñ–ª–∏–∫—Ç–æ–≤")

        # –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if intellectual['value'] > 0.5:
            recommendations.append("üìö –ë–ª–∞–≥–æ–ø—Ä–∏—è—Ç–Ω—ã–π –ø–µ—Ä–∏–æ–¥ –¥–ª—è –æ–±—É—á–µ–Ω–∏—è –∏ –∞–Ω–∞–ª–∏–∑–∞")
        elif intellectual['value'] < -0.3:
            recommendations.append("üìù –û—Ç–ª–æ–∂–∏—Ç–µ —Å–ª–æ–∂–Ω—ã–µ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–µ –∑–∞–¥–∞—á–∏")

        # –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        if intuitive['value'] > 0.4:
            recommendations.append("üîÆ –î–æ–≤–µ—Ä—è–π—Ç–µ –∏–Ω—Ç—É–∏—Ü–∏–∏ –ø—Ä–∏ –ø—Ä–∏–Ω—è—Ç–∏–∏ —Ä–µ—à–µ–Ω–∏–π")

        # –û–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —ç–Ω–µ—Ä–≥–∏–∏
        if overall['percentage'] > 70:
            recommendations.append("üöÄ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤—ã—Å–æ–∫—É—é —ç–Ω–µ—Ä–≥–∏—é –¥–ª—è –≤–∞–∂–Ω—ã—Ö –ø—Ä–æ–µ–∫—Ç–æ–≤")
        elif overall['percentage'] < 30:
            recommendations.append("‚ö° –≠–∫–æ–Ω–æ–º—å—Ç–µ —Å–∏–ª—ã, –ø–ª–∞–Ω–∏—Ä—É–π—Ç–µ –∫–æ—Ä–æ—Ç–∫–∏–µ –ø–µ—Ä–µ—Ä—ã–≤—ã")

        # –ï—Å–ª–∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –º–∞–ª–æ, –¥–æ–±–∞–≤–ª—è–µ–º –æ–±—â–∏–µ
        if len(recommendations) < 3:
            recommendations.extend([
                "üìÖ –°–ª–µ–¥—É–π—Ç–µ —Å–≤–æ–µ–º—É –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–º—É —Ä–∏—Ç–º—É",
                "‚è∞ –ü–ª–∞–Ω–∏—Ä—É–π—Ç–µ –∑–∞–¥–∞—á–∏ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —ç–Ω–µ—Ä–≥–µ—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø–∏–∫–∞–º–∏",
                "üíß –ü–µ–π—Ç–µË∂≥Â§ü –≤–æ–¥—ã –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∞–Ω–∏—è —ç–Ω–µ—Ä–≥–∏–∏"
            ])

        return recommendations[:5]  # –ù–µ –±–æ–ª–µ–µ 5 —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π

    def _find_critical_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –¥–Ω–µ–π (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π)"""
        critical_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (abs(physical['value']) > 0.9 or
                abs(emotional['value']) > 0.9 or
                abs(intellectual['value']) > 0.9):
            critical_days.append({
                'date': target_date.isoformat(),
                'cycles': self._get_critical_cycles(physical, emotional, intellectual),
                'description': '–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –¥–µ–Ω—å - –±—É–¥—å—Ç–µ –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã'
            })

        return critical_days

    def _find_peak_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–∏–∫–æ–≤—ã—Ö –¥–Ω–µ–π (–±–ª–∏–∂–∞–π—à–∏–µ 7 –¥–Ω–µ–π)"""
        peak_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (physical['value'] > 0.8 or
                emotional['value'] > 0.8 or
                intellectual['value'] > 0.8):

            peak_cycles = []
            if physical['value'] > 0.8: peak_cycles.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
            if emotional['value'] > 0.8: peak_cycles.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
            if intellectual['value'] > 0.8: peak_cycles.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')

            peak_days.append({
                'date': target_date.isoformat(),
                'cycles': peak_cycles,
                'description': f'–ü–∏–∫ —ç–Ω–µ—Ä–≥–∏–∏ –≤ —Ü–∏–∫–ª–∞—Ö: {", ".join(peak_cycles)}'
            })

        return peak_days

    def _get_critical_cycles(self, physical: Dict, emotional: Dict, intellectual: Dict) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ü–∏–∫–ª–æ–≤"""
        critical = []
        if abs(physical['value']) > 0.9: critical.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
        if abs(emotional['value']) > 0.9: critical.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
        if abs(intellectual['value']) > 0.9: critical.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')
        return critical

    def calculate_weekly_forecast(self, birth_date: date, start_date: date, days: int = 7) -> List[Dict]:
        """–†–∞—Å—á–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π"""
        forecast = []

        for i in range(days):
            current_date = start_date + timedelta(days=i)
            biorhythms = self.calculate_biorhythms(birth_date, current_date)

            forecast.append({
                'date': current_date.isoformat(),
                'overall_energy': biorhythms['overall_energy']['percentage'],
                'physical': biorhythms['cycles']['physical']['percentage'],
                'emotional': biorhythms['cycles']['emotional']['percentage'],
                'intellectual': biorhythms['cycles']['intellectual']['percentage'],
                'is_critical': len(biorhythms['critical_days']) > 0,
                'is_peak': len(biorhythms['peak_days']) > 0
            })

        return forecast
# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)


async def main():
    try:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î –ø–µ—Ä–µ–¥ –∑–∞–ø—É—Å–∫–æ–º
        logger.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö...")
        db_connected = await check_db_connection()

        if not db_connected:
            logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã.")
            return

        bot = Bot(token=TOKEN)
        dp = Dispatcher()

        # –ü–æ–¥–∫–ª—é—á–∞–µ–º —Ä–æ—É—Ç–µ—Ä
        dp.include_router(router)

        logger.info("‚úÖ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ...")
        logger.info("‚úÖ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ")
        logger.info("‚úÖ Personal Assistant –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–ª–ª–∏–Ω–≥
        await dp.start_polling(bot)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –±–æ—Ç–∞: {e}")
    finally:
        if 'bot' in locals():
            await bot.close()
        logger.info("üõë –ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")


if __name__ == "__main__":
    asyncio.run(main())


backend: 

__init__.py

assistant.py:

from backend.user_services import create_or_update_user, get_user_profile, update_user_profession, increment_request_count
from backend.chart_services import create_and_save_natal_chart, get_user_natal_chart
from backend.matrix_services import calculate_and_save_psyho_matrix, get_user_matrix
from backend.prediction_services import generate_and_save_prediction, get_user_predictions, \
    format_data_for_user, format_data_for_model
from backend.biorhythm_services import calculate_and_save_biorhythms, get_user_biorhythms
from backend.database import async_session
from datetime import datetime, date, timedelta
from backend.moon import calculate_lunar_phase
import logging

logger = logging.getLogger(__name__)


class PersonalAssistant:
    """–ì–ª–∞–≤–Ω—ã–π –∫–ª–∞—Å—Å –ø–æ–º–æ—â–Ω–∏–∫–∞ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—Å–µ–º–∏ –¥–∞–Ω–Ω—ã–º–∏"""

    def __init__(self):
        pass

    async def collect_user_data(self, telegram_id: int, birth_date: date, birth_time: datetime.time,
                                birth_city: str, current_city: str = None, profession: str = None,
                                job_position: str = None, gender: str = None):  # –ù–û–í–´–ô –ü–ê–†–ê–ú–ï–¢–†
        """–°–±–æ—Ä –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            logger.info(f"üîÑ –ù–∞—á–∞–ª–æ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")

            # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç–∏ –æ–ø–µ—Ä–∞—Ü–∏–π
            async with async_session() as session:
                try:
                    # 1. –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                    user = await create_or_update_user(
                        telegram_id=telegram_id,
                        birth_date=birth_date,
                        birth_time=birth_time,
                        birth_city=birth_city,
                        current_city=current_city,
                        profession=profession,
                        job_position=job_position,
                        gender=gender  # –ü–ï–†–ï–î–ê–ï–ú –ü–û–õ
                    )
                    logger.info(f"‚úÖ –î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã")

                    # 2. –°–æ–∑–¥–∞–µ–º –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É
                    birth_datetime = datetime.combine(birth_date, birth_time)
                    natal_chart = await create_and_save_natal_chart(
                        telegram_id=telegram_id,
                        city=birth_city,
                        birth_datetime=birth_datetime,
                        timezone="Europe/Moscow"
                    )
                    logger.info(f"‚úÖ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ —Å–æ–∑–¥–∞–Ω–∞")

                    # 3. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
                    matrix_data = await calculate_and_save_psyho_matrix(telegram_id)
                    logger.info(f"‚úÖ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–∞")

                    # 4. –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∏–æ—Ä–∏—Ç–º—ã –Ω–∞ —Å–µ–≥–æ–¥–Ω—è
                    biorhythms = await calculate_and_save_biorhythms(telegram_id)
                    logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã")

                    await session.commit()

                    return {
                        'success': True,
                        'message': "‚úÖ –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ–±—Ä–∞–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!",
                        'data_collected': {
                            'user_profile': True,
                            'natal_chart': True,
                            'psyho_matrix': True,
                            'biorhythms': True
                        }
                    }

                except Exception as e:
                    await session.rollback()
                    logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
                    raise

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
            }

    async def get_recommendations(self, telegram_id: int, target_date: date):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É"""
        try:
            logger.info(f"üìÖ –§–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ {target_date} –¥–ª—è {telegram_id}")

            # –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π
            await increment_request_count(telegram_id)
            logger.info(f"üìà –°—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π —É–≤–µ–ª–∏—á–µ–Ω –¥–ª—è {telegram_id}")

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –¥–∞—Ç–∞ –Ω–µ –≤ –ø—Ä–æ—à–ª–æ–º
            if target_date < date.today():
                return {
                    'success': False,
                    'message': "‚ùå –ù–µ–ª—å–∑—è –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø—Ä–æ—à–µ–¥—à–∏—Ö –¥–∞—Ç"
                }

            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –¥–∞—Ç—ã
            prediction = await generate_and_save_prediction(telegram_id, target_date)

            # –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –º–æ–¥–µ–ª–∏
            user_profile = await get_user_profile(telegram_id)

            # 1. –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (—á–µ—Ä–µ–∑ –±–æ—Ç)
            user_data = await format_data_for_user(prediction)

            # 2. –î–∞–Ω–Ω—ã–µ –¥–ª—è –º–æ–¥–µ–ª–∏ (—á–µ—Ä–µ–∑ print)
            model_data = await format_data_for_model(telegram_id, user_profile, prediction)

            return {
                'success': True,
                'date': target_date.isoformat(),
                'user_data': user_data,  # –î–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ –±–æ—Ç–µ
                'model_data': model_data,  # –î–ª—è AI –º–æ–¥–µ–ª–∏ (–≤—ã–≤–æ–¥–∏—Ç—Å—è —á–µ—Ä–µ–∑ print)
                'raw_data': prediction
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –Ω–∞ {target_date} –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É: {str(e)}"
            }

    async def get_todays_recommendations(self, telegram_id: int):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)"""
        return await self.get_recommendations(telegram_id, date.today())

    async def get_tomorrows_recommendations(self, telegram_id: int):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –∑–∞–≤—Ç—Ä–∞"""
        tomorrow = date.today() + timedelta(days=1)
        return await self.get_recommendations(telegram_id, tomorrow)

    async def get_date_recommendations(self, telegram_id: int, target_date: date):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—É—é –¥–∞—Ç—É (alias –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏—è)"""
        return await self.get_recommendations(telegram_id, target_date)

    async def update_professional_info(self, telegram_id: int, current_city: str, profession: str,
                                       job_position: str = None, gender: str = None):  # –ù–û–í–´–ô –ü–ê–†–ê–ú–ï–¢–†
        """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
        try:
            await update_user_profession(telegram_id, profession, job_position)

            # –û–±–Ω–æ–≤–ª—è–µ–º –≥–æ—Ä–æ–¥ –ø—Ä–æ–∂–∏–≤–∞–Ω–∏—è –∏ –ø–æ–ª
            user_profile = await get_user_profile(telegram_id)
            if user_profile:
                await create_or_update_user(
                    telegram_id=telegram_id,
                    birth_date=user_profile['birth_date'],
                    birth_time=user_profile['birth_time'],
                    birth_city=user_profile['birth_city'],
                    current_city=current_city,
                    profession=profession,
                    job_position=job_position,
                    gender=gender  # –ü–ï–†–ï–î–ê–ï–ú –ü–û–õ
                )

            logger.info(f"‚úÖ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –æ–±–Ω–æ–≤–ª–µ–Ω—ã –¥–ª—è {telegram_id}")
            return {
                'success': True,
                'message': "‚úÖ –ü—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!"
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
            }

    async def get_user_data_status(self, telegram_id: int):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ —Å–æ–±—Ä–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            user_profile = await get_user_profile(telegram_id)
            natal_chart = await get_user_natal_chart(telegram_id)
            psyho_matrix = await get_user_matrix(telegram_id)
            biorhythms = await get_user_biorhythms(telegram_id)

            has_basic_data = user_profile is not None
            has_natal_chart = natal_chart is not None
            has_psyho_matrix = psyho_matrix is not None
            has_biorhythms = biorhythms is not None

            return {
                'has_basic_data': has_basic_data,
                'has_natal_chart': has_natal_chart,
                'has_psyho_matrix': has_psyho_matrix,
                'has_biorhythms': has_biorhythms,
                'is_complete': has_basic_data and has_natal_chart and has_psyho_matrix and has_biorhythms,
                'user_profile': user_profile
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'has_basic_data': False,
                'has_natal_chart': False,
                'has_psyho_matrix': False,
                'has_biorhythms': False,
                'is_complete': False
            }

    async def get_user_statistics(self, telegram_id: int):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            from backend.prediction_services import get_prediction_statistics
            from backend.biorhythm_services import get_biorhythm_statistics
            from backend.user_services import get_user_request_count

            data_status = await self.get_user_data_status(telegram_id)
            prediction_stats = await get_prediction_statistics(telegram_id)
            biorhythm_stats = await get_biorhythm_statistics(telegram_id)
            request_count = await get_user_request_count(telegram_id)

            return {
                'data_status': data_status,
                'prediction_stats': prediction_stats,
                'biorhythm_stats': biorhythm_stats,
                'request_count': request_count,
                'calculated_at': datetime.now().isoformat()
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è {telegram_id}: {e}")
            return {
                'data_status': {},
                'prediction_stats': {},
                'biorhythm_stats': {},
                'request_count': 0,
                'error': str(e)
            }

    async def cleanup_user_data(self, telegram_id: int):
        """–û—á–∏—Å—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¥–ª—è –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏—è)"""
        try:
            from backend.biorhythm_services import cleanup_old_biorhythms
            from backend.prediction_services import cleanup_old_predictions

            biorhythm_cleaned = await cleanup_old_biorhythms()
            prediction_cleaned = await cleanup_old_predictions()

            logger.info(f"üßπ –û—á–∏—â–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")
            return {
                'success': True,
                'biorhythm_records_cleaned': biorhythm_cleaned,
                'prediction_records_cleaned': prediction_cleaned,
                'message': f"‚úÖ –û—á–∏—â–µ–Ω–æ {biorhythm_cleaned} –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ –∏ {prediction_cleaned} –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π"
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'success': False,
                'message': f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö: {str(e)}"
            }

    async def validate_user_data(self, telegram_id: int):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            from backend.prediction_services import validate_prediction_data

            data_status = await self.get_user_data_status(telegram_id)
            prediction_valid = await validate_prediction_data(telegram_id)

            issues = []

            if not data_status['has_basic_data']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –æ—Å–Ω–æ–≤–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
            if not data_status['has_natal_chart']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞")
            if not data_status['has_psyho_matrix']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞")
            if not data_status['has_biorhythms']:
                issues.append("–û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –¥–∞–Ω–Ω—ã–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤")
            if not prediction_valid:
                issues.append("–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π")

            return {
                'is_valid': len(issues) == 0,
                'issues': issues,
                'data_status': data_status,
                'prediction_valid': prediction_valid
            }

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
            return {
                'is_valid': False,
                'issues': [f"–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {str(e)}"],
                'data_status': {},
                'prediction_valid': False
            }


# –°–æ–∑–¥–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –ø–æ–º–æ—â–Ω–∏–∫–∞
assistant = PersonalAssistant()

biorhythm_calculator.py:

import math
from datetime import date, datetime, timedelta
from typing import Dict, List, Tuple
import logging

logger = logging.getLogger(__name__)


class BiorhythmCalculator:
    """
    –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è.
    –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π, —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∏ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª—ã.
    """

    def __init__(self):
        # –ü–µ—Ä–∏–æ–¥—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤ –≤ –¥–Ω—è—Ö
        self.PHYSICAL_CYCLE = 23
        self.EMOTIONAL_CYCLE = 28
        self.INTELLECTUAL_CYCLE = 33
        self.INTUITIVE_CYCLE = 38  # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ü–∏–∫–ª

    def calculate_biorhythms(self, birth_date: date, target_date: date) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –∑–∞–¥–∞–Ω–Ω—É—é –¥–∞—Ç—É

        Args:
            birth_date: –î–∞—Ç–∞ —Ä–æ–∂–¥–µ–Ω–∏—è
            target_date: –î–∞—Ç–∞ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞

        Returns:
            –°–ª–æ–≤–∞—Ä—å —Å –¥–∞–Ω–Ω—ã–º–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤
        """
        try:
            # –í—ã—á–∏—Å–ª—è–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            days_lived = (target_date - birth_date).days

            if days_lived < 0:
                raise ValueError("–î–∞—Ç–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–Ω—å—à–µ –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è")

            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–æ–≤
            physical = self._calculate_cycle(days_lived, self.PHYSICAL_CYCLE)
            emotional = self._calculate_cycle(days_lived, self.EMOTIONAL_CYCLE)
            intellectual = self._calculate_cycle(days_lived, self.INTELLECTUAL_CYCLE)
            intuitive = self._calculate_cycle(days_lived, self.INTUITIVE_CYCLE)

            # –û–±—â–∏–π –ø–æ–∫–∞–∑–∞—Ç–µ–ª—å —ç–Ω–µ—Ä–≥–∏–∏
            overall_energy = self._calculate_overall_energy(physical, emotional, intellectual, intuitive)

            biorhythm_data = {
                'calculation_date': target_date.isoformat(),
                'days_lived': days_lived,
                'cycles': {
                    'physical': physical,
                    'emotional': emotional,
                    'intellectual': intellectual,
                    'intuitive': intuitive
                },
                'overall_energy': overall_energy,
                'critical_days': self._find_critical_days(physical, emotional, intellectual, target_date),
                'peak_days': self._find_peak_days(physical, emotional, intellectual, target_date)
            }

            logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –¥–ª—è {target_date}, –ø—Ä–æ–∂–∏—Ç–æ –¥–Ω–µ–π: {days_lived}")
            return biorhythm_data

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
            raise

    def _calculate_cycle(self, days_lived: int, cycle_length: int) -> Dict:
        """
        –†–∞—Å—á–µ—Ç –æ–¥–Ω–æ–≥–æ —Ü–∏–∫–ª–∞ –±–∏–æ—Ä–∏—Ç–º–∞

        Args:
            days_lived: –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–∂–∏—Ç—ã—Ö –¥–Ω–µ–π
            cycle_length: –î–ª–∏–Ω–∞ —Ü–∏–∫–ª–∞ –≤ –¥–Ω—è—Ö

        Returns:
            –î–∞–Ω–Ω—ã–µ —Ü–∏–∫–ª–∞
        """
        # –¢–µ–∫—É—â–∞—è —Ñ–∞–∑–∞ –≤ —Ä–∞–¥–∏–∞–Ω–∞—Ö (2œÄ –∑–∞ –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª)
        phase = (2 * math.pi * days_lived) / cycle_length

        # –ó–Ω–∞—á–µ–Ω–∏–µ —Å–∏–Ω—É—Å–æ–∏–¥—ã (-1 –¥–æ +1)
        value = math.sin(phase)

        # –ü—Ä–æ—Ü–µ–Ω—Ç –æ—Ç –º–∞–∫—Å–∏–º—É–º–∞ (0% –¥–æ 100%)
        percentage = ((value + 1) / 2) * 100

        # –î–µ–Ω—å –≤ —Ü–∏–∫–ª–µ (0 –¥–æ cycle_length-1)
        day_in_cycle = days_lived % cycle_length

        return {
            'value': round(value, 4),
            'percentage': round(percentage, 2),
            'day_in_cycle': day_in_cycle,
            'phase': self._get_phase_description(value),
            'trend': self._get_trend(phase)
        }

    def _get_phase_description(self, value: float) -> str:
        """–û–ø–∏—Å–∞–Ω–∏–µ —Ñ–∞–∑—ã –±–∏–æ—Ä–∏—Ç–º–∞"""
        if value >= 0.7:
            return "–ø–∏–∫ —ç–Ω–µ—Ä–≥–∏–∏"
        elif value >= 0.3:
            return "–≤—ã—Å–æ–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        elif value >= -0.3:
            return "–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è —Ñ–∞–∑–∞"
        elif value >= -0.7:
            return "–Ω–∏–∑–∫–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å"
        else:
            return "–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Ç–æ—á–∫–∞"

    def _get_trend(self, phase: float) -> str:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç—Ä–µ–Ω–¥–∞ (—Ä–∞—Å—Ç–µ—Ç/–ø–∞–¥–∞–µ—Ç)"""
        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–∏–∑–≤–æ–¥–Ω—É—é (cos(phase))
        derivative = math.cos(phase)

        if derivative > 0.1:
            return "—Ä–∞—Å—Ç–µ—Ç"
        elif derivative < -0.1:
            return "–ø–∞–¥–∞–µ—Ç"
        else:
            return "—Å—Ç–∞–±–∏–ª—å–Ω–æ"

    def _calculate_overall_energy(self, physical: Dict, emotional: Dict, intellectual: Dict, intuitive: Dict) -> Dict:
        """–†–∞—Å—á–µ—Ç –æ–±—â–µ–≥–æ —É—Ä–æ–≤–Ω—è —ç–Ω–µ—Ä–≥–∏–∏"""
        # –í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—É–º–º–∞ –≤—Å–µ—Ö —Ü–∏–∫–ª–æ–≤
        total_energy = (
                physical['value'] * 0.3 +  # –§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª - 30%
                emotional['value'] * 0.25 +  # –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π - 25%
                intellectual['value'] * 0.25 +  # –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π - 25%
                intuitive['value'] * 0.2  # –ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–π - 20%
        )

        # –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –¥–æ 0-100%
        energy_percentage = ((total_energy + 1) / 2) * 100

        return {
            'value': round(total_energy, 4),
            'percentage': round(energy_percentage, 2)
        }

    def _find_critical_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –¥–Ω–µ–π"""
        critical_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (abs(physical['value']) > 0.9 or
                abs(emotional['value']) > 0.9 or
                abs(intellectual['value']) > 0.9):
            critical_days.append({
                'date': target_date.isoformat(),
                'cycles': self._get_critical_cycles(physical, emotional, intellectual)
            })

        return critical_days

    def _find_peak_days(self, physical: Dict, emotional: Dict, intellectual: Dict, target_date: date) -> List[Dict]:
        """–û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–∏–∫–æ–≤—ã—Ö –¥–Ω–µ–π"""
        peak_days = []

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–∏–π –¥–µ–Ω—å
        if (physical['value'] > 0.8 or
                emotional['value'] > 0.8 or
                intellectual['value'] > 0.8):

            peak_cycles = []
            if physical['value'] > 0.8: peak_cycles.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
            if emotional['value'] > 0.8: peak_cycles.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
            if intellectual['value'] > 0.8: peak_cycles.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')

            peak_days.append({
                'date': target_date.isoformat(),
                'cycles': peak_cycles
            })

        return peak_days

    def _get_critical_cycles(self, physical: Dict, emotional: Dict, intellectual: Dict) -> List[str]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Ü–∏–∫–ª–æ–≤"""
        critical = []
        if abs(physical['value']) > 0.9: critical.append('—Ñ–∏–∑–∏—á–µ—Å–∫–∏–π')
        if abs(emotional['value']) > 0.9: critical.append('—ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π')
        if abs(intellectual['value']) > 0.9: critical.append('–∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π')
        return critical

    def calculate_weekly_forecast(self, birth_date: date, start_date: date, days: int = 7) -> List[Dict]:
        """–†–∞—Å—á–µ—Ç –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ –¥–Ω–µ–π"""
        forecast = []

        for i in range(days):
            current_date = start_date + timedelta(days=i)
            biorhythms = self.calculate_biorhythms(birth_date, current_date)

            forecast.append({
                'date': current_date.isoformat(),
                'overall_energy': biorhythms['overall_energy']['percentage'],
                'physical': biorhythms['cycles']['physical']['percentage'],
                'emotional': biorhythms['cycles']['emotional']['percentage'],
                'intellectual': biorhythms['cycles']['intellectual']['percentage'],
                'is_critical': len(biorhythms['critical_days']) > 0,
                'is_peak': len(biorhythms['peak_days']) > 0
            })

        return forecast

biorhythm_services.py:

from backend.database import async_session, Biorhythms
from backend.biorhythm_calculator import BiorhythmCalculator
from backend.user_services import get_user_profile
from sqlalchemy.future import select
from sqlalchemy import func, and_
from datetime import date, datetime, timedelta
import logging
import asyncio

logger = logging.getLogger(__name__)


async def calculate_and_save_biorhythms(telegram_id: int, target_date: date = None):
    """–†–∞—Å—á–µ—Ç –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        if target_date is None:
            target_date = date.today()

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_profile = await get_user_profile(telegram_id)
        if not user_profile:
            raise ValueError(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∏–æ—Ä–∏—Ç–º—ã
        calculator = BiorhythmCalculator()
        biorhythm_data = calculator.calculate_biorhythms(
            user_profile['birth_date'],
            target_date
        )

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ –ë–î —Å –∞—Ç–æ–º–∞—Ä–Ω–æ–π –æ–ø–µ—Ä–∞—Ü–∏–µ–π
        async with async_session() as session:
            try:
                # –°–Ω–∞—á–∞–ª–∞ —É–¥–∞–ª—è–µ–º –í–°–ï —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ –∑–∞–ø–∏—Å–∏ –¥–ª—è —ç—Ç–æ–π –¥–∞—Ç—ã (–Ω–∞ —Å–ª—É—á–∞–π –¥—É–±–ª–µ–π)
                await session.execute(
                    Biorhythms.__table__.delete().where(
                        and_(
                            Biorhythms.telegram_id == telegram_id,
                            Biorhythms.calculation_date == target_date
                        )
                    )
                )

                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
                new_record = Biorhythms(
                    telegram_id=telegram_id,
                    biorhythm_data=biorhythm_data,
                    calculation_date=target_date
                )
                session.add(new_record)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –±–∏–æ—Ä–∏—Ç–º—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

                await session.commit()
                logger.info(f"üíæ –ë–∏–æ—Ä–∏—Ç–º—ã —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –¥–ª—è {telegram_id}")

            except Exception as db_error:
                await session.rollback()
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ë–î –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {db_error}")
                raise

        return biorhythm_data

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –¥–ª—è {telegram_id}: {e}")
        raise


async def get_user_biorhythms(telegram_id: int, target_date: date = None):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫"""
    try:
        if target_date is None:
            target_date = date.today()

        async with async_session() as session:
            result = await session.execute(
                select(Biorhythms).where(
                    and_(
                        Biorhythms.telegram_id == telegram_id,
                        Biorhythms.calculation_date == target_date
                    )
                )
            )
            biorhythms = result.scalar_one_or_none()

            if biorhythms:
                logger.info(f"‚úÖ –ù–∞–π–¥–µ–Ω—ã —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –±–∏–æ—Ä–∏—Ç–º—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")
                return biorhythms.biorhythm_data

            # –ï—Å–ª–∏ –∑–∞–ø–∏—Å—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–Ω–æ–≤–æ
            logger.info(f"üîÑ –ë–∏–æ—Ä–∏—Ç–º—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã, —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∑–∞–Ω–æ–≤–æ –¥–ª—è {telegram_id}")
            return await calculate_and_save_biorhythms(telegram_id, target_date)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {e}")
        return None


async def get_biorhythm_weekly_forecast(telegram_id: int, start_date: date = None, days: int = 7):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ–¥–µ–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ —Å —É–ª—É—á—à–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π"""
    try:
        if start_date is None:
            start_date = date.today()

        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_profile = await get_user_profile(telegram_id)
        if not user_profile:
            raise ValueError(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω")

        calculator = BiorhythmCalculator()
        forecast = calculator.calculate_weekly_forecast(
            user_profile['birth_date'],
            start_date,
            days
        )

        logger.info(f"‚úÖ –ü—Ä–æ–≥–Ω–æ–∑ –±–∏–æ—Ä–∏—Ç–º–æ–≤ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω –¥–ª—è {telegram_id} –Ω–∞ {days} –¥–Ω–µ–π")
        return forecast

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ–≥–Ω–æ–∑–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {e}")
        return None


async def cleanup_duplicate_biorhythms():
    """–û—á–∏—Å—Ç–∫–∞ –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤"""
    try:
        async with async_session() as session:
            # –ù–∞—Ö–æ–¥–∏–º –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è –∑–∞–ø–∏—Å–∏
            duplicate_query = """
            DELETE FROM biorhythms 
            WHERE ctid NOT IN (
                SELECT MIN(ctid) 
                FROM biorhythms 
                GROUP BY telegram_id, calculation_date
            )
            """

            result = await session.execute(duplicate_query)
            deleted_count = result.rowcount

            await session.commit()

            if deleted_count > 0:
                logger.warning(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {deleted_count} –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤")
            else:
                logger.info("‚úÖ –î—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

            return deleted_count

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥—É–±–ª–∏—Ä—É—é—â–∏—Ö—Å—è –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
        return 0


async def get_biorhythm_statistics(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ –±–∏–æ—Ä–∏—Ç–º–∞–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤
            count_result = await session.execute(
                select(func.count(Biorhythms.telegram_id)).where(
                    Biorhythms.telegram_id == telegram_id
                )
            )
            total_records = count_result.scalar() or 0

            # –°–∞–º–∞—è —Å—Ç–∞—Ä–∞—è –∏ –Ω–æ–≤–∞—è –∑–∞–ø–∏—Å—å
            dates_result = await session.execute(
                select(
                    func.min(Biorhythms.calculation_date),
                    func.max(Biorhythms.calculation_date)
                ).where(Biorhythms.telegram_id == telegram_id)
            )
            min_date, max_date = dates_result.first() or (None, None)

            statistics = {
                'total_records': total_records,
                'first_calculation': min_date.isoformat() if min_date else None,
                'last_calculation': max_date.isoformat() if max_date else None,
                'calculation_range_days': (max_date - min_date).days if min_date and max_date else 0
            }

            logger.info(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–∏–æ—Ä–∏—Ç–º–æ–≤ –ø–æ–ª—É—á–µ–Ω–∞ –¥–ª—è {telegram_id}")
            return statistics

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤ {telegram_id}: {e}")
        return {
            'total_records': 0,
            'first_calculation': None,
            'last_calculation': None,
            'calculation_range_days': 0
        }


async def cleanup_old_biorhythms(days_old: int = 30):
    """–û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤"""
    try:
        cutoff_date = date.today() - timedelta(days=days_old)

        async with async_session() as session:
            result = await session.execute(
                Biorhythms.__table__.delete().where(
                    Biorhythms.calculation_date < cutoff_date
                )
            )
            deleted_count = result.rowcount

            await session.commit()

            if deleted_count > 0:
                logger.info(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–æ {deleted_count} —Å—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ (—Å—Ç–∞—Ä—à–µ {days_old} –¥–Ω–µ–π)")
            else:
                logger.info("‚úÖ –°—Ç–∞—Ä—ã—Ö –∑–∞–ø–∏—Å–µ–π –±–∏–æ—Ä–∏—Ç–º–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")

            return deleted_count

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ —Å—Ç–∞—Ä—ã—Ö –±–∏–æ—Ä–∏—Ç–º–æ–≤: {e}")
        return 0

chart_services.py:

from backend.database import async_session, UserNatalChart
from backend.natal_chart import MLNatalChartCalculator
from sqlalchemy.future import select
import logging

logger = logging.getLogger(__name__)


async def create_and_save_natal_chart(telegram_id: int, city: str, birth_datetime, timezone: str):
    """–°–æ–∑–¥–∞–Ω–∏–µ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã"""
    try:
        calculator = MLNatalChartCalculator()
        natal_data = calculator.calculate_natal_chart_ml(city, birth_datetime, timezone)

        logger.info(f"–°–æ–∑–¥–∞–Ω–∏–µ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")

        async with async_session() as session:
            result = await session.execute(
                select(UserNatalChart).where(UserNatalChart.telegram_id == telegram_id)
            )
            natal_chart = result.scalar_one_or_none()

            if natal_chart:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É
                natal_chart.natal_data = natal_data
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –¥–ª—è {telegram_id}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É
                natal_chart = UserNatalChart(
                    telegram_id=telegram_id,
                    natal_data=natal_data
                )
                session.add(natal_chart)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –¥–ª—è {telegram_id}")

            await session.commit()
            logger.info(f"üíæ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è {telegram_id}")
            return natal_chart

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –¥–ª—è {telegram_id}: {e}")
        raise


async def get_user_natal_chart(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(UserNatalChart).where(UserNatalChart.telegram_id == telegram_id)
            )
            natal_chart = result.scalar_one_or_none()

            if natal_chart:
                return natal_chart.natal_data
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã {telegram_id}: {e}")
        return None

database.py:

import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, BigInteger, JSON, TIMESTAMP, String, Date, Time, Text
from sqlalchemy.sql import func
from sqlalchemy import ForeignKey
from sqlalchemy import Column, BigInteger, JSON, TIMESTAMP, String, Date, Time, Text, ForeignKey, Integer
from sqlalchemy.sql import func
import logging

logger = logging.getLogger(__name__)

DATABASE_URL = os.getenv(
    "DATABASE_URL",
    "postgresql+asyncpg://pers_assist:astra123@localhost:5432/p_assistant_bd"
)

logger.info(f"–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ –ë–î: postgresql+asyncpg://pers_assist:******@localhost:5432/p_assistant_bd")

async_engine = create_async_engine(
    DATABASE_URL,
    echo=True,
    pool_pre_ping=True,
    pool_recycle=300
)

async_session = sessionmaker(
    async_engine,
    expire_on_commit=False,
    class_=AsyncSession
)

Base = declarative_base()

class User(Base):
    __tablename__ = 'users'

    telegram_id = Column(BigInteger, primary_key=True, index=True)
    birth_date = Column(Date, nullable=False)
    birth_time = Column(Time, nullable=False)
    birth_city = Column(String(100), nullable=False)
    profession = Column(String(100), nullable=True)
    job_position = Column(String(100), nullable=True)
    current_city = Column(String(100), nullable=True)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())
    gender = Column(String(10), nullable=True)  # 'male', 'female', None
    request_count = Column(Integer, default=0)

    def __repr__(self):
        return f"<User(telegram_id={self.telegram_id}, birth_date={self.birth_date})>"

class UserNatalChart(Base):
    __tablename__ = 'user_natal_charts'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    natal_data = Column(JSON, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<UserNatalChart(telegram_id={self.telegram_id})>"

class PsyhoMatrix(Base):
    __tablename__ = 'psyho_matrix'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    matrix_data = Column(JSON, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<PsyhoMatrix(telegram_id={self.telegram_id})>"

class NatalPredictions(Base):
    __tablename__ = 'natal_predictions'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    predictions = Column(JSON, nullable=False)
    assistant_data = Column(JSON, nullable=False, default={})
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<NatalPredictions(telegram_id={self.telegram_id})>"


class Biorhythms(Base):
    __tablename__ = 'biorhythms'

    telegram_id = Column(BigInteger, ForeignKey('users.telegram_id', ondelete='CASCADE'), primary_key=True, index=True)
    biorhythm_data = Column(JSON, nullable=False)
    calculation_date = Column(Date, nullable=False)
    created_at = Column(TIMESTAMP, server_default=func.now())
    updated_at = Column(TIMESTAMP, server_default=func.now(), onupdate=func.now())

    def __repr__(self):
        return f"<Biorhythms(telegram_id={self.telegram_id}, date={self.calculation_date})>"



async def get_db():
    async with async_session() as session:
        try:
            yield session
        finally:
            await session.close()





db_connection.py:

from backend.database import async_session
from sqlalchemy import text
import logging

logger = logging.getLogger(__name__)

async def check_db_connection():
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö"""
    try:
        async with async_session() as session:
            await session.execute(text("SELECT 1"))
        logger.info("‚úÖ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î —É—Å–ø–µ—à–Ω–æ")
        return True
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î: {e}")
        return False

matrix_services.py:

from backend.database import async_session, PsyhoMatrix
from backend.psyho_matrix import PsyhoMatrixCalculator
from backend.user_services import get_user_profile
from sqlalchemy.future import select
import logging

logger = logging.getLogger(__name__)


async def calculate_and_save_psyho_matrix(telegram_id: int):
    """–†–∞—Å—á–µ—Ç –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã"""
    try:
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        user_profile = await get_user_profile(telegram_id)
        if not user_profile:
            raise ValueError("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

        calculator = PsyhoMatrixCalculator()
        matrix_data = calculator.calculate_matrix(user_profile['birth_date'])

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
        async with async_session() as session:
            result = await session.execute(
                select(PsyhoMatrix).where(PsyhoMatrix.telegram_id == telegram_id)
            )
            psyho_matrix = result.scalar_one_or_none()

            if psyho_matrix:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
                psyho_matrix.matrix_data = matrix_data
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω–∞ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ –¥–ª—è {telegram_id}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É
                psyho_matrix = PsyhoMatrix(
                    telegram_id=telegram_id,
                    matrix_data=matrix_data
                )
                session.add(psyho_matrix)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ –¥–ª—è {telegram_id}")

            await session.commit()
            logger.info(f"‚úÖ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ —Ä–∞—Å—Å—á–∏—Ç–∞–Ω–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –¥–ª—è {telegram_id}")

        return matrix_data

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞—Å—á–µ—Ç–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –¥–ª—è {telegram_id}: {e}")
        raise


async def get_user_matrix(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(PsyhoMatrix).where(PsyhoMatrix.telegram_id == telegram_id)
            )
            matrix = result.scalar_one_or_none()

            if matrix:
                return matrix.matrix_data
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã {telegram_id}: {e}")
        return None

natal_chart.py:

import os
import pytz
from datetime import datetime
import swisseph as swe
from math import floor
from typing import Dict, List, Tuple, Any
import logging
import requests
import time
from urllib.parse import quote

from backend.database import async_session, UserNatalChart

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MLNatalChartCalculator:
    def __init__(self):
        current_dir = os.getcwd()
        ephe_path = os.path.join(current_dir, 'ephe')
        swe.set_ephe_path(ephe_path)
        swe.set_jpl_file('de441.eph')

        # –ö—ç—à –¥–ª—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≥–æ—Ä–æ–¥–æ–≤
        self.coordinates_cache = {}

        # –û—Å–Ω–æ–≤–Ω—ã–µ –≥–æ—Ä–æ–¥–∞ –†–æ—Å—Å–∏–∏ –¥–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ –¥–æ—Å—Ç—É–ø–∞
        self.major_cities = {
            "–º–æ—Å–∫–≤–∞": (55.7558, 37.6173, 156),
            "—Å–∞–Ω–∫—Ç-–ø–µ—Ç–µ—Ä–±—É—Ä–≥": (59.9343, 30.3351, 3),
            "–Ω–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫": (55.0084, 82.9357, 150),
            "–µ–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥": (56.8389, 60.6057, 237),
            "–Ω–∏–∂–Ω–∏–π –Ω–æ–≤–≥–æ—Ä–æ–¥": (56.3269, 44.0075, 78),
            "–∫–∞–∑–∞–Ω—å": (55.8304, 49.0661, 60),
            "—á–µ–ª—è–±–∏–Ω—Å–∫": (55.1644, 61.4368, 228),
            "–æ–º—Å–∫": (54.9884, 73.3242, 85),
            "—Å–∞–º–∞—Ä–∞": (53.2415, 50.2212, 87),
            "—Ä–æ—Å—Ç–æ–≤-–Ω–∞-–¥–æ–Ω—É": (47.2225, 39.7187, 70),
            "—É—Ñ–∞": (54.7355, 55.9587, 158),
            "–∫—Ä–∞—Å–Ω–æ—è—Ä—Å–∫": (56.0153, 92.8932, 136),
            "–ø–µ—Ä–º—å": (58.0105, 56.2502, 149),
            "–≤–æ—Ä–æ–Ω–µ–∂": (51.6720, 39.1843, 104),
            "–≤–æ–ª–≥–æ–≥—Ä–∞–¥": (48.7080, 44.5133, 80),
            "–∫—Ä–∞—Å–Ω–æ–¥–∞—Ä": (45.0355, 38.9750, 25),
            "—Å–∞—Ä–∞—Ç–æ–≤": (51.5924, 45.9608, 50),
            "—Ç—é–º–µ–Ω—å": (57.1613, 65.5250, 70),
            "—Ç–æ–ª—å—è—Ç—Ç–∏": (53.5088, 49.4192, 90),
            "–∏–∂–µ–≤—Å–∫": (56.8527, 53.2115, 140),
            "—É–ª—å—è–Ω–æ–≤—Å–∫": (54.3282, 48.3866, 80),
            "–∏—Ä–∫—É—Ç—Å–∫": (52.2864, 104.2806, 440),
            "—Ö–∞–±–∞—Ä–æ–≤—Å–∫": (48.4802, 135.0719, 72),
            "—è—Ä–æ—Å–ª–∞–≤–ª—å": (57.6261, 39.8845, 100),
            "–≤–ª–∞–¥–∏–≤–æ—Å—Ç–æ–∫": (43.1332, 131.9113, 8),
            "–º–≥–∞": (59.7569, 31.0609, 33)
        }

        self.ORBS = {
            'conjunction': 8, 'opposition': 8, 'square': 8, 'trine': 8, 'sextile': 6,
            'quincunx': 3, 'semi-square': 3, 'semi-sextile': 3
        }

        self.planets_ml = {
            swe.SUN: 'Sun',
            swe.MOON: 'Moon',
            swe.MERCURY: 'Mercury',
            swe.VENUS: 'Venus',
            swe.MARS: 'Mars',
            swe.JUPITER: 'Jupiter',
            swe.SATURN: 'Saturn',
            swe.URANUS: 'Uranus',
            swe.NEPTUNE: 'Neptune',
            swe.PLUTO: 'Pluto',
            swe.TRUE_NODE: 'North_Node'
        }

        self.zodiac_signs = [
            "Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo",
            "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces"
        ]

        self.aspects_ml = {
            0: ('conjunction', self.ORBS['conjunction']),
            60: ('sextile', self.ORBS['sextile']),
            90: ('square', self.ORBS['square']),
            120: ('trine', self.ORBS['trine']),
            180: ('opposition', self.ORBS['opposition'])
        }

    def get_city_coordinates(self, city_name: str) -> Tuple[float, float, float]:
        """
        –ù–∞–¥–µ–∂–Ω–æ–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≥–æ—Ä–æ–¥–∞.
        –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –∫—ç—à, –∑–∞—Ç–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –≥–æ—Ä–æ–¥–∞, –∑–∞—Ç–µ–º –≥–µ–æ–∫–æ–¥–∏–Ω–≥.
        """
        city_lower = city_name.strip().lower()

        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à
        if city_lower in self.coordinates_cache:
            logger.info(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –∫—ç—à–∞ –¥–ª—è: {city_name}")
            return self.coordinates_cache[city_lower]

        # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –≥–æ—Ä–æ–¥–∞ –†–æ—Å—Å–∏–∏
        if city_lower in self.major_cities:
            coords = self.major_cities[city_lower]
            self.coordinates_cache[city_lower] = coords
            logger.info(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑ –±–∞–∑—ã –æ—Å–Ω–æ–≤–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤ –¥–ª—è: {city_name}")
            return coords

        # 3. –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–µ–æ–∫–æ–¥–∏–Ω–≥ —á–µ—Ä–µ–∑ Nominatim (OpenStreetMap)
        try:
            coords = self._geocode_city(city_name)
            if coords:
                self.coordinates_cache[city_lower] = coords
                logger.info(f"–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ–ª—É—á–µ–Ω—ã —á–µ—Ä–µ–∑ –≥–µ–æ–∫–æ–¥–∏–Ω–≥ –¥–ª—è: {city_name}")
                return coords
        except Exception as e:
            logger.warning(f"–û—à–∏–±–∫–∞ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ –¥–ª—è {city_name}: {e}")

        # 4. –†–µ–∑–µ—Ä–≤–Ω—ã–π –≤–∞—Ä–∏–∞–Ω—Ç - –ú–æ—Å–∫–≤–∞
        logger.warning(f"–ù–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è {city_name}, –∏—Å–ø–æ–ª—å–∑—É–µ–º –ú–æ—Å–∫–≤—É")
        return (55.7558, 37.6173, 156)

    def _geocode_city(self, city_name: str) -> Tuple[float, float, float]:
        """
        –ì–µ–æ–∫–æ–¥–∏–Ω–≥ –≥–æ—Ä–æ–¥–∞ —á–µ—Ä–µ–∑ Nominatim API (OpenStreetMap)
        """
        # –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–∞–Ω—É –¥–ª—è –ª—É—á—à–µ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è
        search_query = f"{city_name}, –†–æ—Å—Å–∏—è"
        encoded_query = quote(search_query)

        url = f"https://nominatim.openstreetmap.org/search?q={encoded_query}&format=json&limit=1"

        headers = {
            'User-Agent': 'AstrologyBot/1.0 (leostuchchi@example.com)',
            'Accept': 'application/json'
        }

        try:
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()

            data = response.json()

            if data and len(data) > 0:
                lat = float(data[0]['lat'])
                lon = float(data[0]['lon'])

                # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—ã—Å–æ—Ç—É (–ø—Ä–∏–º–µ—Ä–Ω–æ, —Ç–∞–∫ –∫–∞–∫ Nominatim –Ω–µ –¥–∞–µ—Ç —Ç–æ—á–Ω—É—é –≤—ã—Å–æ—Ç—É)
                elevation = self._estimate_elevation(lat, lon)

                logger.info(f"–ì–µ–æ–∫–æ–¥–∏–Ω–≥ —É—Å–ø–µ—à–µ–Ω: {city_name} -> {lat}, {lon}, {elevation}–º")
                return (lat, lon, elevation)

        except requests.exceptions.RequestException as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ –¥–ª—è {city_name}: {e}")
        except (KeyError, ValueError, IndexError) as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ—Ç–≤–µ—Ç–∞ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ –¥–ª—è {city_name}: {e}")

        return None

    def _estimate_elevation(self, lat: float, lon: float) -> float:
        """
        –ü—Ä–∏–º–µ—Ä–Ω–∞—è –æ—Ü–µ–Ω–∫–∞ –≤—ã—Å–æ—Ç—ã –Ω–∞–¥ —É—Ä–æ–≤–Ω–µ–º –º–æ—Ä—è.
        –î–ª—è —Ç–æ—á–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ API.
        """
        # –ü—Ä–æ—Å—Ç–∞—è –ª–æ–≥–∏–∫–∞: –ø—Ä–∏–±—Ä–µ–∂–Ω—ã–µ –≥–æ—Ä–æ–¥–∞ ~0–º, –≥–æ—Ä–Ω—ã–µ ~500–º, —Ä–∞–≤–Ω–∏–Ω–Ω—ã–µ ~100-200–º
        if 43 <= lat <= 49 and 131 <= lon <= 142:  # –î–∞–ª—å–Ω–∏–π –í–æ—Å—Ç–æ–∫
            return 200
        elif 53 <= lat <= 58 and 48 <= lon <= 56:  # –ü–æ–≤–æ–ª–∂—å–µ
            return 100
        elif 55 <= lat <= 57 and 37 <= lon <= 40:  # –¶–µ–Ω—Ç—Ä–∞–ª—å–Ω–∞—è –†–æ—Å—Å–∏—è
            return 150
        elif 44 <= lat <= 46 and 38 <= lon <= 40:  # –Æ–≥ –†–æ—Å—Å–∏–∏
            return 50
        elif 51 <= lat <= 53 and 103 <= lon <= 108:  # –ë–∞–π–∫–∞–ª
            return 500
        else:
            return 100  # –°—Ä–µ–¥–Ω—è—è –≤—ã—Å–æ—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é

    def _geocode_fallback(self, city_name: str) -> Tuple[float, float, float]:
        """
        –†–µ–∑–µ—Ä–≤–Ω—ã–π –º–µ—Ç–æ–¥ –≥–µ–æ–∫–æ–¥–∏–Ω–≥–∞ —á–µ—Ä–µ–∑ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–µ—Ä–≤–∏—Å
        """
        try:
            # –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π —Å–µ—Ä–≤–∏—Å - GeoNames (—Ç—Ä–µ–±—É–µ—Ç API key)
            # –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
            pass
        except Exception as e:
            logger.warning(f"–†–µ–∑–µ—Ä–≤–Ω—ã–π –≥–µ–æ–∫–æ–¥–∏–Ω–≥ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")

        return None

    def add_city_to_cache(self, city_name: str, lat: float, lon: float, elevation: float = 100):
        """
        –†—É—á–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ –≥–æ—Ä–æ–¥–∞ –≤ –∫—ç—à
        """
        city_lower = city_name.strip().lower()
        self.coordinates_cache[city_lower] = (lat, lon, elevation)
        logger.info(f"–ì–æ—Ä–æ–¥ –¥–æ–±–∞–≤–ª–µ–Ω –≤ –∫—ç—à: {city_name}")

    def get_cached_cities(self) -> List[str]:
        """
        –ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –∑–∞–∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –≥–æ—Ä–æ–¥–æ–≤
        """
        return list(self.coordinates_cache.keys())

    # –û—Å—Ç–∞–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –∫–ª–∞—Å—Å–∞ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
    def calculate_planet_positions(self, jd_ut: float) -> Dict[str, Dict]:
        positions = {}
        for planet_id, name in self.planets_ml.items():
            try:
                flags = swe.FLG_SWIEPH | swe.FLG_SPEED
                pos, ret_flags = swe.calc_ut(jd_ut, planet_id, flags)
                lon = pos[0] % 360
                sign_index = floor(lon / 30)
                positions[name] = {
                    'longitude': round(lon, 6),
                    'sign': self.zodiac_signs[sign_index],
                    'sign_index': sign_index,
                    'position_in_sign': round(lon % 30, 4),
                    'retrograde': pos[3] < 0,
                    'speed': round(pos[3], 6)
                }
            except Exception as e:
                logger.warning(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –¥–ª—è {name}: {e}")
                continue
        return positions

    def calculate_houses_ml(self, jd_ut: float, lat: float, lon: float) -> Dict:
        try:
            hsys = b'P'
            cusps, ascmc = swe.houses(jd_ut, lat, lon, hsys)
            houses = {}
            for i, cusp in enumerate(cusps[:12]):
                cusp_deg = cusp % 360
                sign_index = floor(cusp_deg / 30)
                houses[i + 1] = {
                    'cusp_longitude': round(cusp_deg, 6),
                    'sign': self.zodiac_signs[sign_index],
                    'sign_index': sign_index,
                    'position_in_sign': round(cusp_deg % 30, 4)
                }
            return {
                'houses': houses,
                'ascendant': round(ascmc[0] % 360, 6),
                'midheaven': round(ascmc[1] % 360, 6),
                'house_system': 'Placidus'
            }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –¥–æ–º–æ–≤: {e}")
            return self._get_default_houses()

    def _get_default_houses(self) -> Dict:
        houses = {}
        for i in range(12):
            houses[i + 1] = {
                'cusp_longitude': round(i * 30.0, 6),
                'sign': self.zodiac_signs[i],
                'sign_index': i,
                'position_in_sign': 0.0
            }
        return {
            'houses': houses,
            'ascendant': 0.0,
            'midheaven': 0.0,
            'house_system': 'Placidus'
        }

    def calculate_aspects_ml(self, planets: Dict, asc: float, mc: float) -> List[Dict]:
        aspects = []
        all_points = {**planets}
        all_points['Ascendant'] = {'longitude': asc}
        all_points['Midheaven'] = {'longitude': mc}
        point_names = list(all_points.keys())
        for i in range(len(point_names)):
            for j in range(i + 1, len(point_names)):
                p1, p2 = point_names[i], point_names[j]
                lon1, lon2 = all_points[p1]['longitude'], all_points[p2]['longitude']
                distance = abs(lon1 - lon2)
                angle = min(distance, 360 - distance)
                for aspect_angle, (aspect_name, orb) in self.aspects_ml.items():
                    if abs(angle - aspect_angle) <= orb:
                        aspects.append({
                            'point1': p1,
                            'point2': p2,
                            'aspect': aspect_name,
                            'exact_angle': aspect_angle,
                            'actual_angle': round(angle, 4),
                            'orb': round(abs(angle - aspect_angle), 4),
                            'strength': 1.0 - (abs(angle - aspect_angle) / orb)
                        })
                        break
        aspects.sort(key=lambda x: x['strength'], reverse=True)
        return aspects

    def get_planet_house_placement(self, planets: Dict, houses: Dict) -> Dict:
        house_placement = {}
        for planet_name, planet_data in planets.items():
            planet_lon = planet_data['longitude']
            for house_num, house_data in houses.items():
                next_house_num = house_num + 1 if house_num < 12 else 1
                next_house_lon = houses[next_house_num]['cusp_longitude']
                current_lon = house_data['cusp_longitude']
                if next_house_lon < current_lon:
                    next_house_lon += 360
                    adjusted_planet_lon = planet_lon + 360 if planet_lon < current_lon else planet_lon
                else:
                    adjusted_planet_lon = planet_lon
                if current_lon <= adjusted_planet_lon < next_house_lon:
                    house_placement[planet_name] = house_num
                    break
            else:
                house_placement[planet_name] = 1
        return house_placement

    def calculate_natal_chart_ml(self, city_name: str, birth_datetime_local: datetime, timezone_str: str) -> Dict[
        str, Any]:
        try:
            lat, lon, elevation = self.get_city_coordinates(city_name)
            local_tz = pytz.timezone(timezone_str)
            birth_local = local_tz.localize(birth_datetime_local)
            birth_utc = birth_local.astimezone(pytz.utc)
            jd_ut = swe.julday(
                birth_utc.year,
                birth_utc.month,
                birth_utc.day,
                birth_utc.hour + birth_utc.minute / 60 + birth_utc.second / 3600
            )
            planets = self.calculate_planet_positions(jd_ut)
            houses_data = self.calculate_houses_ml(jd_ut, lat, lon)
            house_placement = self.get_planet_house_placement(planets, houses_data['houses'])
            aspects = self.calculate_aspects_ml(planets, houses_data['ascendant'], houses_data['midheaven'])
            return {
                'metadata': {
                    'location': {
                        'city': city_name,
                        'lat': round(lat, 4),
                        'lon': round(lon, 4),
                        'elevation': round(elevation, 1)
                    },
                    'datetime': {
                        'local': birth_local.isoformat(),
                        'utc': birth_utc.isoformat(),
                        'jd': round(jd_ut, 6)
                    },
                    'calculation': {
                        'house_system': houses_data['house_system'],
                        'ephemeris': 'DE441'
                    }
                },
                'planets': planets,
                'houses': houses_data['houses'],
                'angles': {
                    'ascendant': {
                        'longitude': houses_data['ascendant'],
                        'sign': self.zodiac_signs[floor(houses_data['ascendant'] / 30)],
                        'sign_index': floor(houses_data['ascendant'] / 30)
                    },
                    'midheaven': {
                        'longitude': houses_data['midheaven'],
                        'sign': self.zodiac_signs[floor(houses_data['midheaven'] / 30)],
                        'sign_index': floor(houses_data['midheaven'] / 30)
                    }
                },
                'placements': house_placement,
                'aspects': aspects,
                'ml_features': {
                    'sign_distribution': self._get_sign_distribution(planets, houses_data),
                    'aspect_patterns': self._get_aspect_patterns(aspects),
                    'element_balance': self._get_element_balance(planets)
                }
            }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Ä–∞—Å—á–µ—Ç–∞ –Ω–∞—Ç–∞–ª—å–Ω–æ–π –∫–∞—Ä—Ç—ã: {e}")
            raise

    def _get_sign_distribution(self, planets: Dict, houses_data: Dict) -> Dict[str, int]:
        distribution = {sign: 0 for sign in self.zodiac_signs}
        for planet_data in planets.values():
            distribution[planet_data['sign']] += 1
        return distribution

    def _get_aspect_patterns(self, aspects: List[Dict]) -> Dict[str, int]:
        patterns = {
            'conjunctions': 0,
            'squares': 0,
            'trines': 0,
            'oppositions': 0,
            'sextiles': 0
        }
        for aspect in aspects:
            if aspect['aspect'] in patterns:
                patterns[aspect['aspect']] += 1
        return patterns

    def _get_element_balance(self, planets: Dict) -> Dict[str, int]:
        elements = {
            'fire': ['Aries', 'Leo', 'Sagittarius'],
            'earth': ['Taurus', 'Virgo', 'Capricorn'],
            'air': ['Gemini', 'Libra', 'Aquarius'],
            'water': ['Cancer', 'Scorpio', 'Pisces']
        }
        balance = {element: 0 for element in elements}
        for planet_data in planets.values():
            for element, signs in elements.items():
                if planet_data['sign'] in signs:
                    balance[element] += 1
                    break
        return balance

    def save_ml_chart(self, natal_chart: Dict, filename: str = 'natal_chart_ml.json') -> None:
        import json
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(natal_chart, f, ensure_ascii=False, indent=2, separators=(',', ':'))
        logger.info(f"ML-–Ω–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞: {filename}")

predictions.py:

from math import floor
import json
from datetime import date, datetime
import swisseph as swe
from sqlalchemy.future import select

from backend.database import async_session, NatalPredictions


class AstroPredictor:
    def __init__(self, natal_chart):
        self.natal_chart = natal_chart
        self.planets_ml = {
            swe.SUN: 'Sun', swe.MOON: 'Moon', swe.MERCURY: 'Mercury',
            swe.VENUS: 'Venus', swe.MARS: 'Mars', swe.JUPITER: 'Jupiter',
            swe.SATURN: 'Saturn', swe.URANUS: 'Uranus',
            swe.NEPTUNE: 'Neptune', swe.PLUTO: 'Pluto'
        }
        self.planet_names_to_ids = {v: k for k, v in self.planets_ml.items()}

    def calculate_transits(self, target_date):
        jd_target = swe.julday(target_date.year, target_date.month, target_date.day, 12.0)
        transits = {}
        for planet_id, name in self.planets_ml.items():
            pos, _ = swe.calc_ut(jd_target, planet_id, swe.FLG_SWIEPH)
            lon = pos[0] % 360
            transits[name] = {
                'longitude': lon,
                'sign': self.get_sign_from_longitude(lon),
                'position_in_sign': lon % 30,
                'retrograde': pos[3] < 0
            }
        return transits

    def get_sign_from_longitude(self, longitude):
        signs = ["Aries", "Taurus", "Gemini", "Cancer", "Leo", "Virgo",
                 "Libra", "Scorpio", "Sagittarius", "Capricorn", "Aquarius", "Pisces"]
        return signs[floor(longitude / 30)]

    def analyze_aspects(self, transits, natal_positions):
        aspects = []
        for t_planet, t_data in transits.items():
            for n_planet, n_data in natal_positions.items():
                if t_planet == n_planet:
                    continue
                t_lon = t_data['longitude']
                n_lon = n_data['longitude']
                distance = abs(t_lon - n_lon)
                angle = min(distance, 360 - distance)
                aspect_info = self.check_aspect(angle)
                if aspect_info:
                    aspects.append({
                        'transit_planet': t_planet,
                        'natal_planet': n_planet,
                        'aspect': aspect_info[0],
                        'exact_angle': aspect_info[1],
                        'actual_angle': angle,
                        'orb': abs(angle - aspect_info[1]),
                        'strength': 1.0 - (abs(angle - aspect_info[1]) / aspect_info[2])
                    })
        aspects.sort(key=lambda x: x['strength'], reverse=True)
        return aspects

    def check_aspect(self, angle):
        aspects = {
            0: ('conjunction', 0, 8),
            60: ('sextile', 60, 6),
            90: ('square', 90, 8),
            120: ('trine', 120, 8),
            180: ('opposition', 180, 8)
        }
        for aspect_angle, (name, exact, orb) in aspects.items():
            if abs(angle - aspect_angle) <= orb:
                return (name, exact, orb)
        return None

    def generate_prediction(self, target_date):
        """–û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –†–ê–°–ß–ï–¢–û–í"""
        try:
            # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç—Ä–∞–Ω–∑–∏—Ç—ã
            transits = self.calculate_transits(target_date)

            # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Ç–∞–ª—å–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏
            natal_positions = {}
            for name, data in self.natal_chart['planets'].items():
                if name in self.planets_ml.values():
                    natal_positions[name] = {
                        'longitude': data['longitude'],
                        'sign': data['sign'],
                        'position_in_sign': data['position_in_sign']
                    }

            # –î–æ–±–∞–≤–ª—è–µ–º —É–≥–ª—ã –∫–∞—Ä—Ç—ã
            if 'angles' in self.natal_chart:
                natal_positions['Ascendant'] = {
                    'longitude': self.natal_chart['angles']['ascendant']['longitude'],
                    'sign': self.natal_chart['angles']['ascendant']['sign'],
                    'position_in_sign': self.natal_chart['angles']['ascendant']['longitude'] % 30
                }

            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∞—Å–ø–µ–∫—Ç—ã
            aspects = self.analyze_aspects(transits, natal_positions)

            return {
                'prediction_date': target_date.strftime('%Y-%m-%d'),
                'transits': transits,
                'aspects': aspects,
                'aspects_count': len(aspects),
                'strong_aspects_count': len([a for a in aspects if a['strength'] > 0.7]),
                'retrograde_planets': [p for p, data in transits.items() if data.get('retrograde')]
            }

        except Exception as e:
            # –í —Å–ª—É—á–∞–µ –æ—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç—ã–µ –¥–∞–Ω–Ω—ã–µ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –æ—à–∏–±–∫–µ
            return {
                'prediction_date': target_date.strftime('%Y-%m-%d'),
                'transits': {},
                'aspects': [],
                'aspects_count': 0,
                'strong_aspects_count': 0,
                'retrograde_planets': [],
                'calculation_error': True,
                'error_message': str(e)
            }

    async def save_prediction_to_db(self, telegram_id: int, prediction_date: date):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
        prediction = self.generate_prediction(prediction_date)
        async with async_session() as session:
            result = await session.execute(
                select(NatalPredictions).where(NatalPredictions.telegram_id == telegram_id)
            )
            existing_record = result.scalar_one_or_none()

            if existing_record:
                existing_record.predictions = prediction
                existing_record.updated_at = datetime.utcnow()
            else:
                new_record = NatalPredictions(
                    telegram_id=telegram_id,
                    predictions=prediction,
                    assistant_data={},
                )
                session.add(new_record)

            await session.commit()
        return prediction

prediction_services.py:

from backend.database import async_session, NatalPredictions
from backend.predictions import AstroPredictor
from backend.chart_services import get_user_natal_chart
from backend.matrix_services import get_user_matrix
from backend.biorhythm_services import calculate_and_save_biorhythms
from sqlalchemy.future import select
from sqlalchemy import func, and_
import logging
import json
from datetime import datetime, date

logger = logging.getLogger(__name__)


class DataCombiner:
    """–ö–ª–∞—Å—Å –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –∞—Å—Ç—Ä–æ–ª–æ–≥–∏–∏ –∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤"""

    def __init__(self):
        pass

    def combine_calculation_data(self, astro_prediction: dict, biorhythm_data: dict) -> dict:
        """–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∞—Å—Ç—Ä–æ–ª–æ–≥–∏–∏ –∏ –±–∏–æ—Ä–∏—Ç–º–æ–≤"""

        return {
            'calculation_date': datetime.now().isoformat(),
            'target_date': astro_prediction.get('prediction_date', datetime.now().date().isoformat()),
            'astro_data': {
                'transits_count': len(astro_prediction.get('transits', {})),
                'aspects_count': astro_prediction.get('aspects_count', 0),
                'strong_aspects_count': astro_prediction.get('strong_aspects_count', 0),
                'retrograde_planets': astro_prediction.get('retrograde_planets', []),
                'key_aspects': astro_prediction.get('aspects', [])[:5]
            },
            'biorhythm_data': {
                'overall_energy': biorhythm_data.get('overall_energy', {}),
                'physical_cycle': biorhythm_data.get('cycles', {}).get('physical', {}),
                'emotional_cycle': biorhythm_data.get('cycles', {}).get('emotional', {}),
                'intellectual_cycle': biorhythm_data.get('cycles', {}).get('intellectual', {}),
                'critical_days_count': len(biorhythm_data.get('critical_days', [])),
                'peak_days_count': len(biorhythm_data.get('peak_days', []))
            },
            'calculation_metadata': {
                'calculation_timestamp': datetime.now().isoformat(),
                'data_sources': ['astrology', 'biorhythms'],
                'calculation_methods': ['swiss_ephemeris', 'sine_wave_analysis']
            }
        }


async def generate_and_save_prediction(telegram_id: int, target_date: date):
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –¥–∞—Ç—ã (–ø–µ—Ä–µ–∑–∞–ø–∏—Å—å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö)"""
    try:
        logger.info(f"üîÆ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id} –Ω–∞ {target_date}")

        # –ü–æ–ª—É—á–∞–µ–º –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        natal_data = await get_user_natal_chart(telegram_id)
        if not natal_data:
            logger.warning(f"‚ö†Ô∏è –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}")
            raise ValueError("–ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞. –°–Ω–∞—á–∞–ª–∞ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–∞—Ç–∞–ª—å–Ω—É—é –∫–∞—Ä—Ç—É —Å –ø–æ–º–æ—â—å—é /start")

        logger.info(f"‚úÖ –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞ –Ω–∞–π–¥–µ–Ω–∞ –¥–ª—è {telegram_id}")

        # –ü–æ–ª—É—á–∞–µ–º –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—É –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        matrix_data = await get_user_matrix(telegram_id)
        logger.info(f"‚úÖ –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞ –ø–æ–ª—É—á–µ–Ω–∞ –¥–ª—è {telegram_id}")

        # –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –±–∏–æ—Ä–∏—Ç–º—ã –Ω–∞ —Ü–µ–ª–µ–≤—É—é –¥–∞—Ç—É
        biorhythm_data = await calculate_and_save_biorhythms(telegram_id, target_date)
        logger.info(f"‚úÖ –ë–∏–æ—Ä–∏—Ç–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Ü–µ–ª–µ–≤—É—é –¥–∞—Ç—É
        predictor = AstroPredictor(natal_data)
        astro_prediction = predictor.generate_prediction(target_date)
        logger.info(f"‚úÖ –ê—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

        # –û–±—ä–µ–¥–∏–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ
        combiner = DataCombiner()
        combined_data = combiner.combine_calculation_data(astro_prediction, biorhythm_data)

        logger.info(f"‚úÖ –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å–æ–∑–¥–∞–Ω—ã –¥–ª—è {telegram_id}")

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ –ë–î —Å –ü–ï–†–ï–ó–ê–ü–ò–°–¨–Æ
        async with async_session() as session:
            result = await session.execute(
                select(NatalPredictions).where(NatalPredictions.telegram_id == telegram_id)
            )
            existing_record = result.scalar_one_or_none()

            # –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
            prediction_data = {
                'calculation_date': datetime.now().isoformat(),
                'target_date': target_date.isoformat(),
                'natal_chart': natal_data,
                'psyho_matrix': matrix_data,
                'daily_calculations': combined_data
            }

            if existing_record:
                # –ü–ï–†–ï–ó–ê–ü–ò–°–´–í–ê–ï–ú —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å—å
                existing_record.predictions = prediction_data
                existing_record.updated_at = func.now()
                logger.info(f"üìù –ü–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω—ã –¥–∞–Ω–Ω—ã–µ –¥–ª—è {telegram_id} –Ω–∞ {target_date}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
                new_record = NatalPredictions(
                    telegram_id=telegram_id,
                    predictions=prediction_data,
                    assistant_data={},
                )
                session.add(new_record)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω—ã –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è {telegram_id} –Ω–∞ {target_date}")

            await session.commit()
            logger.info(f"üíæ –î–∞–Ω–Ω—ã–µ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ –ë–î –¥–ª—è {telegram_id}")

        return prediction_data

    except ValueError as e:
        logger.warning(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–ª—è {telegram_id}: {e}")
        raise
    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
        raise Exception(f"–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ä–∞—Å—á–µ—Ç–æ–≤: {str(e)}")


async def get_user_predictions(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(NatalPredictions).where(NatalPredictions.telegram_id == telegram_id)
            )
            predictions = result.scalar_one_or_none()

            if predictions:
                return predictions.predictions
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö {telegram_id}: {e}")
        return None


async def get_todays_prediction(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ —Å–µ–≥–æ–¥–Ω—è (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)"""
    try:
        today = datetime.now().date()
        return await generate_and_save_prediction(telegram_id, today)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–µ–≥–æ–¥–Ω—è—à–Ω–∏—Ö –¥–∞–Ω–Ω—ã—Ö {telegram_id}: {e}")
        return None


async def get_date_prediction(telegram_id: int, target_date: date):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –¥–∞—Ç—É"""
    try:
        # –í—Å–µ–≥–¥–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ (–ø–µ—Ä–µ–∑–∞–ø–∏—Å—å)
        return await generate_and_save_prediction(telegram_id, target_date)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–∞ {target_date} –¥–ª—è {telegram_id}: {e}")
        return None


async def format_data_for_user(prediction: dict) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é"""
    if not prediction:
        return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ —Ä–∞—Å—á–µ—Ç–æ–≤"

    try:
        daily_data = prediction.get('daily_calculations', {})
        target_date_str = daily_data.get('target_date', '—Å–µ–≥–æ–¥–Ω—è')

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —Å—Ç—Ä–æ–∫—É –¥–∞—Ç—ã –≤ —á–∏—Ç–∞–µ–º—ã–π —Ñ–æ—Ä–º–∞—Ç
        try:
            target_date = datetime.fromisoformat(target_date_str).date()
            formatted_date = target_date.strftime('%d.%m.%Y')
        except:
            formatted_date = target_date_str

        lines = []
        lines.append(f"üìä **–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ä–∞—Å—á–µ—Ç–æ–≤ –Ω–∞ {formatted_date}**")
        lines.append("")

        # –ë–∏–æ—Ä–∏—Ç–º—ã
        biorhythms = daily_data.get('biorhythm_data', {})
        if biorhythms:
            overall_energy = biorhythms.get('overall_energy', {})
            lines.append(
                f"‚ö° **–û–±—â–∞—è —ç–Ω–µ—Ä–≥–∏—è:** {overall_energy.get('percentage', 0):.1f}%")

            physical = biorhythms.get('physical_cycle', {})
            emotional = biorhythms.get('emotional_cycle', {})
            intellectual = biorhythms.get('intellectual_cycle', {})

            lines.append(
                f"üí™ **–§–∏–∑–∏—á–µ—Å–∫–∏–π —Ü–∏–∫–ª:** {physical.get('percentage', 0):.1f}% ({physical.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è')})")
            lines.append(
                f"üòä **–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª:** {emotional.get('percentage', 0):.1f}% ({emotional.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è')})")
            lines.append(
                f"üß† **–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π —Ü–∏–∫–ª:** {intellectual.get('percentage', 0):.1f}% ({intellectual.get('phase', '–Ω–µ–π—Ç—Ä–∞–ª—å–Ω–∞—è')})")
            lines.append("")

        # –ê—Å—Ç—Ä–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ –¥–∞–Ω–Ω—ã–µ
        astro_data = daily_data.get('astro_data', {})
        if astro_data:
            lines.append(
                f"üåü **–ê—Å—Ç—Ä–æ–ª–æ–≥–∏—è:** {astro_data.get('aspects_count', 0)} –∞—Å–ø–µ–∫—Ç–æ–≤, {astro_data.get('strong_aspects_count', 0)} —Å–∏–ª—å–Ω—ã—Ö")

            retrograde_planets = astro_data.get('retrograde_planets', [])
            if retrograde_planets:
                lines.append(f"üîÑ **–†–µ—Ç—Ä–æ–≥—Ä–∞–¥–Ω—ã–µ –ø–ª–∞–Ω–µ—Ç—ã:** {', '.join(retrograde_planets)}")

            lines.append("")

        lines.append("üìà *–í—Å–µ –¥–∞–Ω–Ω—ã–µ –≥–æ—Ç–æ–≤—ã –¥–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π*")

        return "\n".join(lines)

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")
        return "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏–∏ –¥–∞–Ω–Ω—ã—Ö —Ä–∞—Å—á–µ—Ç–æ–≤"


async def format_data_for_model(telegram_id: int, user_profile: dict, prediction: dict) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –º–æ–¥–µ–ª–∏ –ò–ò"""
    if not prediction:
        return "‚ùå No calculation data available"

    try:
        model_data = {
            'user_profile': {
                'telegram_id': telegram_id,
                'gender': user_profile.get('gender'),
                'profession': user_profile.get('profession'),
                'job_position': user_profile.get('job_position'),
                'current_city': user_profile.get('current_city'),
                'birth_date': user_profile.get('birth_date').isoformat() if user_profile.get('birth_date') else None,
                'birth_city': user_profile.get('birth_city')
            },
            'natal_chart': prediction.get('natal_chart', {}),
            'psyho_matrix': prediction.get('psyho_matrix', {}),
            'daily_calculations': prediction.get('daily_calculations', {}),
            'target_date': prediction.get('target_date'),
            'timestamp': datetime.now().isoformat()
        }

        # –ö—Ä–∞—Å–∏–≤—ã–π –≤—ã–≤–æ–¥ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        print("\n" + "=" * 80)
        print("ü§ñ DATA FOR AI MODEL:")
        print("=" * 80)
        print(f"üë§ User ID: {telegram_id}")
        print(f"üìÖ Target Date: {prediction.get('target_date', 'Unknown')}")
        print(f"üíº Profession: {user_profile.get('profession', 'Not specified')}")
        print(f"üìã Position: {user_profile.get('job_position', 'Not specified')}")
        print(f"üèôÔ∏è City: {user_profile.get('current_city', 'Not specified')}")

        # –ù–∞—Ç–∞–ª—å–Ω–∞—è –∫–∞—Ä—Ç–∞
        natal_chart = prediction.get('natal_chart', {})
        if natal_chart:
            planets = natal_chart.get('planets', {})
            print(f"\nüåü Natal Chart: {len(planets)} planets calculated")
            print(f"   üìç Birth location: {natal_chart.get('metadata', {}).get('location', {}).get('city', 'Unknown')}")

        # –ü—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü–∞
        matrix = prediction.get('psyho_matrix', {})
        if matrix:
            basic_numbers = matrix.get('basic_numbers', {})
            print(f"üî¢ Psyho Matrix: First number: {basic_numbers.get('first', 'N/A')}")

        # –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–µ —Ä–∞—Å—á–µ—Ç—ã
        daily = prediction.get('daily_calculations', {})
        if daily:
            biorhythms = daily.get('biorhythm_data', {})
            astro = daily.get('astro_data', {})
            print(f"üìä Daily Calculations:")
            print(f"   ‚ö° Energy: {biorhythms.get('overall_energy', {}).get('percentage', 0):.1f}%")
            print(f"   üåü Aspects: {astro.get('aspects_count', 0)}")

        print("=" * 80)
        print("JSON Data for AI Model:")
        print("=" * 80)
        print(json.dumps(model_data, ensure_ascii=False, indent=2))
        print("=" * 80 + "\n")

        return json.dumps(model_data, ensure_ascii=False)

    except Exception as e:
        logger.error(f"‚ùå Error formatting data for model: {e}")
        return json.dumps({'error': str(e)})


async def get_prediction_statistics(telegram_id: int) -> dict:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        prediction = await get_user_predictions(telegram_id)
        if not prediction:
            return {}

        daily_data = prediction.get('daily_calculations', {})
        return {
            'last_calculation_date': prediction.get('calculation_date'),
            'target_date': prediction.get('target_date'),
            'biorhythm_energy': daily_data.get('biorhythm_data', {}).get('overall_energy', {}).get('percentage', 0),
            'astro_aspects_count': daily_data.get('astro_data', {}).get('aspects_count', 0)
        }

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –¥–ª—è {telegram_id}: {e}")
        return {}


async def validate_prediction_data(telegram_id: int) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö"""
    try:
        prediction = await get_user_predictions(telegram_id)
        if not prediction:
            return False

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –ø–æ–ª–µ–π
        required_fields = ['natal_chart', 'psyho_matrix', 'daily_calculations', 'target_date']
        for field in required_fields:
            if field not in prediction:
                return False

        return True

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è {telegram_id}: {e}")
        return False


async def cleanup_old_predictions():
    """–û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö"""
    try:
        logger.info("üîÑ –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö –¥–∞–Ω–Ω—ã—Ö –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤ —Ç–µ–∫—É—â–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–µ")
        return 0

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö: {e}")
        return 0

psyho_matrix.py:

from datetime import datetime
import logging

logger = logging.getLogger(__name__)


class PsyhoMatrixCalculator:
    def __init__(self):
        pass

    def calculate_matrix(self, birth_date: datetime.date):
        """–†–∞—Å—á–µ—Ç –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ø–æ –¥–∞—Ç–µ —Ä–æ–∂–¥–µ–Ω–∏—è (–Ω—É–º–µ—Ä–æ–ª–æ–≥–∏—è –ü–∏—Ñ–∞–≥–æ—Ä–∞)"""
        day = birth_date.day
        month = birth_date.month
        year = birth_date.year

        # –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –¥–∞—Ç—É –≤ —Å—Ç—Ä–æ–∫—É –¥–ª—è —Ä–∞—Å—á–µ—Ç–æ–≤
        date_str = f"{day:02d}{month:02d}{year}"

        # –ü–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ - —Å—É–º–º–∞ –≤—Å–µ—Ö —Ü–∏—Ñ—Ä –¥–∞—Ç—ã
        first_number = sum(int(d) for d in date_str)

        # –í—Ç–æ—Ä–æ–µ —á–∏—Å–ª–æ - —Å—É–º–º–∞ —Ü–∏—Ñ—Ä –ø–µ—Ä–≤–æ–≥–æ —á–∏—Å–ª–∞
        second_number = sum(int(d) for d in str(first_number))

        # –¢—Ä–µ—Ç—å–µ —á–∏—Å–ª–æ - –ø–µ—Ä–≤–æ–µ —á–∏—Å–ª–æ –º–∏–Ω—É—Å —É–¥–≤–æ–µ–Ω–Ω–∞—è –ø–µ—Ä–≤–∞—è —Ü–∏—Ñ—Ä–∞ –¥–Ω—è —Ä–æ–∂–¥–µ–Ω–∏—è
        first_digit_of_day = day // 10
        third_number = first_number - 2 * first_digit_of_day

        # –ß–µ—Ç–≤–µ—Ä—Ç–æ–µ —á–∏—Å–ª–æ - —Å—É–º–º–∞ —Ü–∏—Ñ—Ä —Ç—Ä–µ—Ç—å–µ–≥–æ —á–∏—Å–ª–∞
        fourth_number = sum(int(d) for d in str(third_number))

        # –°—Ç—Ä–æ–∏–º –º–∞—Ç—Ä–∏—Ü—É 3x3 –ø–æ –º–µ—Ç–æ–¥—É –ü–∏—Ñ–∞–≥–æ—Ä–∞
        matrix_numbers = self._build_pythagoras_matrix(day, month, year)

        # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –†–ê–°–ß–ï–¢–û–í
        matrix_data = {
            'basic_numbers': {
                'first': first_number,
                'second': second_number,
                'third': third_number,
                'fourth': fourth_number
            },
            'pythagoras_matrix': matrix_numbers,
            'digit_counts': self._calculate_digit_counts(matrix_numbers),
            'calculated_at': datetime.now().isoformat()
        }

        return matrix_data

    def _build_pythagoras_matrix(self, day: int, month: int, year: int):
        """–ü–æ—Å—Ç—Ä–æ–µ–Ω–∏–µ –ø—Å–∏—Ö–æ–º–∞—Ç—Ä–∏—Ü—ã –ü–∏—Ñ–∞–≥–æ—Ä–∞ 3x3"""
        # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —Ü–∏—Ñ—Ä—ã –¥–∞—Ç—ã —Ä–æ–∂–¥–µ–Ω–∏—è
        all_digits = []
        all_digits.extend([int(d) for d in str(day)])
        all_digits.extend([int(d) for d in str(month)])
        all_digits.extend([int(d) for d in str(year)])

        # –°—á–∏—Ç–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–∂–¥–æ–π —Ü–∏—Ñ—Ä—ã –æ—Ç 1 –¥–æ 9
        matrix = {}
        for i in range(1, 10):
            matrix[str(i)] = all_digits.count(i)

        return matrix

    def _calculate_digit_counts(self, matrix):
        """–†–∞—Å—á–µ—Ç —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ —Ü–∏—Ñ—Ä–∞–º"""
        return {
            'total_digits': sum(matrix.values()),
            'strong_digits': [digit for digit, count in matrix.items() if count >= 2],
            'missing_digits': [digit for digit in map(str, range(1, 10)) if matrix.get(digit, 0) == 0]
        }

user_services.py:  

from backend.database import async_session, User
from sqlalchemy.future import select
from sqlalchemy import func  # ‚Üê –î–û–ë–ê–í–ò–¢–¨ –≠–¢–û–¢ –ò–ú–ü–û–†–¢
from datetime import datetime  # ‚Üê –î–û–ë–ê–í–ò–¢–¨ –î–õ–Ø calculated_at
import logging

logger = logging.getLogger(__name__)


async def create_or_update_user(
        telegram_id: int,
        birth_date,
        birth_time,
        birth_city: str,
        profession: str = None,
        job_position: str = None,
        current_city: str = None,
        gender: str = None
):
    """–°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user.birth_date = birth_date
                user.birth_time = birth_time
                user.birth_city = birth_city
                if profession:
                    user.profession = profession
                if job_position:
                    user.job_position = job_position
                if current_city:
                    user.current_city = current_city
                if gender is not None:
                    user.gender = gender
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id}")
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
                user = User(
                    telegram_id=telegram_id,
                    birth_date=birth_date,
                    birth_time=birth_time,
                    birth_city=birth_city,
                    profession=profession,
                    job_position=job_position,
                    current_city=current_city,
                    gender=gender,
                    request_count=0
                )
                session.add(user)
                logger.info(f"üÜï –°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id}")

            await session.commit()
            return user

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–∞–±–æ—Ç–µ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º {telegram_id}: {e}")
        raise


async def get_user_profile(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                return {
                    'telegram_id': user.telegram_id,
                    'birth_date': user.birth_date,
                    'birth_time': user.birth_time,
                    'birth_city': user.birth_city,
                    'profession': user.profession,
                    'job_position': user.job_position,
                    'current_city': user.current_city,
                    'gender': user.gender,
                    'request_count': user.request_count or 0,
                    'created_at': user.created_at
                }
            return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–∏–ª—è {telegram_id}: {e}")
        return None


async def update_user_profession(telegram_id: int, profession: str, job_position: str = None):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                user.profession = profession
                if job_position:
                    user.job_position = job_position
                await session.commit()
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω—ã –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è {telegram_id}")
                return user
            else:
                raise ValueError("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø—Ä–æ—Ñ–µ—Å—Å–∏–∏ {telegram_id}: {e}")
        raise


async def increment_request_count(telegram_id: int):
    """–£–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç —Å—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                current_count = user.request_count or 0
                user.request_count = current_count + 1
                await session.commit()
                logger.info(f"üìà –£–≤–µ–ª–∏—á–µ–Ω —Å—á–µ—Ç—á–∏–∫ –æ–±—Ä–∞—â–µ–Ω–∏–π –¥–ª—è {telegram_id}: {current_count} -> {user.request_count}")
                return user.request_count
            else:
                logger.warning(f"‚ö†Ô∏è –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å {telegram_id} –Ω–µ –Ω–∞–π–¥–µ–Ω –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ —Å—á–µ—Ç—á–∏–∫–∞")
                return None

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–≤–µ–ª–∏—á–µ–Ω–∏–∏ —Å—á–µ—Ç—á–∏–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏–π {telegram_id}: {e}")
        return None


async def get_user_request_count(telegram_id: int):
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –æ–±—Ä–∞—â–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User.request_count).where(User.telegram_id == telegram_id)
            )
            count = result.scalar_one_or_none()
            return count or 0

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—á–µ—Ç—á–∏–∫–∞ –æ–±—Ä–∞—â–µ–Ω–∏–π {telegram_id}: {e}")
        return 0


async def update_user_gender(telegram_id: int, gender: str):
    """–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–ª–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    try:
        async with async_session() as session:
            result = await session.execute(
                select(User).where(User.telegram_id == telegram_id)
            )
            user = result.scalar_one_or_none()

            if user:
                user.gender = gender
                await session.commit()
                logger.info(f"üìù –û–±–Ω–æ–≤–ª–µ–Ω –ø–æ–ª –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {telegram_id}: {gender}")
                return user
            else:
                raise ValueError("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω")

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª–∞ {telegram_id}: {e}")
        raise


async def get_users_statistics():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    try:
        async with async_session() as session:
            # –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            total_users_result = await session.execute(
                select(User).where(User.telegram_id.isnot(None))
            )
            total_users = len(total_users_result.scalars().all())

            # –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ —Å –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–º –ø–æ–ª–æ–º
            users_with_gender_result = await session.execute(
                select(User).where(User.gender.isnot(None))
            )
            users_with_gender = len(users_with_gender_result.scalars().all())

            # –°—Ä–µ–¥–Ω–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–±—Ä–∞—â–µ–Ω–∏–π
            avg_requests_result = await session.execute(
                select(func.avg(User.request_count)).where(User.request_count > 0)
            )
            avg_requests = avg_requests_result.scalar() or 0

            return {
                'total_users': total_users,
                'users_with_gender': users_with_gender,
                'gender_fill_rate': round((users_with_gender / total_users * 100) if total_users > 0 else 0, 2),
                'average_requests': round(avg_requests, 2),
                'calculated_at': datetime.now().isoformat()
            }

    except Exception as e:
        logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return {
            'total_users': 0,
            'users_with_gender': 0,
            'gender_fill_rate': 0,
            'average_requests': 0,
            'error': str(e)
        }
